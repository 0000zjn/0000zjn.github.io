{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"source/assets/img/alipay.jpg","path":"assets/img/alipay.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/avatar.jpg","path":"assets/img/avatar.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/empty.png","path":"assets/img/empty.png","modified":1,"renderable":0},{"_id":"source/assets/img/weixin.jpg","path":"assets/img/weixin.jpg","modified":1,"renderable":0},{"_id":"source/assets/img/favicon.ico","path":"assets/img/favicon.ico","modified":1,"renderable":0}],"Cache":[{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1590128660000},{"_id":"source/photos/index.ejs","hash":"4bff10f03e95f1c53eae2c92ccb1a77f4a65f24b","modified":1590128660000},{"_id":"source/photos/data.json","hash":"14569ddcb562f0b4a4fc87f737b9691c12e0a773","modified":1590128660000},{"_id":"source/photos/index.md","hash":"461bba0a6954f3fe9d311d0ce76509a85bd66f72","modified":1590128660000},{"_id":"source/photos/ins.css","hash":"72e696dc997e60ed2dc8b8a7daf0b8330686b1c9","modified":1590128660000},{"_id":"source/photos/ins.js","hash":"98cd2195ce46cf1d4bd67d5af549e1f852154978","modified":1590128660000},{"_id":"source/photos/lazyload.min.js","hash":"9c699878cd19d64c7611fb7ccbe342532569c863","modified":1590128660000},{"_id":"source/_posts/2018/CentOS下的SS-SSR-BBR配置.md","hash":"a9e2d4e2da675337f12e7aae9a5b4afed1ebe62e","modified":1590132029000},{"_id":"source/_posts/2018/ES6.md","hash":"0e9c42c32d698f152c45f836996fa0a5d71cee47","modified":1618019146219},{"_id":"source/_posts/2018/JSP基础.md","hash":"5deb788e85ec1e3c29dedd2429d92ddf770744f0","modified":1618019204068},{"_id":"source/_posts/2018/JavaScript基础.md","hash":"6f8530005775c672dc4c77afcc83de2edc5aad7a","modified":1618019146209},{"_id":"source/_posts/2018/Java反射.md","hash":"516db82f3da9195662c6812bc17640fcd43e9a4b","modified":1590128660000},{"_id":"source/_posts/2018/Node.js入门笔记.md","hash":"bb888a43b3e79147701d2c49bb62768f816c1029","modified":1590128660000},{"_id":"source/_posts/2018/React.md","hash":"23f9715fa139a654837f83deee11629236e8c6ed","modified":1590128660000},{"_id":"source/_posts/2019/IDEA使用技巧.md","hash":"d2caa5427fb06aa3050ee8bccddcfa9283f0cb78","modified":1618021017703},{"_id":"source/_posts/2019/Git笔记.md","hash":"76abd44842d96cf2d58e8102137df15d2b278f70","modified":1607158387556},{"_id":"source/_posts/2019/Java虚拟机.md","hash":"95f633675dc8aea666542785d3ef66f70c2373bd","modified":1590128660000},{"_id":"source/_posts/2019/Java高级开发必会的50个性能优化的细节.md","hash":"d090350fbe83fc806ec5797b6116f729e96be2ef","modified":1590128660000},{"_id":"source/_posts/2019/MySQL知识点.md","hash":"f6ba9be7eda6db10055dd7b2b76e0e615338e076","modified":1590128660000},{"_id":"source/_posts/2019/MySQL高性能优化规范建议.md","hash":"02a00f7faad25c8378c6200096f59788e2fc69ab","modified":1590128660000},{"_id":"source/_posts/2019/乐观锁和悲观锁.md","hash":"902f0fa360e253f0751412a6ee65f11c496565ad","modified":1590128660000},{"_id":"source/_posts/2019/如何从MySQL生成数据库的结构表.md","hash":"bd08bddda8f729f73b190960a7b72cb41ff5f7d8","modified":1590128660000},{"_id":"source/_posts/2019/常用Shell命令.md","hash":"c89e632f45d0a58dad358a6922c9066d27106e88","modified":1618019439896},{"_id":"source/_posts/2019/常用MySQL优化.md","hash":"cee4a2fe842171b6f7a54fab58589fb81d028ed8","modified":1590128660000},{"_id":"source/_posts/2019/建站日志.md","hash":"3d090d657f2af962ec2ff11856611e8bcd256a26","modified":1607158856880},{"_id":"source/_posts/2019/批量执行不确定数量的异步方法.md","hash":"fe3ff33cd85ded7a76df7064d88375bf5d6cc690","modified":1618019146216},{"_id":"source/_posts/2019/数据库基础知识.md","hash":"e2e0368624bbfb33383344f11096ebba7ebfaab7","modified":1590128660000},{"_id":"source/_posts/2019/树.md","hash":"73f1243df1aef9d3bf87b5d32a7364f0931720f6","modified":1590128660000},{"_id":"source/_posts/2019/递归文件夹并返回带路径的文件名数组.md","hash":"ef471bcfb20aa82bec0455bd731184a211e5b86c","modified":1618019146223},{"_id":"source/_posts/2021/淘宝数据中期设计与重构计划.md","hash":"c74ebc82a101f022ca60232013a874b7dfaee697","modified":1618018895958},{"_id":"source/_posts/2021/2020总结.md","hash":"4bdd5a8024c8f8c8bf615a98b265de6ea378a664","modified":1618020205419},{"_id":"source/assets/img/alipay.jpg","hash":"ab899e5ea3113705ab57f8ffd66205f524e918d6","modified":1590128660000},{"_id":"source/assets/img/favicon.ico","hash":"3e83cbc9656029bfdfd45198c26029ea1c5d24a1","modified":1590128660000},{"_id":"source/assets/img/empty.png","hash":"e88177c88f6b7219a3474da7d210965a6dbb57d7","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/12.webp","hash":"1347c44424676b5cb44991c9f72547346df16c68","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/10.webp","hash":"f4bde3b60157ba10b074fd3a3f278596fb68d12b","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/11.webp","hash":"53eb928cffd802caea2aa3625a30cef321c22c42","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/13.webp","hash":"3a27d4c59f8db1b82adfe01b3312a4ac1d46e28a","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/14.webp","hash":"d436d957733590d9227be88765a8f7db6d16dfb5","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/17.webp","hash":"e0e6993502d7947454b45d85386890fbe3f1a0c2","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/15.webp","hash":"2b4f35e8192ed98f639ee62e4025e3ae73dbec03","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/21.webp","hash":"49b2a11617b26e1825ae9db196c09dd46d7fd844","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/16.webp","hash":"7069fbc6493d78b530f222500ff99ef271b4fa7c","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/19.webp","hash":"cfcbaae15fb91accaa98d305fa42b0b7c7fab7cd","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/2.webp","hash":"96570257bf93f56f7881f3b53a927fdb9a749252","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/23.webp","hash":"2c0ba156cf34999ac7012a3bdf341d646f9a28a2","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/20.webp","hash":"75f14fdd2c8e416d23f56c0a81b4b546d1f8dda3","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/22.webp","hash":"945dff44bdf4dd0b35f47391a1dec8910c7e1602","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/24.webp","hash":"53c9814880638cf0b3d9e1fbb5a029393144f243","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/25.webp","hash":"f19fcc4e45ea4a567a26a2625014159e8f73ef9c","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/4.webp","hash":"18f6f657b53cc848eec8faeacfbbe61c7d3a69d4","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/3.webp","hash":"c1ed86584b77589212715e8ec5eb7648b1ae0d5a","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/640.webp","hash":"d674823e68793e150d11db5645949d09e866980f","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/5.webp","hash":"836acb7ca7aa232a6716e0190cb93abf2b48c082","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/6.webp","hash":"c9decfcd33fecbbf5d686465cee29bccde47fb96","modified":1590128660000},{"_id":"source/_posts/2019/常用MySQL优化/2.webp","hash":"1bf14e2ff504d6192d3be0f599c5dc7a3d712e94","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/7.webp","hash":"9908201e36af8db8eda666f50de1f5b9cd2be863","modified":1590128660000},{"_id":"source/_posts/2019/常用MySQL优化/1.webp","hash":"6278eb259d44e084f355642203445fd7dc40984b","modified":1590128660000},{"_id":"source/_posts/2019/常用MySQL优化/4.webp","hash":"cdfc386797b408553913d11966a2756444733d9d","modified":1590128660000},{"_id":"source/_posts/2019/常用MySQL优化/5.webp","hash":"1981a8b81321163bbf1a3fd65215af5fcaa84e25","modified":1590128660000},{"_id":"source/_posts/2019/常用MySQL优化/6.webp","hash":"c1755d0dfd5d62bd1ec091aae96cb7908cfe91d1","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/8.webp","hash":"e7a1f89e52d973d47555ac801f6a944f3fb309e0","modified":1590128660000},{"_id":"source/_posts/2019/Java虚拟机/9.webp","hash":"ec25d2a65141ddb147a8c548b9d0dd48f5f8d40d","modified":1590128660000},{"_id":"source/_posts/2020/01/异步中的eval().md","hash":"ed9d0eac52d7e253decbc5a6146e1919f4a7e22b","modified":1590128660000},{"_id":"source/_posts/2019/常用MySQL优化/3.webp","hash":"8b1ee0d223cd4ff34f0d5405236d4a287e3d4756","modified":1590128660000},{"_id":"source/_posts/2020/03/连接池大小应该设多大.md","hash":"5a954e829041efdbbf50b8931c09cabe690e19df","modified":1590128660000},{"_id":"source/_posts/2020/05/CentOS下docker安装ss.md","hash":"e1d40e54d9ebf080c239e43f3f8dac4e907523ee","modified":1607151125807},{"_id":"source/_posts/2019/常用MySQL优化/7.webp","hash":"cdc936d2e027164ffc03855cb0773d48e2b087c9","modified":1590128660000},{"_id":"source/_posts/2020/05/为git配置代理.md","hash":"d372cde271338f7839d9c68ac377db5861fcb5d5","modified":1590211140822},{"_id":"source/_posts/2019/常用MySQL优化/8.webp","hash":"1d5a93bc85c477e9ff4d47fc982f0debfa8320fb","modified":1590128660000},{"_id":"source/_posts/2020/05/为npm配置代理.md","hash":"fd39a0fd1ef7e14c8bf51f9063363f42e96bdd79","modified":1590211140753},{"_id":"source/_posts/2020/05/事件循环 - 宏队列与微队列.md","hash":"39c504e59677ad88087e6c8b426c24d97e9bc3a0","modified":1618019146197},{"_id":"source/_posts/2020/05/可选链、双问号.md","hash":"5b805344a3fab221e763f43eb54bfd3984a47149","modified":1618019146227},{"_id":"source/_posts/2020/05/相对合理的js对象深拷贝方法.md","hash":"1ed7372caad9d13bb4a2a7dbafe2449f7c2fd995","modified":1618019146204},{"_id":"source/_posts/2020/05/短信验证接口的保护方案.md","hash":"71223a4c77449579452df0a2f68f8c7ffc946c97","modified":1607158841407},{"_id":"source/_posts/2020/05/自己出的一道题，考验对js事件循环的理解.md","hash":"87a118fd70d0ff746552324db7b28a997d2585d5","modified":1618019146229},{"_id":"source/_posts/2020/05/记一次客户端上执行表重构发生的接口挂起.md","hash":"b851ad4effb858119f5f3cfb83e92cae5c22abee","modified":1590211005272},{"_id":"source/_posts/2020/04/Koa和Express的区别.md","hash":"4e2034c2e46b43d5053a3498e460e04491136510","modified":1590128660000},{"_id":"source/_posts/2020/04/MAX-和-ORDER-BY-LIMIT-的比较.md","hash":"1878c12757dd67a483fe33e7570423279fd2e393","modified":1590211882239},{"_id":"source/_posts/2020/04/Node.js多线程.md","hash":"2728579656183bb7358add7fb9f1f25779a2ccc5","modified":1590128660000},{"_id":"source/_posts/2020/04/insert语句添加条件.md","hash":"d112983b42574f356871a65da7a9c88f1760459c","modified":1590128660000},{"_id":"source/_posts/2020/04/阿里Serverless面试记录.md","hash":"e51f447ca2eed0d799cbc0a7cb210eab90ad38ed","modified":1590147123000},{"_id":"source/_posts/2020/06/EggJS踩坑.md","hash":"3248b01766e8d510ae92fd3a572b335ab9254a53","modified":1607157807794},{"_id":"source/_posts/2020/06/docker踩坑.md","hash":"1c39c21d4388ad6840c1c72c04e409ef83875e41","modified":1607159064025},{"_id":"source/_posts/2020/06/redis踩坑.md","hash":"ccfefdd68b405637f6da2ecaf69837bfef15848c","modified":1607159156504},{"_id":"source/_posts/2020/06/sequelize踩坑.md","hash":"b30672e1ee9f2ef3e7584ed9f784e16efe16ff43","modified":1607158289941},{"_id":"source/_posts/2020/07/mysql踩坑.md","hash":"afec610c3d49f43d708126fdc513d48254ed3a2b","modified":1607162710476},{"_id":"source/_posts/2020/12/map-中的this问题.md","hash":"c5637d1ac9267af6dc047eda9b80534e6cc88bb6","modified":1618019146213},{"_id":"source/_posts/2020/12/当我们查询的时候，到底发生了什么-MySQL.md","hash":"da618f31d2ab3cfa5a2970238c9384341f18c1b0","modified":1607162710483},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1590128660000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1590128660000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1590128660000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1590128660000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1590128660000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1590128660000},{"_id":"themes/yilia/README.md","hash":"99985dc9f0f3473a26341245e436751bc42fd322","modified":1590128660000},{"_id":"themes/yilia/_config.yml","hash":"98eaac877ca35fb5d28d6234fde011d5e92f3461","modified":1600832991102},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1590128660000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1590128660000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1590128660000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1590128660000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1590128660000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1590128660000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1590128660000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1590128660000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1590128660000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1590128660000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1590128660000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1590128660000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1590128660000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1590128660000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1590128660000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1590128660000},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"e352e0ae17b78650690bde86837380367621dfdd","modified":1590128660000},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1590128660000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1590128660000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"103802f7367a9b36e9825334a94119c3a3fab843","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"412c4ea4a37d5ea47a24f4a7173f55d98d8b4214","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"f6793ac2ed78a07d093071e9894b095e0683d2b2","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1590128660000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1590128660000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1590128660000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"a5e9fe67e0604c24279281d9fdd2ce1f4536d3e5","modified":1590128660000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1590128660000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1590128660000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1590128660000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1590128660000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1590128660000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1590128660000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1590128660000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1590128660000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"ed8946381e234b61eca2cfa12c53c890f35d1c88","modified":1590128660000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f3899dd5e60c5b17e461d167f2138f4bb99d9a12","modified":1590128660000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1590128660000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1590128660000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1590128660000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"9cf5d3bddfb121d9af7246950a32596a04112946","modified":1590128660000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1590128660000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1590128660000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1590128660000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1590128660000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1590128660000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1590128660000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1590128660000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1590128660000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1590128660000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1590128660000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1590128660000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1590128660000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1590128660000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1590128660000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1590128660000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1590128660000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"d1bd3aa3c4affea0d1f429d34e6bcf488e892b32","modified":1590128660000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1590128660000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"8f9490df20431cf93e7235de0a09ca46d91a1617","modified":1590128660000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1590128660000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1590128660000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1590128660000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1590128660000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1590128660000},{"_id":"themes/yilia/source-src/js/main.js","hash":"6240cc040dd6c4e56956bd6225540ad0e7a3906e","modified":1590128660000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1590128660000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1590128660000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1590128660000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1590128660000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1590128660000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"d59e0c6eaf9d9a3d73319f989697c31991883539","modified":1590146908000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1590128660000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1590128660000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1590128660000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"efccad5ddd83118f603917a51a6a277985aba77e","modified":1590128660000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1590128660000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1590128660000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1590128660000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1590128660000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1590128660000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1590128660000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1590128660000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1590128660000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"a5e9fe67e0604c24279281d9fdd2ce1f4536d3e5","modified":1590128660000},{"_id":"source/assets/img/avatar.jpg","hash":"888874bcb6df5c097b26408944f16367929c5cd7","modified":1590128660000},{"_id":"source/assets/img/weixin.jpg","hash":"23eee68cfcabf48f22a8202f6c9ac0c74f065065","modified":1590128660000},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"62fa12c585a17b570f362e536ea8b17780b36039","modified":1590128660000},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1590128660000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1590128660000},{"_id":"source/_posts/2019/IDEA使用技巧/1.gif","hash":"4443d892e43d73059be19d64baf73263fa4bbb26","modified":1590128660000},{"_id":"source/_posts/2019/IDEA使用技巧/3.gif","hash":"0eddbd25dcf4f6da40970dd7af6f89c299ba32be","modified":1590128660000},{"_id":"source/_posts/2019/IDEA使用技巧/2.gif","hash":"84243a8963bf1306ca188aa32f15b98a09696165","modified":1590128660000},{"_id":"source/_posts/2019/树/1.png","hash":"596d2234ff3d3c9c4a2f35e017962e59c6b61b9a","modified":1590128660000},{"_id":"source/_posts/2019/树/2.png","hash":"bf6944e37cb04fa93ca58e53bfbbc203480092f8","modified":1590128660000},{"_id":"source/_posts/2019/IDEA使用技巧/10.gif","hash":"8dd8743a19bc0c3125218bbdbd11f329d67c4d2c","modified":1590128660000},{"_id":"source/_posts/2019/IDEA使用技巧/7.gif","hash":"0a788b984807117ff798a2f7f455b9875a06b864","modified":1590128660000},{"_id":"source/_posts/2019/IDEA使用技巧/4.gif","hash":"941d1ee275a9f0d849d5281e8d22f891f2ab0f82","modified":1590128660000},{"_id":"source/_posts/2019/IDEA使用技巧/9.gif","hash":"c62e66ac809e3b2a64b3ee9c68d73c2e42c8176f","modified":1590128660000},{"_id":"source/_posts/2019/IDEA使用技巧/5.gif","hash":"b7349d28016142213f8956d820c566bb73cb73b9","modified":1590128660000},{"_id":"source/_posts/2019/IDEA使用技巧/8.gif","hash":"94df65a0ef30dd593a6d3d8c43db077c7e27b6f7","modified":1590128660000},{"_id":"source/_posts/2019/IDEA使用技巧/6.gif","hash":"6741fabe9c0e5e913a1357100577732f9c86c2d7","modified":1590128660000}],"Category":[],"Data":[],"Page":[{"layout":"post","slug":"photos","title":"相册","noDate":"true","comments":0,"_content":"<link rel=\"stylesheet\" href=\"./ins.css\">\n<div class=\"photos-btn-wrap\">\n    <a class=\"photos-btn active\" href=\"javascript:void(0)\">Photos</a>\n    <a class=\"photos-btn\" href=\"#\">待续</a>\n</div>\n<div class=\"instagram itemscope\">\n    <a href=\"#\" target=\"_blank\" class=\"open-ins\">图片正在加载中…</a>\n</div>\n<script>\n    (function(){\n        var loadScript = function(path){\n            var $script = document.createElement('script')\n            document.getElementsByTagName('body')[0].appendChild($script)\n            $script.setAttribute('src',path)\n        }\n        setTimeout(function(){\n            loadScript('./ins.js')\n        },0)\n    })()\n</script>","source":"photos/index.ejs","raw":"---\nlayout: post\nslug: \"photos\"\ntitle: \"相册\"\nnoDate: \"true\"\ncomments: \"false\"\n---\n<link rel=\"stylesheet\" href=\"./ins.css\">\n<div class=\"photos-btn-wrap\">\n    <a class=\"photos-btn active\" href=\"javascript:void(0)\">Photos</a>\n    <a class=\"photos-btn\" href=\"#\">待续</a>\n</div>\n<div class=\"instagram itemscope\">\n    <a href=\"#\" target=\"_blank\" class=\"open-ins\">图片正在加载中…</a>\n</div>\n<script>\n    (function(){\n        var loadScript = function(path){\n            var $script = document.createElement('script')\n            document.getElementsByTagName('body')[0].appendChild($script)\n            $script.setAttribute('src',path)\n        }\n        setTimeout(function(){\n            loadScript('./ins.js')\n        },0)\n    })()\n</script>","date":"2020-11-09T02:39:37.474Z","updated":"2020-05-22T06:24:20.000Z","path":"photos/index.html","_id":"cknb3zrjg00002yku5r710sai","content":"<link rel=\"stylesheet\" href=\"./ins.css\">\n<div class=\"photos-btn-wrap\">\n    <a class=\"photos-btn active\" href=\"javascript:void(0)\">Photos</a>\n    <a class=\"photos-btn\" href=\"#\">待续</a>\n</div>\n<div class=\"instagram itemscope\">\n    <a href=\"#\" target=\"_blank\" class=\"open-ins\">图片正在加载中…</a>\n</div>\n<script>\n    (function(){\n        var loadScript = function(path){\n            var $script = document.createElement('script')\n            document.getElementsByTagName('body')[0].appendChild($script)\n            $script.setAttribute('src',path)\n        }\n        setTimeout(function(){\n            loadScript('./ins.js')\n        },0)\n    })()\n</script>","site":{"data":{}},"excerpt":"","more":"<link rel=\"stylesheet\" href=\"./ins.css\">\n<div class=\"photos-btn-wrap\">\n    <a class=\"photos-btn active\" href=\"javascript:void(0)\">Photos</a>\n    <a class=\"photos-btn\" href=\"#\">待续</a>\n</div>\n<div class=\"instagram itemscope\">\n    <a href=\"#\" target=\"_blank\" class=\"open-ins\">图片正在加载中…</a>\n</div>\n<script>\n    (function(){\n        var loadScript = function(path){\n            var $script = document.createElement('script')\n            document.getElementsByTagName('body')[0].appendChild($script)\n            $script.setAttribute('src',path)\n        }\n        setTimeout(function(){\n            loadScript('./ins.js')\n        },0)\n    })()\n</script>"},{"_content":"{\"list\": []}","source":"photos/data.json","raw":"{\"list\": []}","date":"2020-11-09T02:39:37.474Z","updated":"2020-05-22T06:24:20.000Z","path":"photos/data.json","layout":"false","title":"","comments":1,"_id":"cknb3zrjm00022yku4coi0nz7","content":"{\"list\":[]}","site":{"data":{}},"excerpt":"","more":"{\"list\":[]}"},{"title":"相册","noDate":"true","_content":"<link type=\"text/css\" href=\"/fancybox/jquery.fancybox.css\" rel=\"stylesheet\">\n<div class=\"instagram\"><section class=\"archives album\"><ul class=\"img-box-ul\"></ul></section></div>\n","source":"photos/index.md","raw":"---\ntitle: 相册\nnoDate: 'true'\n---\n<link type=\"text/css\" href=\"/fancybox/jquery.fancybox.css\" rel=\"stylesheet\">\n<div class=\"instagram\"><section class=\"archives album\"><ul class=\"img-box-ul\"></ul></section></div>\n","date":"2020-11-09T02:39:37.475Z","updated":"2020-05-22T06:24:20.000Z","path":"photos/index.html","comments":1,"layout":"page","_id":"cknb3zrjr00052ykuat9cdjt9","content":"<link type=\"text/css\" href=\"/fancybox/jquery.fancybox.css\" rel=\"stylesheet\">\n<div class=\"instagram\"><section class=\"archives album\"><ul class=\"img-box-ul\"></ul></section></div>\n","site":{"data":{}},"excerpt":"","more":"<link type=\"text/css\" href=\"/fancybox/jquery.fancybox.css\" rel=\"stylesheet\">\n<div class=\"instagram\"><section class=\"archives album\"><ul class=\"img-box-ul\"></ul></section></div>\n"},{"_content":"#post-instagram {\n    padding: 30px;\n}\n\n#post-instagram .article-entry {\n    padding-right: 0;\n}\n\n.instagram {\n    position: relative;\n    min-height: 500px;\n}\n\n.instagram img {\n    width: 100%;\n}\n\n.instagram .year {\n    font-size: 16px;\n}\n\n.instagram .open-ins {\n    padding: 10px 0;\n    color: #cdcdcd;\n}\n\n.instagram .open-ins:hover {\n    color: #657b83;\n}\n\n.instagram .year {\n    display: inline;\n}\n\n.instagram .thumb {\n    width: 25%;\n    height: 0;\n    padding-bottom: 25%;\n    position: relative;\n    display: inline-block;\n    text-align: center;\n    background: #ededed;\n    outline: 1px solid #ddd;\n}\n\n.instagram .thumb a {\n    position: relative;\n}\n\n.instagram .album h1 em {\n    font-style: normal;\n    font-size: 14px;\n    margin-left: 10px;\n}\n\n.instagram .album ul {\n    display: flex;\n    flex-wrap: wrap;\n    clear: both;\n    width: 100%;\n    text-align: left;\n}\n\n.instagram .album li {\n    list-style: none;\n    display: inline-block;\n    box-sizing: border-box;\n    padding: 0 5px;\n    margin-bottom: -10px;\n    height: 0;\n    width: 25%;\n    position: relative;\n    padding-bottom: 25%;\n}\n\n.instagram .album li:before {\n    display: none;\n}\n\n.instagram .album div.img-box {\n    position: absolute;\n    width: 90%;\n    height: 90%;\n    -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4), 0 1px 0 1px rgba(255, 255, 255, 0.1);\n    -moz-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4), 0 1px 0 1px rgba(255, 255, 255, 0.1);\n    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4), 0 1px 0 1px rgba(255, 255, 255, 0.1);\n}\n\n.instagram .album div.img-box img {\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    z-index: 2;\n}\n\n.instagram .album div.img-box .img-bg {\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0px;\n    width: 100%;\n    margin: -5px;\n    padding: 5px;\n    -webkit-box-shadow: 0 0 0 1px rgba(0, 0, 0, .04), 0 1px 5px rgba(0, 0, 0, 0.1);\n    -moz-box-shadow: 0 0 0 1px rgba(0, 0, 0, .04), 0 1px 5px rgba(0, 0, 0, 0.1);\n    box-shadow: 0 0 0 1px rgba(0, 0, 0, .04), 0 1px 5px rgba(0, 0, 0, 0.1);\n    -webkit-transition: all 0.15s ease-out 0.1s;\n    -moz-transition: all 0.15s ease-out 0.1s;\n    -o-transition: all 0.15s ease-out 0.1s;\n    transition: all 0.15s ease-out 0.1s;\n    opacity: 0.2;\n    cursor: pointer;\n    display: block;\n    z-index: 3;\n}\n\n.instagram .album div.img-box .icon {\n    font-size: 14px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-left: -7px;\n    margin-top: -7px;\n    color: #999;\n    z-index: 1;\n}\n\n.instagram .album div.img-box .img-bg:hover {\n    opacity: 0;\n}\n\n.photos-btn-wrap {\n    border-bottom: 1px solid #e5e5e5;\n    margin-bottom: 20px;\n}\n\n.photos-btn {\n    font-size: 16px;\n    color: #333;\n    margin-bottom: -4px;\n    padding: 5px 8px 3px;\n}\n\n.photos-btn.active {\n    color: #08c;\n    border: 1px solid #e5e5e5;\n    border-bottom: 5px solid #fff;\n}\n\n@media screen and (max-width: 600px) {\n    .instagram .thumb {\n        width: 50%;\n        padding-bottom: 50%;\n    }\n\n    .instagram .album li {\n        width: 100%;\n        position: relative;\n        padding-bottom: 100%;\n        text-align: center;\n    }\n\n    .instagram .album div.img-box {\n        margin: 0;\n        width: 90%;\n        height: 90%;\n    }\n}","source":"photos/ins.css","raw":"#post-instagram {\n    padding: 30px;\n}\n\n#post-instagram .article-entry {\n    padding-right: 0;\n}\n\n.instagram {\n    position: relative;\n    min-height: 500px;\n}\n\n.instagram img {\n    width: 100%;\n}\n\n.instagram .year {\n    font-size: 16px;\n}\n\n.instagram .open-ins {\n    padding: 10px 0;\n    color: #cdcdcd;\n}\n\n.instagram .open-ins:hover {\n    color: #657b83;\n}\n\n.instagram .year {\n    display: inline;\n}\n\n.instagram .thumb {\n    width: 25%;\n    height: 0;\n    padding-bottom: 25%;\n    position: relative;\n    display: inline-block;\n    text-align: center;\n    background: #ededed;\n    outline: 1px solid #ddd;\n}\n\n.instagram .thumb a {\n    position: relative;\n}\n\n.instagram .album h1 em {\n    font-style: normal;\n    font-size: 14px;\n    margin-left: 10px;\n}\n\n.instagram .album ul {\n    display: flex;\n    flex-wrap: wrap;\n    clear: both;\n    width: 100%;\n    text-align: left;\n}\n\n.instagram .album li {\n    list-style: none;\n    display: inline-block;\n    box-sizing: border-box;\n    padding: 0 5px;\n    margin-bottom: -10px;\n    height: 0;\n    width: 25%;\n    position: relative;\n    padding-bottom: 25%;\n}\n\n.instagram .album li:before {\n    display: none;\n}\n\n.instagram .album div.img-box {\n    position: absolute;\n    width: 90%;\n    height: 90%;\n    -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4), 0 1px 0 1px rgba(255, 255, 255, 0.1);\n    -moz-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4), 0 1px 0 1px rgba(255, 255, 255, 0.1);\n    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4), 0 1px 0 1px rgba(255, 255, 255, 0.1);\n}\n\n.instagram .album div.img-box img {\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    z-index: 2;\n}\n\n.instagram .album div.img-box .img-bg {\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0px;\n    width: 100%;\n    margin: -5px;\n    padding: 5px;\n    -webkit-box-shadow: 0 0 0 1px rgba(0, 0, 0, .04), 0 1px 5px rgba(0, 0, 0, 0.1);\n    -moz-box-shadow: 0 0 0 1px rgba(0, 0, 0, .04), 0 1px 5px rgba(0, 0, 0, 0.1);\n    box-shadow: 0 0 0 1px rgba(0, 0, 0, .04), 0 1px 5px rgba(0, 0, 0, 0.1);\n    -webkit-transition: all 0.15s ease-out 0.1s;\n    -moz-transition: all 0.15s ease-out 0.1s;\n    -o-transition: all 0.15s ease-out 0.1s;\n    transition: all 0.15s ease-out 0.1s;\n    opacity: 0.2;\n    cursor: pointer;\n    display: block;\n    z-index: 3;\n}\n\n.instagram .album div.img-box .icon {\n    font-size: 14px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-left: -7px;\n    margin-top: -7px;\n    color: #999;\n    z-index: 1;\n}\n\n.instagram .album div.img-box .img-bg:hover {\n    opacity: 0;\n}\n\n.photos-btn-wrap {\n    border-bottom: 1px solid #e5e5e5;\n    margin-bottom: 20px;\n}\n\n.photos-btn {\n    font-size: 16px;\n    color: #333;\n    margin-bottom: -4px;\n    padding: 5px 8px 3px;\n}\n\n.photos-btn.active {\n    color: #08c;\n    border: 1px solid #e5e5e5;\n    border-bottom: 5px solid #fff;\n}\n\n@media screen and (max-width: 600px) {\n    .instagram .thumb {\n        width: 50%;\n        padding-bottom: 50%;\n    }\n\n    .instagram .album li {\n        width: 100%;\n        position: relative;\n        padding-bottom: 100%;\n        text-align: center;\n    }\n\n    .instagram .album div.img-box {\n        margin: 0;\n        width: 90%;\n        height: 90%;\n    }\n}","date":"2020-11-09T02:39:37.475Z","updated":"2020-05-22T06:24:20.000Z","path":"photos/ins.css","layout":"false","title":"","comments":1,"_id":"cknb3zrjt00072ykubt93grl3","content":"#post-instagram {\n    padding: 30px;\n}\n\n#post-instagram .article-entry {\n    padding-right: 0;\n}\n\n.instagram {\n    position: relative;\n    min-height: 500px;\n}\n\n.instagram img {\n    width: 100%;\n}\n\n.instagram .year {\n    font-size: 16px;\n}\n\n.instagram .open-ins {\n    padding: 10px 0;\n    color: #cdcdcd;\n}\n\n.instagram .open-ins:hover {\n    color: #657b83;\n}\n\n.instagram .year {\n    display: inline;\n}\n\n.instagram .thumb {\n    width: 25%;\n    height: 0;\n    padding-bottom: 25%;\n    position: relative;\n    display: inline-block;\n    text-align: center;\n    background: #ededed;\n    outline: 1px solid #ddd;\n}\n\n.instagram .thumb a {\n    position: relative;\n}\n\n.instagram .album h1 em {\n    font-style: normal;\n    font-size: 14px;\n    margin-left: 10px;\n}\n\n.instagram .album ul {\n    display: flex;\n    flex-wrap: wrap;\n    clear: both;\n    width: 100%;\n    text-align: left;\n}\n\n.instagram .album li {\n    list-style: none;\n    display: inline-block;\n    box-sizing: border-box;\n    padding: 0 5px;\n    margin-bottom: -10px;\n    height: 0;\n    width: 25%;\n    position: relative;\n    padding-bottom: 25%;\n}\n\n.instagram .album li:before {\n    display: none;\n}\n\n.instagram .album div.img-box {\n    position: absolute;\n    width: 90%;\n    height: 90%;\n    -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4), 0 1px 0 1px rgba(255, 255, 255, 0.1);\n    -moz-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4), 0 1px 0 1px rgba(255, 255, 255, 0.1);\n    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4), 0 1px 0 1px rgba(255, 255, 255, 0.1);\n}\n\n.instagram .album div.img-box img {\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    z-index: 2;\n}\n\n.instagram .album div.img-box .img-bg {\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0px;\n    width: 100%;\n    margin: -5px;\n    padding: 5px;\n    -webkit-box-shadow: 0 0 0 1px rgba(0, 0, 0, .04), 0 1px 5px rgba(0, 0, 0, 0.1);\n    -moz-box-shadow: 0 0 0 1px rgba(0, 0, 0, .04), 0 1px 5px rgba(0, 0, 0, 0.1);\n    box-shadow: 0 0 0 1px rgba(0, 0, 0, .04), 0 1px 5px rgba(0, 0, 0, 0.1);\n    -webkit-transition: all 0.15s ease-out 0.1s;\n    -moz-transition: all 0.15s ease-out 0.1s;\n    -o-transition: all 0.15s ease-out 0.1s;\n    transition: all 0.15s ease-out 0.1s;\n    opacity: 0.2;\n    cursor: pointer;\n    display: block;\n    z-index: 3;\n}\n\n.instagram .album div.img-box .icon {\n    font-size: 14px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-left: -7px;\n    margin-top: -7px;\n    color: #999;\n    z-index: 1;\n}\n\n.instagram .album div.img-box .img-bg:hover {\n    opacity: 0;\n}\n\n.photos-btn-wrap {\n    border-bottom: 1px solid #e5e5e5;\n    margin-bottom: 20px;\n}\n\n.photos-btn {\n    font-size: 16px;\n    color: #333;\n    margin-bottom: -4px;\n    padding: 5px 8px 3px;\n}\n\n.photos-btn.active {\n    color: #08c;\n    border: 1px solid #e5e5e5;\n    border-bottom: 5px solid #fff;\n}\n\n@media screen and (max-width: 600px) {\n    .instagram .thumb {\n        width: 50%;\n        padding-bottom: 50%;\n    }\n\n    .instagram .album li {\n        width: 100%;\n        position: relative;\n        padding-bottom: 100%;\n        text-align: center;\n    }\n\n    .instagram .album div.img-box {\n        margin: 0;\n        width: 90%;\n        height: 90%;\n    }\n}","site":{"data":{}},"excerpt":"","more":"#post-instagram {\n    padding: 30px;\n}\n\n#post-instagram .article-entry {\n    padding-right: 0;\n}\n\n.instagram {\n    position: relative;\n    min-height: 500px;\n}\n\n.instagram img {\n    width: 100%;\n}\n\n.instagram .year {\n    font-size: 16px;\n}\n\n.instagram .open-ins {\n    padding: 10px 0;\n    color: #cdcdcd;\n}\n\n.instagram .open-ins:hover {\n    color: #657b83;\n}\n\n.instagram .year {\n    display: inline;\n}\n\n.instagram .thumb {\n    width: 25%;\n    height: 0;\n    padding-bottom: 25%;\n    position: relative;\n    display: inline-block;\n    text-align: center;\n    background: #ededed;\n    outline: 1px solid #ddd;\n}\n\n.instagram .thumb a {\n    position: relative;\n}\n\n.instagram .album h1 em {\n    font-style: normal;\n    font-size: 14px;\n    margin-left: 10px;\n}\n\n.instagram .album ul {\n    display: flex;\n    flex-wrap: wrap;\n    clear: both;\n    width: 100%;\n    text-align: left;\n}\n\n.instagram .album li {\n    list-style: none;\n    display: inline-block;\n    box-sizing: border-box;\n    padding: 0 5px;\n    margin-bottom: -10px;\n    height: 0;\n    width: 25%;\n    position: relative;\n    padding-bottom: 25%;\n}\n\n.instagram .album li:before {\n    display: none;\n}\n\n.instagram .album div.img-box {\n    position: absolute;\n    width: 90%;\n    height: 90%;\n    -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4), 0 1px 0 1px rgba(255, 255, 255, 0.1);\n    -moz-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4), 0 1px 0 1px rgba(255, 255, 255, 0.1);\n    box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4), 0 1px 0 1px rgba(255, 255, 255, 0.1);\n}\n\n.instagram .album div.img-box img {\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    z-index: 2;\n}\n\n.instagram .album div.img-box .img-bg {\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0px;\n    width: 100%;\n    margin: -5px;\n    padding: 5px;\n    -webkit-box-shadow: 0 0 0 1px rgba(0, 0, 0, .04), 0 1px 5px rgba(0, 0, 0, 0.1);\n    -moz-box-shadow: 0 0 0 1px rgba(0, 0, 0, .04), 0 1px 5px rgba(0, 0, 0, 0.1);\n    box-shadow: 0 0 0 1px rgba(0, 0, 0, .04), 0 1px 5px rgba(0, 0, 0, 0.1);\n    -webkit-transition: all 0.15s ease-out 0.1s;\n    -moz-transition: all 0.15s ease-out 0.1s;\n    -o-transition: all 0.15s ease-out 0.1s;\n    transition: all 0.15s ease-out 0.1s;\n    opacity: 0.2;\n    cursor: pointer;\n    display: block;\n    z-index: 3;\n}\n\n.instagram .album div.img-box .icon {\n    font-size: 14px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-left: -7px;\n    margin-top: -7px;\n    color: #999;\n    z-index: 1;\n}\n\n.instagram .album div.img-box .img-bg:hover {\n    opacity: 0;\n}\n\n.photos-btn-wrap {\n    border-bottom: 1px solid #e5e5e5;\n    margin-bottom: 20px;\n}\n\n.photos-btn {\n    font-size: 16px;\n    color: #333;\n    margin-bottom: -4px;\n    padding: 5px 8px 3px;\n}\n\n.photos-btn.active {\n    color: #08c;\n    border: 1px solid #e5e5e5;\n    border-bottom: 5px solid #fff;\n}\n\n@media screen and (max-width: 600px) {\n    .instagram .thumb {\n        width: 50%;\n        padding-bottom: 50%;\n    }\n\n    .instagram .album li {\n        width: 100%;\n        position: relative;\n        padding-bottom: 100%;\n        text-align: center;\n    }\n\n    .instagram .album div.img-box {\n        margin: 0;\n        width: 90%;\n        height: 90%;\n    }\n}"},{"_content":"/*!\n * An jQuery | zepto plugin for lazy loading images.\n * author -> jieyou\n * see https://github.com/jieyou/lazyload\n * use some tuupola's code https://github.com/tuupola/jquery_lazyload (BSD)\n * use component's throttle https://github.com/component/throttle (MIT)\n */\n!function(a){\"function\"==typeof define&&define.amd?define([\"jquery\"],a):a(window.jQuery||window.Zepto)}(function(a){function g(){}function h(a,b){var e;return e=b._$container==d?(\"innerHeight\"in c?c.innerHeight:d.height())+d.scrollTop():b._$container.offset().top+b._$container.height(),e<=a.offset().top-b.threshold}function i(b,e){var f;return f=e._$container==d?d.width()+(a.fn.scrollLeft?d.scrollLeft():c.pageXOffset):e._$container.offset().left+e._$container.width(),f<=b.offset().left-e.threshold}function j(a,b){var c;return c=b._$container==d?d.scrollTop():b._$container.offset().top,c>=a.offset().top+b.threshold+a.height()}function k(b,e){var f;return f=e._$container==d?a.fn.scrollLeft?d.scrollLeft():c.pageXOffset:e._$container.offset().left,f>=b.offset().left+e.threshold+b.width()}function l(a,b){var c=0;a.each(function(d){function g(){f.trigger(\"_lazyload_appear\"),c=0}var f=a.eq(d);if(!(f.width()<=0&&f.height()<=0||\"none\"===f.css(\"display\")))if(b.vertical_only)if(j(f,b));else if(h(f,b)){if(++c>b.failure_limit)return!1}else g();else if(j(f,b)||k(f,b));else if(h(f,b)||i(f,b)){if(++c>b.failure_limit)return!1}else g()})}function m(a){return a.filter(function(b){return!a.eq(b)._lazyload_loadStarted})}function n(a,b){function h(){f=0,g=+new Date,e=a.apply(c,d),c=null,d=null}var c,d,e,f,g=0;return function(){c=this,d=arguments;var a=new Date-g;return f||(a>=b?h():f=setTimeout(h,b-a)),e}}var f,c=window,d=a(c),e={threshold:0,failure_limit:0,event:\"scroll\",effect:\"show\",effect_params:null,container:c,data_attribute:\"original\",data_srcset_attribute:\"original-srcset\",skip_invisible:!0,appear:g,load:g,vertical_only:!1,check_appear_throttle_time:300,url_rewriter_fn:g,no_fake_img_loader:!1,placeholder_data_img:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\",placeholder_real_img:\"http://ditu.baidu.cn/yyfm/lazyload/0.0.1/img/placeholder.png\"};f=function(){var a=Object.prototype.toString;return function(b){return a.call(b).replace(\"[object \",\"\").replace(\"]\",\"\")}}(),a.fn.hasOwnProperty(\"lazyload\")||(a.fn.lazyload=function(b){var i,j,k,h=this;return a.isPlainObject(b)||(b={}),a.each(e,function(g,h){var i=f(b[g]);-1!=a.inArray(g,[\"threshold\",\"failure_limit\",\"check_appear_throttle_time\"])?\"String\"==i?b[g]=parseInt(b[g],10):\"Number\"!=i&&(b[g]=h):\"container\"==g?(b._$container=b.hasOwnProperty(g)?b[g]==c||b[g]==document?d:a(b[g]):d,delete b.container):!e.hasOwnProperty(g)||b.hasOwnProperty(g)&&i==f(e[g])||(b[g]=h)}),i=\"scroll\"==b.event,k=0==b.check_appear_throttle_time?l:n(l,b.check_appear_throttle_time),j=i||\"scrollstart\"==b.event||\"scrollstop\"==b.event,h.each(function(c){var e=this,f=h.eq(c),i=f.attr(\"src\"),k=f.attr(\"data-\"+b.data_attribute),l=b.url_rewriter_fn==g?k:b.url_rewriter_fn.call(e,f,k),n=f.attr(\"data-\"+b.data_srcset_attribute),o=f.is(\"img\");return 1==f._lazyload_loadStarted||i==l?(f._lazyload_loadStarted=!0,h=m(h),void 0):(f._lazyload_loadStarted=!1,o&&!i&&f.one(\"error\",function(){f.attr(\"src\",b.placeholder_real_img)}).attr(\"src\",b.placeholder_data_img),f.one(\"_lazyload_appear\",function(){function i(){d&&f.hide(),o?(n&&f.attr(\"srcset\",n),l&&f.attr(\"src\",l)):f.css(\"background-image\",'url(\"'+l+'\")'),d&&f[b.effect].apply(f,c?b.effect_params:[]),h=m(h)}var d,c=a.isArray(b.effect_params);f._lazyload_loadStarted||(d=\"show\"!=b.effect&&a.fn[b.effect]&&(!b.effect_params||c&&0==b.effect_params.length),b.appear!=g&&b.appear.call(e,f,h.length,b),f._lazyload_loadStarted=!0,b.no_fake_img_loader||n?(b.load!=g&&f.one(\"load\",function(){b.load.call(e,f,h.length,b)}),i()):a(\"<img />\").one(\"load\",function(){i(),b.load!=g&&b.load.call(e,f,h.length,b)}).attr(\"src\",l))}),j||f.on(b.event,function(){f._lazyload_loadStarted||f.trigger(\"_lazyload_appear\")}),void 0)}),j&&b._$container.on(b.event,function(){k(h,b)}),d.on(\"resize load\",function(){k(h,b)}),a(function(){k(h,b)}),this})});","source":"photos/lazyload.min.js","raw":"/*!\n * An jQuery | zepto plugin for lazy loading images.\n * author -> jieyou\n * see https://github.com/jieyou/lazyload\n * use some tuupola's code https://github.com/tuupola/jquery_lazyload (BSD)\n * use component's throttle https://github.com/component/throttle (MIT)\n */\n!function(a){\"function\"==typeof define&&define.amd?define([\"jquery\"],a):a(window.jQuery||window.Zepto)}(function(a){function g(){}function h(a,b){var e;return e=b._$container==d?(\"innerHeight\"in c?c.innerHeight:d.height())+d.scrollTop():b._$container.offset().top+b._$container.height(),e<=a.offset().top-b.threshold}function i(b,e){var f;return f=e._$container==d?d.width()+(a.fn.scrollLeft?d.scrollLeft():c.pageXOffset):e._$container.offset().left+e._$container.width(),f<=b.offset().left-e.threshold}function j(a,b){var c;return c=b._$container==d?d.scrollTop():b._$container.offset().top,c>=a.offset().top+b.threshold+a.height()}function k(b,e){var f;return f=e._$container==d?a.fn.scrollLeft?d.scrollLeft():c.pageXOffset:e._$container.offset().left,f>=b.offset().left+e.threshold+b.width()}function l(a,b){var c=0;a.each(function(d){function g(){f.trigger(\"_lazyload_appear\"),c=0}var f=a.eq(d);if(!(f.width()<=0&&f.height()<=0||\"none\"===f.css(\"display\")))if(b.vertical_only)if(j(f,b));else if(h(f,b)){if(++c>b.failure_limit)return!1}else g();else if(j(f,b)||k(f,b));else if(h(f,b)||i(f,b)){if(++c>b.failure_limit)return!1}else g()})}function m(a){return a.filter(function(b){return!a.eq(b)._lazyload_loadStarted})}function n(a,b){function h(){f=0,g=+new Date,e=a.apply(c,d),c=null,d=null}var c,d,e,f,g=0;return function(){c=this,d=arguments;var a=new Date-g;return f||(a>=b?h():f=setTimeout(h,b-a)),e}}var f,c=window,d=a(c),e={threshold:0,failure_limit:0,event:\"scroll\",effect:\"show\",effect_params:null,container:c,data_attribute:\"original\",data_srcset_attribute:\"original-srcset\",skip_invisible:!0,appear:g,load:g,vertical_only:!1,check_appear_throttle_time:300,url_rewriter_fn:g,no_fake_img_loader:!1,placeholder_data_img:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\",placeholder_real_img:\"http://ditu.baidu.cn/yyfm/lazyload/0.0.1/img/placeholder.png\"};f=function(){var a=Object.prototype.toString;return function(b){return a.call(b).replace(\"[object \",\"\").replace(\"]\",\"\")}}(),a.fn.hasOwnProperty(\"lazyload\")||(a.fn.lazyload=function(b){var i,j,k,h=this;return a.isPlainObject(b)||(b={}),a.each(e,function(g,h){var i=f(b[g]);-1!=a.inArray(g,[\"threshold\",\"failure_limit\",\"check_appear_throttle_time\"])?\"String\"==i?b[g]=parseInt(b[g],10):\"Number\"!=i&&(b[g]=h):\"container\"==g?(b._$container=b.hasOwnProperty(g)?b[g]==c||b[g]==document?d:a(b[g]):d,delete b.container):!e.hasOwnProperty(g)||b.hasOwnProperty(g)&&i==f(e[g])||(b[g]=h)}),i=\"scroll\"==b.event,k=0==b.check_appear_throttle_time?l:n(l,b.check_appear_throttle_time),j=i||\"scrollstart\"==b.event||\"scrollstop\"==b.event,h.each(function(c){var e=this,f=h.eq(c),i=f.attr(\"src\"),k=f.attr(\"data-\"+b.data_attribute),l=b.url_rewriter_fn==g?k:b.url_rewriter_fn.call(e,f,k),n=f.attr(\"data-\"+b.data_srcset_attribute),o=f.is(\"img\");return 1==f._lazyload_loadStarted||i==l?(f._lazyload_loadStarted=!0,h=m(h),void 0):(f._lazyload_loadStarted=!1,o&&!i&&f.one(\"error\",function(){f.attr(\"src\",b.placeholder_real_img)}).attr(\"src\",b.placeholder_data_img),f.one(\"_lazyload_appear\",function(){function i(){d&&f.hide(),o?(n&&f.attr(\"srcset\",n),l&&f.attr(\"src\",l)):f.css(\"background-image\",'url(\"'+l+'\")'),d&&f[b.effect].apply(f,c?b.effect_params:[]),h=m(h)}var d,c=a.isArray(b.effect_params);f._lazyload_loadStarted||(d=\"show\"!=b.effect&&a.fn[b.effect]&&(!b.effect_params||c&&0==b.effect_params.length),b.appear!=g&&b.appear.call(e,f,h.length,b),f._lazyload_loadStarted=!0,b.no_fake_img_loader||n?(b.load!=g&&f.one(\"load\",function(){b.load.call(e,f,h.length,b)}),i()):a(\"<img />\").one(\"load\",function(){i(),b.load!=g&&b.load.call(e,f,h.length,b)}).attr(\"src\",l))}),j||f.on(b.event,function(){f._lazyload_loadStarted||f.trigger(\"_lazyload_appear\")}),void 0)}),j&&b._$container.on(b.event,function(){k(h,b)}),d.on(\"resize load\",function(){k(h,b)}),a(function(){k(h,b)}),this})});","date":"2020-11-09T02:39:37.475Z","updated":"2020-05-22T06:24:20.000Z","path":"photos/lazyload.min.js","layout":"false","title":"","comments":1,"_id":"cknb3zrjv00092ykuccsufdil","content":"/*!\n * An jQuery | zepto plugin for lazy loading images.\n * author -> jieyou\n * see https://github.com/jieyou/lazyload\n * use some tuupola's code https://github.com/tuupola/jquery_lazyload (BSD)\n * use component's throttle https://github.com/component/throttle (MIT)\n */\n!function(a){\"function\"==typeof define&&define.amd?define([\"jquery\"],a):a(window.jQuery||window.Zepto)}(function(a){function g(){}function h(a,b){var e;return e=b._$container==d?(\"innerHeight\"in c?c.innerHeight:d.height())+d.scrollTop():b._$container.offset().top+b._$container.height(),e<=a.offset().top-b.threshold}function i(b,e){var f;return f=e._$container==d?d.width()+(a.fn.scrollLeft?d.scrollLeft():c.pageXOffset):e._$container.offset().left+e._$container.width(),f<=b.offset().left-e.threshold}function j(a,b){var c;return c=b._$container==d?d.scrollTop():b._$container.offset().top,c>=a.offset().top+b.threshold+a.height()}function k(b,e){var f;return f=e._$container==d?a.fn.scrollLeft?d.scrollLeft():c.pageXOffset:e._$container.offset().left,f>=b.offset().left+e.threshold+b.width()}function l(a,b){var c=0;a.each(function(d){function g(){f.trigger(\"_lazyload_appear\"),c=0}var f=a.eq(d);if(!(f.width()<=0&&f.height()<=0||\"none\"===f.css(\"display\")))if(b.vertical_only)if(j(f,b));else if(h(f,b)){if(++c>b.failure_limit)return!1}else g();else if(j(f,b)||k(f,b));else if(h(f,b)||i(f,b)){if(++c>b.failure_limit)return!1}else g()})}function m(a){return a.filter(function(b){return!a.eq(b)._lazyload_loadStarted})}function n(a,b){function h(){f=0,g=+new Date,e=a.apply(c,d),c=null,d=null}var c,d,e,f,g=0;return function(){c=this,d=arguments;var a=new Date-g;return f||(a>=b?h():f=setTimeout(h,b-a)),e}}var f,c=window,d=a(c),e={threshold:0,failure_limit:0,event:\"scroll\",effect:\"show\",effect_params:null,container:c,data_attribute:\"original\",data_srcset_attribute:\"original-srcset\",skip_invisible:!0,appear:g,load:g,vertical_only:!1,check_appear_throttle_time:300,url_rewriter_fn:g,no_fake_img_loader:!1,placeholder_data_img:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\",placeholder_real_img:\"http://ditu.baidu.cn/yyfm/lazyload/0.0.1/img/placeholder.png\"};f=function(){var a=Object.prototype.toString;return function(b){return a.call(b).replace(\"[object \",\"\").replace(\"]\",\"\")}}(),a.fn.hasOwnProperty(\"lazyload\")||(a.fn.lazyload=function(b){var i,j,k,h=this;return a.isPlainObject(b)||(b={}),a.each(e,function(g,h){var i=f(b[g]);-1!=a.inArray(g,[\"threshold\",\"failure_limit\",\"check_appear_throttle_time\"])?\"String\"==i?b[g]=parseInt(b[g],10):\"Number\"!=i&&(b[g]=h):\"container\"==g?(b._$container=b.hasOwnProperty(g)?b[g]==c||b[g]==document?d:a(b[g]):d,delete b.container):!e.hasOwnProperty(g)||b.hasOwnProperty(g)&&i==f(e[g])||(b[g]=h)}),i=\"scroll\"==b.event,k=0==b.check_appear_throttle_time?l:n(l,b.check_appear_throttle_time),j=i||\"scrollstart\"==b.event||\"scrollstop\"==b.event,h.each(function(c){var e=this,f=h.eq(c),i=f.attr(\"src\"),k=f.attr(\"data-\"+b.data_attribute),l=b.url_rewriter_fn==g?k:b.url_rewriter_fn.call(e,f,k),n=f.attr(\"data-\"+b.data_srcset_attribute),o=f.is(\"img\");return 1==f._lazyload_loadStarted||i==l?(f._lazyload_loadStarted=!0,h=m(h),void 0):(f._lazyload_loadStarted=!1,o&&!i&&f.one(\"error\",function(){f.attr(\"src\",b.placeholder_real_img)}).attr(\"src\",b.placeholder_data_img),f.one(\"_lazyload_appear\",function(){function i(){d&&f.hide(),o?(n&&f.attr(\"srcset\",n),l&&f.attr(\"src\",l)):f.css(\"background-image\",'url(\"'+l+'\")'),d&&f[b.effect].apply(f,c?b.effect_params:[]),h=m(h)}var d,c=a.isArray(b.effect_params);f._lazyload_loadStarted||(d=\"show\"!=b.effect&&a.fn[b.effect]&&(!b.effect_params||c&&0==b.effect_params.length),b.appear!=g&&b.appear.call(e,f,h.length,b),f._lazyload_loadStarted=!0,b.no_fake_img_loader||n?(b.load!=g&&f.one(\"load\",function(){b.load.call(e,f,h.length,b)}),i()):a(\"<img />\").one(\"load\",function(){i(),b.load!=g&&b.load.call(e,f,h.length,b)}).attr(\"src\",l))}),j||f.on(b.event,function(){f._lazyload_loadStarted||f.trigger(\"_lazyload_appear\")}),void 0)}),j&&b._$container.on(b.event,function(){k(h,b)}),d.on(\"resize load\",function(){k(h,b)}),a(function(){k(h,b)}),this})});","site":{"data":{}},"excerpt":"","more":"/*!\n * An jQuery | zepto plugin for lazy loading images.\n * author -> jieyou\n * see https://github.com/jieyou/lazyload\n * use some tuupola's code https://github.com/tuupola/jquery_lazyload (BSD)\n * use component's throttle https://github.com/component/throttle (MIT)\n */\n!function(a){\"function\"==typeof define&&define.amd?define([\"jquery\"],a):a(window.jQuery||window.Zepto)}(function(a){function g(){}function h(a,b){var e;return e=b._$container==d?(\"innerHeight\"in c?c.innerHeight:d.height())+d.scrollTop():b._$container.offset().top+b._$container.height(),e<=a.offset().top-b.threshold}function i(b,e){var f;return f=e._$container==d?d.width()+(a.fn.scrollLeft?d.scrollLeft():c.pageXOffset):e._$container.offset().left+e._$container.width(),f<=b.offset().left-e.threshold}function j(a,b){var c;return c=b._$container==d?d.scrollTop():b._$container.offset().top,c>=a.offset().top+b.threshold+a.height()}function k(b,e){var f;return f=e._$container==d?a.fn.scrollLeft?d.scrollLeft():c.pageXOffset:e._$container.offset().left,f>=b.offset().left+e.threshold+b.width()}function l(a,b){var c=0;a.each(function(d){function g(){f.trigger(\"_lazyload_appear\"),c=0}var f=a.eq(d);if(!(f.width()<=0&&f.height()<=0||\"none\"===f.css(\"display\")))if(b.vertical_only)if(j(f,b));else if(h(f,b)){if(++c>b.failure_limit)return!1}else g();else if(j(f,b)||k(f,b));else if(h(f,b)||i(f,b)){if(++c>b.failure_limit)return!1}else g()})}function m(a){return a.filter(function(b){return!a.eq(b)._lazyload_loadStarted})}function n(a,b){function h(){f=0,g=+new Date,e=a.apply(c,d),c=null,d=null}var c,d,e,f,g=0;return function(){c=this,d=arguments;var a=new Date-g;return f||(a>=b?h():f=setTimeout(h,b-a)),e}}var f,c=window,d=a(c),e={threshold:0,failure_limit:0,event:\"scroll\",effect:\"show\",effect_params:null,container:c,data_attribute:\"original\",data_srcset_attribute:\"original-srcset\",skip_invisible:!0,appear:g,load:g,vertical_only:!1,check_appear_throttle_time:300,url_rewriter_fn:g,no_fake_img_loader:!1,placeholder_data_img:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\",placeholder_real_img:\"http://ditu.baidu.cn/yyfm/lazyload/0.0.1/img/placeholder.png\"};f=function(){var a=Object.prototype.toString;return function(b){return a.call(b).replace(\"[object \",\"\").replace(\"]\",\"\")}}(),a.fn.hasOwnProperty(\"lazyload\")||(a.fn.lazyload=function(b){var i,j,k,h=this;return a.isPlainObject(b)||(b={}),a.each(e,function(g,h){var i=f(b[g]);-1!=a.inArray(g,[\"threshold\",\"failure_limit\",\"check_appear_throttle_time\"])?\"String\"==i?b[g]=parseInt(b[g],10):\"Number\"!=i&&(b[g]=h):\"container\"==g?(b._$container=b.hasOwnProperty(g)?b[g]==c||b[g]==document?d:a(b[g]):d,delete b.container):!e.hasOwnProperty(g)||b.hasOwnProperty(g)&&i==f(e[g])||(b[g]=h)}),i=\"scroll\"==b.event,k=0==b.check_appear_throttle_time?l:n(l,b.check_appear_throttle_time),j=i||\"scrollstart\"==b.event||\"scrollstop\"==b.event,h.each(function(c){var e=this,f=h.eq(c),i=f.attr(\"src\"),k=f.attr(\"data-\"+b.data_attribute),l=b.url_rewriter_fn==g?k:b.url_rewriter_fn.call(e,f,k),n=f.attr(\"data-\"+b.data_srcset_attribute),o=f.is(\"img\");return 1==f._lazyload_loadStarted||i==l?(f._lazyload_loadStarted=!0,h=m(h),void 0):(f._lazyload_loadStarted=!1,o&&!i&&f.one(\"error\",function(){f.attr(\"src\",b.placeholder_real_img)}).attr(\"src\",b.placeholder_data_img),f.one(\"_lazyload_appear\",function(){function i(){d&&f.hide(),o?(n&&f.attr(\"srcset\",n),l&&f.attr(\"src\",l)):f.css(\"background-image\",'url(\"'+l+'\")'),d&&f[b.effect].apply(f,c?b.effect_params:[]),h=m(h)}var d,c=a.isArray(b.effect_params);f._lazyload_loadStarted||(d=\"show\"!=b.effect&&a.fn[b.effect]&&(!b.effect_params||c&&0==b.effect_params.length),b.appear!=g&&b.appear.call(e,f,h.length,b),f._lazyload_loadStarted=!0,b.no_fake_img_loader||n?(b.load!=g&&f.one(\"load\",function(){b.load.call(e,f,h.length,b)}),i()):a(\"<img />\").one(\"load\",function(){i(),b.load!=g&&b.load.call(e,f,h.length,b)}).attr(\"src\",l))}),j||f.on(b.event,function(){f._lazyload_loadStarted||f.trigger(\"_lazyload_appear\")}),void 0)}),j&&b._$container.on(b.event,function(){k(h,b)}),d.on(\"resize load\",function(){k(h,b)}),a(function(){k(h,b)}),this})});"},{"_content":"/******/\n(function(modules){ // webpackBootstrap\n    /******/ // The module cache\n    /******/\n    var installedModules = {};\n    /******/\n    /******/ // The require function\n    /******/\n    function __webpack_require__(moduleId){\n        /******/\n        /******/ // Check if module is in cache\n        /******/\n        if(installedModules[moduleId])\n        /******/\n            return installedModules[moduleId].exports;\n        /******/\n        /******/ // Create a new module (and put it into the cache)\n        /******/\n        var module = installedModules[moduleId] = {\n            /******/\n            exports:{},\n            /******/\n            id:moduleId,\n            /******/\n            loaded:false\n            /******/\n        };\n        /******/\n        /******/ // Execute the module function\n        /******/\n        modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);\n        /******/\n        /******/ // Flag the module as loaded\n        /******/\n        module.loaded = true;\n        /******/\n        /******/ // Return the exports of the module\n        /******/\n        return module.exports;\n        /******/\n    }\n\n    /******/\n    /******/\n    /******/ // expose the modules object (__webpack_modules__)\n    /******/\n    __webpack_require__.m = modules;\n    /******/\n    /******/ // expose the module cache\n    /******/\n    __webpack_require__.c = installedModules;\n    /******/\n    /******/ // __webpack_public_path__\n    /******/\n    __webpack_require__.p = \"/dist/\";\n    /******/\n    /******/ // Load entry module and return exports\n    /******/\n    return __webpack_require__(0);\n    /******/\n})\n/************************************************************************/\n/******/\n([\n    /* 0 */\n    /***/\n    function(module,exports,__webpack_require__){\n\n        'use strict';\n\n        __webpack_require__(1);\n\n        var _view = __webpack_require__(2);\n\n        var _view2 = _interopRequireDefault(_view);\n\n        function _interopRequireDefault(obj){\n            return obj && obj.__esModule ? obj : {\n                default:obj\n            };\n        }\n\n        /**\n         * @name impush-client\n         * @description 这个项目让我发家致富…\n         * @date 2016-12-1\n         */\n\n        var _collection = [];\n        var _count = 0;\n        var searchData;\n\n        function addMask(elem){\n            var rect = elem.getBoundingClientRect();\n            var style = getComputedStyle(elem,null);\n\n            var mask = document.createElement('i');\n            mask.className = 'icon-film';\n            mask.style.color = '#fff';\n            mask.style.fontSize = '26px';\n            mask.style.position = 'absolute';\n            mask.style.right = '10px';\n            mask.style.bottom = '10px';\n            mask.style.zIndex = 1;\n            elem.parentNode.appendChild(mask);\n        }\n\n        var createVideoIncon = function createVideoIncon(){\n            var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]');\n            for(var i = 0,len = $videoImg.length; i < len; i++){\n                addMask($videoImg[i]);\n            }\n        };\n        var render = function render(res){\n            var ulTmpl = \"\";\n            for(var j = 0,len2 = res.list.length; j < len2; j++){\n                var data = res.list[j].arr;\n                var liTmpl = \"\";\n                for(var i = 0,len = data.link.length; i < len; i++){\n                    var minSrc = 'https://raw.githubusercontent.com/0000zjn/Blog-File-Back-Up/master/min_photos/' + data.link[i];\n                    var src = 'https://raw.githubusercontent.com/0000zjn/Blog-File-Back-Up/master/photos/' + data.link[i];\n                    var type = data.type[i];\n                    var target = src + (type === 'video' ? '.mp4' : '.jpg');\n                    src += '';\n\n                    liTmpl += '<figure class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\">\\\n                <a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"1080x1080\" data-type=\"' + type + '\" data-target=\"' + src + '\">\\\n                  <img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"/assets/img/empty.png\" itemprop=\"thumbnail\" onload=\"lzld(this)\">\\\n                </a>\\\n                <figcaption style=\"display:none\" itemprop=\"caption description\">' + data.text[i] + '</figcaption>\\\n            </figure>';\n                }\n                ulTmpl = ulTmpl + '<section class=\"archives album\"><h1 class=\"year\">' + data.year + '年<em>' + data.month + '月</em></h1>\\\n        <ul class=\"img-box-ul\">' + liTmpl + '</ul>\\\n        </section>';\n            }\n            document.querySelector('.instagram').innerHTML = '<div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\">' + ulTmpl + '</div>';\n            createVideoIncon();\n            _view2.default.init();\n        };\n\n        var replacer = function replacer(str){\n            var arr = str.split(\"/\");\n            return \"/assets/ins/\" + arr[arr.length - 1];\n        };\n\n        var ctrler = function ctrler(data){\n            var imgObj = {};\n            for(var i = 0,len = data.length; i < len; i++){\n                var y = data[i].y;\n                var m = data[i].m;\n                var src = replacer(data[i].src);\n                var text = data[i].text;\n                var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m);\n                if(imgObj[key]){\n                    imgObj[key].srclist.push(src);\n                    imgObj[key].text.push(text);\n                }else{\n                    imgObj[key] = {\n                        year:y,\n                        month:m,\n                        srclist:[src],\n                        text:[text]\n                    };\n                }\n            }\n            render(imgObj);\n        };\n\n        function loadData(success){\n            if(!searchData){\n                var xhr = new XMLHttpRequest();\n                xhr.open('GET','./data.json?t=' + +new Date(),true);\n\n                xhr.onload = function(){\n                    if(this.status >= 200 && this.status < 300){\n                        var res = JSON.parse(this.response);\n                        searchData = res;\n                        success(searchData);\n                    }else{\n                        console.error(this.statusText);\n                    }\n                };\n\n                xhr.onerror = function(){\n                    console.error(this.statusText);\n                };\n\n                xhr.send();\n            }else{\n                success(searchData);\n            }\n        }\n\n        var Ins = {\n            init:function init(){\n                loadData(function(data){\n                    render(data);\n                });\n            }\n        };\n\n        Ins.init();\n\n        // export default impush;\n\n        /***/\n    },\n    /* 1 */\n    /***/\n    function(module,exports,__webpack_require__){\n\n        /* WEBPACK VAR INJECTION */\n        (function(global){\n            'use strict';\n\n            var inViewport = __webpack_require__(3);\n            var lazyAttrs = ['data-src'];\n\n            global.lzld = lazyload();\n\n            // Provide libs using getAttribute early to get the good src\n            // and not the fake data-src\n            replaceGetAttribute('Image');\n            replaceGetAttribute('IFrame');\n\n            function registerLazyAttr(attr){\n                if(indexOf.call(lazyAttrs,attr) === -1){\n                    lazyAttrs.push(attr);\n                }\n            }\n\n            function lazyload(opts){\n                opts = merge({\n                    'offset':333,\n                    'src':'data-src',\n                    'container':false\n                },opts || {});\n\n                if(typeof opts.src === 'string'){\n                    registerLazyAttr(opts.src);\n                }\n\n                var elts = [];\n\n                function show(elt){\n                    var src = findRealSrc(elt);\n\n                    if(src){\n                        elt.src = src;\n                    }\n\n                    elt.setAttribute('data-lzled',true);\n                    elts[indexOf.call(elts,elt)] = null;\n                }\n\n                function findRealSrc(elt){\n                    if(typeof opts.src === 'function'){\n                        return opts.src(elt);\n                    }\n\n                    return elt.getAttribute(opts.src);\n                }\n\n                function register(elt){\n                    elt.onload = null;\n                    elt.removeAttribute('onload');\n                    elt.onerror = null;\n                    elt.removeAttribute('onerror');\n\n                    if(indexOf.call(elts,elt) === -1){\n                        inViewport(elt,opts,show);\n                    }\n                }\n\n                return register;\n            }\n\n            function replaceGetAttribute(elementName){\n                var fullname = 'HTML' + elementName + 'Element';\n                if(fullname in global === false){\n                    return;\n                }\n\n                var original = global[fullname].prototype.getAttribute;\n                global[fullname].prototype.getAttribute = function(name){\n                    if(name === 'src'){\n                        var realSrc;\n                        for(var i = 0,max = lazyAttrs.length; i < max; i++){\n                            realSrc = original.call(this,lazyAttrs[i]);\n                            if(realSrc){\n                                break;\n                            }\n                        }\n\n                        return realSrc || original.call(this,name);\n                    }\n\n                    // our own lazyloader will go through theses lines\n                    // because we use getAttribute(opts.src)\n                    return original.call(this,name);\n                };\n            }\n\n            function merge(defaults,opts){\n                for(var name in defaults){\n                    if(opts[name] === undefined){\n                        opts[name] = defaults[name];\n                    }\n                }\n\n                return opts;\n            }\n\n            // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html\n            function indexOf(value){\n                for(var i = this.length; i-- && this[i] !== value;){}\n                return i;\n            }\n\n            module.exports = lazyload;\n\n            // export default impush;\n            /* WEBPACK VAR INJECTION */\n        }.call(exports,(function(){\n            return this;\n        }())))\n\n        /***/\n    },\n    /* 2 */\n    /***/\n    function(module,exports){\n\n        'use strict';\n\n        var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector){\n\n            // parse slide data (url, title, size ...) from DOM elements\n            // (children of gallerySelector)\n            var parseThumbnailElements = function parseThumbnailElements(el){\n                el = el.parentNode.parentNode;\n                var thumbElements = el.getElementsByClassName('thumb'),\n                    numNodes = thumbElements.length,\n                    items = [],\n                    figureEl,\n                    linkEl,\n                    size,\n                    type,\n                    // video or not\n                    target,\n                    item;\n\n                for(var i = 0; i < numNodes; i++){\n\n                    figureEl = thumbElements[i]; //\n\n                    // include only element nodes\n                    if(figureEl.nodeType !== 1){\n                        continue;\n                    }\n\n                    linkEl = figureEl.children[0]; //\n\n                    size = linkEl.getAttribute('data-size').split('x');\n                    type = linkEl.getAttribute('data-type');\n                    target = linkEl.getAttribute('data-target');\n                    // create slide object\n                    item = {\n                        src:linkEl.getAttribute('href'),\n                        w:parseInt(size[0],10),\n                        h:parseInt(size[1],10)\n                    };\n\n                    if(figureEl.children.length > 1){\n                        item.title = figureEl.children[1].innerHTML;\n                    }\n\n                    if(linkEl.children.length > 0){\n                        item.msrc = linkEl.children[0].getAttribute('src');\n                        item.type = type;\n                        item.target = target;\n                        item.html = '<video src=\"' + target + '\" controls=\"controls\" autoplay=\"autoplay\"></video>';\n                        if(type === 'video'){\n                            //item.src = null;\n                        }\n                    }\n\n                    item.el = figureEl; // save link to element for getThumbBoundsFn\n                    items.push(item);\n                }\n\n                return items;\n            };\n\n            // find nearest parent element\n            var closest = function closest(el,fn){\n                return el && (fn(el) ? el : closest(el.parentNode,fn));\n            };\n\n            // triggers when user clicks on thumbnail\n            var onThumbnailsClick = function onThumbnailsClick(e){\n                e = e || window.event;\n                e.preventDefault ? e.preventDefault() : e.returnValue = false;\n\n                var eTarget = e.target || e.srcElement;\n\n                // find root element of slide\n                var clickedListItem = closest(eTarget,function(el){\n                    return el.tagName && el.tagName.toUpperCase() === 'FIGURE';\n                });\n\n                if(!clickedListItem){\n                    return;\n                }\n\n                // find index of clicked item by looping through all child nodes\n                // alternatively, you may define index via data- attribute\n                var clickedGallery = clickedListItem.parentNode,\n\n                    // childNodes = clickedListItem.parentNode.childNodes,\n                    // numChildNodes = childNodes.length,\n                    childNodes = document.getElementsByClassName('thumb'),\n                    numChildNodes = childNodes.length,\n                    nodeIndex = 0,\n                    index;\n\n                for(var i = 0; i < numChildNodes; i++){\n                    if(childNodes[i].nodeType !== 1){\n                        continue;\n                    }\n\n                    if(childNodes[i] === clickedListItem){\n                        index = nodeIndex;\n                        break;\n                    }\n                    nodeIndex++;\n                }\n\n                if(index >= 0){\n                    // open PhotoSwipe if valid index found\n                    openPhotoSwipe(index,clickedGallery);\n                }\n                return false;\n            };\n\n            // parse picture index and gallery index from URL (#&pid=1&gid=2)\n            var photoswipeParseHash = function photoswipeParseHash(){\n                var hash = window.location.hash.substring(1),\n                    params = {};\n\n                if(hash.length < 5){\n                    return params;\n                }\n\n                var vars = hash.split('&');\n                for(var i = 0; i < vars.length; i++){\n                    if(!vars[i]){\n                        continue;\n                    }\n                    var pair = vars[i].split('=');\n                    if(pair.length < 2){\n                        continue;\n                    }\n                    params[pair[0]] = pair[1];\n                }\n\n                if(params.gid){\n                    params.gid = parseInt(params.gid,10);\n                }\n\n                return params;\n            };\n\n            var openPhotoSwipe = function openPhotoSwipe(index,galleryElement,disableAnimation,fromURL){\n                var pswpElement = document.querySelectorAll('.pswp')[0],\n                    gallery,\n                    options,\n                    items;\n\n                items = parseThumbnailElements(galleryElement);\n                // define options (if needed)\n                options = {\n\n                    // define gallery index (for URL)\n                    galleryUID:galleryElement.getAttribute('data-pswp-uid'),\n\n                    getThumbBoundsFn:function getThumbBoundsFn(index){\n                        // See Options -> getThumbBoundsFn section of documentation for more info\n                        var thumbnail = items[index].el.getElementsByTagName('img')[0],\n                            // find thumbnail\n                            pageYScroll = window.pageYOffset || document.documentElement.scrollTop,\n                            rect = thumbnail.getBoundingClientRect();\n\n                        return {\n                            x:rect.left,\n                            y:rect.top + pageYScroll,\n                            w:rect.width\n                        };\n                    }\n\n                };\n\n                // PhotoSwipe opened from URL\n                if(fromURL){\n                    if(options.galleryPIDs){\n                        // parse real index when custom PIDs are used\n                        // http://photoswipe.com/documentation/faq.html#custom-pid-in-url\n                        for(var j = 0; j < items.length; j++){\n                            if(items[j].pid == index){\n                                options.index = j;\n                                break;\n                            }\n                        }\n                    }else{\n                        // in URL indexes start from 1\n                        options.index = parseInt(index,10) - 1;\n                    }\n                }else{\n                    options.index = parseInt(index,10);\n                }\n\n                // exit if index not found\n                if(isNaN(options.index)){\n                    return;\n                }\n\n                if(disableAnimation){\n                    options.showAnimationDuration = 0;\n                }\n\n                // Pass data to PhotoSwipe and initialize it\n                gallery = new PhotoSwipe(pswpElement,PhotoSwipeUI_Default,items,options);\n                gallery.init();\n\n                var $tempVideo;\n                var stopVideoHandle = function stopVideoHandle(){\n                    if($tempVideo){\n                        $tempVideo.remove();\n                        $tempVideo = null;\n                    }\n                };\n                var changeHandle = function changeHandle(){\n                    var item = gallery.currItem;\n                    stopVideoHandle();\n                    if(item.type === 'video'){\n                        var $ctn = item.container;\n                        var style = $ctn.getElementsByClassName('pswp__img')[0].style;\n                        var $video = document.createElement('video');\n                        $video.setAttribute('autoplay','autoplay');\n                        $video.setAttribute('controls','controls');\n                        $video.setAttribute('src',item.target);\n                        $video.style.width = style.width;\n                        $video.style.height = style.height;\n                        $video.style.position = 'absolute';\n                        $video.style.zIndex = 2;\n                        $tempVideo = $video;\n                        $ctn.appendChild($video);\n                    }\n                };\n                gallery.listen('initialZoomIn',changeHandle);\n                gallery.listen('afterChange',changeHandle);\n                gallery.listen('initialZoomOut',stopVideoHandle);\n            };\n\n            // loop through all gallery elements and bind events\n            var galleryElements = document.querySelectorAll(gallerySelector);\n            for(var i = 0,l = galleryElements.length; i < l; i++){\n                galleryElements[i].setAttribute('data-pswp-uid',i + 1);\n                galleryElements[i].onclick = onThumbnailsClick;\n            }\n\n            // Parse URL and open gallery if it contains #&pid=3&gid=1\n            var hashData = photoswipeParseHash();\n            if(hashData.pid && hashData.gid){\n                openPhotoSwipe(hashData.pid,galleryElements[hashData.gid - 1],true,true);\n            }\n        };\n\n        var Viewer = function(){\n            function init(){\n                initPhotoSwipeFromDOM('.photos');\n            }\n\n            return {\n                init:init\n            };\n        }();\n\n        module.exports = Viewer;\n\n        /***/\n    },\n    /* 3 */\n    /***/\n    function(module,exports){\n\n        /* WEBPACK VAR INJECTION */\n        (function(global){\n            module.exports = inViewport;\n\n            var instances = [];\n            var supportsMutationObserver = typeof global.MutationObserver === 'function';\n\n            function inViewport(elt,params,cb){\n                var opts = {\n                    container:global.document.body,\n                    offset:0\n                };\n\n                if(params === undefined || typeof params === 'function'){\n                    cb = params;\n                    params = {};\n                }\n\n                var container = opts.container = params.container || opts.container;\n                var offset = opts.offset = params.offset || opts.offset;\n\n                for(var i = 0; i < instances.length; i++){\n                    if(instances[i].container === container){\n                        return instances[i].isInViewport(elt,offset,cb);\n                    }\n                }\n\n                return instances[\n                instances.push(createInViewport(container)) - 1\n                    ].isInViewport(elt,offset,cb);\n            }\n\n            function addEvent(el,type,fn){\n                if(el.attachEvent){\n                    el.attachEvent('on' + type,fn);\n                }else{\n                    el.addEventListener(type,fn,false);\n                }\n            }\n\n            function debounce(func,wait,immediate){\n                var timeout;\n                return function(){\n                    var context = this,\n                        args = arguments;\n                    var callNow = immediate && !timeout;\n                    clearTimeout(timeout);\n                    timeout = setTimeout(later,wait);\n                    if(callNow) func.apply(context,args);\n\n                    function later(){\n                        timeout = null;\n                        if(!immediate) func.apply(context,args);\n                    }\n                };\n            }\n\n            // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708\n            var contains = function(){\n                if(!global.document){\n                    return true;\n                }\n                return global.document.documentElement.compareDocumentPosition ?\n                    function(a,b){\n                        return !!(a.compareDocumentPosition(b) & 16);\n                    } :\n                    global.document.documentElement.contains ?\n                        function(a,b){\n                            return a !== b && (a.contains ? a.contains(b) : false);\n                        } :\n                        function(a,b){\n                            while(b = b.parentNode){\n                                if(b === a){\n                                    return true;\n                                }\n                            }\n                            return false;\n                        };\n            }\n\n            function createInViewport(container){\n                var watches = createWatches();\n\n                var scrollContainer = container === global.document.body ? global : container;\n                var debouncedCheck = debounce(watches.checkAll(watchInViewport),15);\n\n                addEvent(scrollContainer,'scroll',debouncedCheck);\n\n                if(scrollContainer === global){\n                    addEvent(global,'resize',debouncedCheck);\n                }\n\n                if(supportsMutationObserver){\n                    observeDOM(watches,container,debouncedCheck);\n                }\n\n                // failsafe check, every 200ms we check for visible images\n                // usecase: a hidden parent containing eleements\n                // when the parent becomes visible, we have no event that the children\n                // became visible\n                setInterval(debouncedCheck,150);\n\n                function isInViewport(elt,offset,cb){\n                    if(!cb){\n                        return isVisible(elt,offset);\n                    }\n\n                    var remote = createRemote(elt,offset,cb);\n                    remote.watch();\n                    return remote;\n                }\n\n                function createRemote(elt,offset,cb){\n                    function watch(){\n                        watches.add(elt,offset,cb);\n                    }\n\n                    function dispose(){\n                        watches.remove(elt);\n                    }\n\n                    return {\n                        watch:watch,\n                        dispose:dispose\n                    };\n                }\n\n                function watchInViewport(elt,offset,cb){\n                    if(isVisible(elt,offset)){\n                        watches.remove(elt);\n                        cb(elt);\n                    }\n                }\n\n                function isVisible(elt,offset){\n                    if(!contains(global.document.documentElement,elt) || !contains(global.document.documentElement,container)){\n                        return false;\n                    }\n\n                    // Check if the element is visible\n                    // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js\n                    if(!elt.offsetWidth || !elt.offsetHeight){\n                        return false;\n                    }\n\n                    var eltRect = elt.getBoundingClientRect();\n                    var viewport = {};\n\n                    if(container === global.document.body){\n                        viewport = {\n                            top:-offset,\n                            left:-offset,\n                            right:global.document.documentElement.clientWidth + offset,\n                            bottom:global.document.documentElement.clientHeight + offset\n                        };\n                    }else{\n                        var containerRect = container.getBoundingClientRect();\n                        viewport = {\n                            top:containerRect.top - offset,\n                            left:containerRect.left - offset,\n                            right:containerRect.right + offset,\n                            bottom:containerRect.bottom + offset\n                        };\n                    }\n\n                    // The element must overlap with the visible part of the viewport\n                    var visible =\n                        (\n                            (eltRect.right > viewport.left) &&\n                            (eltRect.left < viewport.right) &&\n                            (eltRect.bottom > viewport.top) &&\n                            (eltRect.top < viewport.bottom)\n                        );\n\n                    return visible;\n                }\n\n                return {\n                    container:container,\n                    isInViewport:isInViewport\n                };\n            }\n\n            function createWatches(){\n                var watches = [];\n\n                function add(elt,offset,cb){\n                    if(!isWatched(elt)){\n                        watches.push([elt,offset,cb]);\n                    }\n                }\n\n                function remove(elt){\n                    var pos = indexOf(elt);\n                    if(pos !== -1){\n                        watches.splice(pos,1);\n                    }\n                }\n\n                function indexOf(elt){\n                    for(var i = watches.length - 1; i >= 0; i--){\n                        if(watches[i][0] === elt){\n                            return i;\n                        }\n                    }\n                    return -1;\n                }\n\n                function isWatched(elt){\n                    return indexOf(elt) !== -1;\n                }\n\n                function checkAll(cb){\n                    return function(){\n                        for(var i = watches.length - 1; i >= 0; i--){\n                            cb.apply(this,watches[i]);\n                        }\n                    };\n                }\n\n                return {\n                    add:add,\n                    remove:remove,\n                    isWatched:isWatched,\n                    checkAll:checkAll\n                };\n            }\n\n            function observeDOM(watches,container,cb){\n                var observer = new MutationObserver(watch);\n                var filter = Array.prototype.filter;\n                var concat = Array.prototype.concat;\n\n                observer.observe(container,{\n                    childList:true,\n                    subtree:true,\n                    // changes like style/width/height/display will be catched\n                    attributes:true\n                });\n\n                function watch(mutations){\n                    // some new DOM nodes where previously watched\n                    // we should check their positions\n                    if(mutations.some(knownNodes) === true){\n                        setTimeout(cb,0);\n                    }\n                }\n\n                function knownNodes(mutation){\n                    var nodes = concat.call([],\n                        Array.prototype.slice.call(mutation.addedNodes),\n                        mutation.target\n                    );\n                    return filter.call(nodes,watches.isWatched).length > 0;\n                }\n            }\n\n            /* WEBPACK VAR INJECTION */\n        }.call(exports,(function(){\n            return this;\n        }())))\n\n        /***/\n    }\n    /******/\n]);","source":"photos/ins.js","raw":"/******/\n(function(modules){ // webpackBootstrap\n    /******/ // The module cache\n    /******/\n    var installedModules = {};\n    /******/\n    /******/ // The require function\n    /******/\n    function __webpack_require__(moduleId){\n        /******/\n        /******/ // Check if module is in cache\n        /******/\n        if(installedModules[moduleId])\n        /******/\n            return installedModules[moduleId].exports;\n        /******/\n        /******/ // Create a new module (and put it into the cache)\n        /******/\n        var module = installedModules[moduleId] = {\n            /******/\n            exports:{},\n            /******/\n            id:moduleId,\n            /******/\n            loaded:false\n            /******/\n        };\n        /******/\n        /******/ // Execute the module function\n        /******/\n        modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);\n        /******/\n        /******/ // Flag the module as loaded\n        /******/\n        module.loaded = true;\n        /******/\n        /******/ // Return the exports of the module\n        /******/\n        return module.exports;\n        /******/\n    }\n\n    /******/\n    /******/\n    /******/ // expose the modules object (__webpack_modules__)\n    /******/\n    __webpack_require__.m = modules;\n    /******/\n    /******/ // expose the module cache\n    /******/\n    __webpack_require__.c = installedModules;\n    /******/\n    /******/ // __webpack_public_path__\n    /******/\n    __webpack_require__.p = \"/dist/\";\n    /******/\n    /******/ // Load entry module and return exports\n    /******/\n    return __webpack_require__(0);\n    /******/\n})\n/************************************************************************/\n/******/\n([\n    /* 0 */\n    /***/\n    function(module,exports,__webpack_require__){\n\n        'use strict';\n\n        __webpack_require__(1);\n\n        var _view = __webpack_require__(2);\n\n        var _view2 = _interopRequireDefault(_view);\n\n        function _interopRequireDefault(obj){\n            return obj && obj.__esModule ? obj : {\n                default:obj\n            };\n        }\n\n        /**\n         * @name impush-client\n         * @description 这个项目让我发家致富…\n         * @date 2016-12-1\n         */\n\n        var _collection = [];\n        var _count = 0;\n        var searchData;\n\n        function addMask(elem){\n            var rect = elem.getBoundingClientRect();\n            var style = getComputedStyle(elem,null);\n\n            var mask = document.createElement('i');\n            mask.className = 'icon-film';\n            mask.style.color = '#fff';\n            mask.style.fontSize = '26px';\n            mask.style.position = 'absolute';\n            mask.style.right = '10px';\n            mask.style.bottom = '10px';\n            mask.style.zIndex = 1;\n            elem.parentNode.appendChild(mask);\n        }\n\n        var createVideoIncon = function createVideoIncon(){\n            var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]');\n            for(var i = 0,len = $videoImg.length; i < len; i++){\n                addMask($videoImg[i]);\n            }\n        };\n        var render = function render(res){\n            var ulTmpl = \"\";\n            for(var j = 0,len2 = res.list.length; j < len2; j++){\n                var data = res.list[j].arr;\n                var liTmpl = \"\";\n                for(var i = 0,len = data.link.length; i < len; i++){\n                    var minSrc = 'https://raw.githubusercontent.com/0000zjn/Blog-File-Back-Up/master/min_photos/' + data.link[i];\n                    var src = 'https://raw.githubusercontent.com/0000zjn/Blog-File-Back-Up/master/photos/' + data.link[i];\n                    var type = data.type[i];\n                    var target = src + (type === 'video' ? '.mp4' : '.jpg');\n                    src += '';\n\n                    liTmpl += '<figure class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\">\\\n                <a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"1080x1080\" data-type=\"' + type + '\" data-target=\"' + src + '\">\\\n                  <img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"/assets/img/empty.png\" itemprop=\"thumbnail\" onload=\"lzld(this)\">\\\n                </a>\\\n                <figcaption style=\"display:none\" itemprop=\"caption description\">' + data.text[i] + '</figcaption>\\\n            </figure>';\n                }\n                ulTmpl = ulTmpl + '<section class=\"archives album\"><h1 class=\"year\">' + data.year + '年<em>' + data.month + '月</em></h1>\\\n        <ul class=\"img-box-ul\">' + liTmpl + '</ul>\\\n        </section>';\n            }\n            document.querySelector('.instagram').innerHTML = '<div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\">' + ulTmpl + '</div>';\n            createVideoIncon();\n            _view2.default.init();\n        };\n\n        var replacer = function replacer(str){\n            var arr = str.split(\"/\");\n            return \"/assets/ins/\" + arr[arr.length - 1];\n        };\n\n        var ctrler = function ctrler(data){\n            var imgObj = {};\n            for(var i = 0,len = data.length; i < len; i++){\n                var y = data[i].y;\n                var m = data[i].m;\n                var src = replacer(data[i].src);\n                var text = data[i].text;\n                var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m);\n                if(imgObj[key]){\n                    imgObj[key].srclist.push(src);\n                    imgObj[key].text.push(text);\n                }else{\n                    imgObj[key] = {\n                        year:y,\n                        month:m,\n                        srclist:[src],\n                        text:[text]\n                    };\n                }\n            }\n            render(imgObj);\n        };\n\n        function loadData(success){\n            if(!searchData){\n                var xhr = new XMLHttpRequest();\n                xhr.open('GET','./data.json?t=' + +new Date(),true);\n\n                xhr.onload = function(){\n                    if(this.status >= 200 && this.status < 300){\n                        var res = JSON.parse(this.response);\n                        searchData = res;\n                        success(searchData);\n                    }else{\n                        console.error(this.statusText);\n                    }\n                };\n\n                xhr.onerror = function(){\n                    console.error(this.statusText);\n                };\n\n                xhr.send();\n            }else{\n                success(searchData);\n            }\n        }\n\n        var Ins = {\n            init:function init(){\n                loadData(function(data){\n                    render(data);\n                });\n            }\n        };\n\n        Ins.init();\n\n        // export default impush;\n\n        /***/\n    },\n    /* 1 */\n    /***/\n    function(module,exports,__webpack_require__){\n\n        /* WEBPACK VAR INJECTION */\n        (function(global){\n            'use strict';\n\n            var inViewport = __webpack_require__(3);\n            var lazyAttrs = ['data-src'];\n\n            global.lzld = lazyload();\n\n            // Provide libs using getAttribute early to get the good src\n            // and not the fake data-src\n            replaceGetAttribute('Image');\n            replaceGetAttribute('IFrame');\n\n            function registerLazyAttr(attr){\n                if(indexOf.call(lazyAttrs,attr) === -1){\n                    lazyAttrs.push(attr);\n                }\n            }\n\n            function lazyload(opts){\n                opts = merge({\n                    'offset':333,\n                    'src':'data-src',\n                    'container':false\n                },opts || {});\n\n                if(typeof opts.src === 'string'){\n                    registerLazyAttr(opts.src);\n                }\n\n                var elts = [];\n\n                function show(elt){\n                    var src = findRealSrc(elt);\n\n                    if(src){\n                        elt.src = src;\n                    }\n\n                    elt.setAttribute('data-lzled',true);\n                    elts[indexOf.call(elts,elt)] = null;\n                }\n\n                function findRealSrc(elt){\n                    if(typeof opts.src === 'function'){\n                        return opts.src(elt);\n                    }\n\n                    return elt.getAttribute(opts.src);\n                }\n\n                function register(elt){\n                    elt.onload = null;\n                    elt.removeAttribute('onload');\n                    elt.onerror = null;\n                    elt.removeAttribute('onerror');\n\n                    if(indexOf.call(elts,elt) === -1){\n                        inViewport(elt,opts,show);\n                    }\n                }\n\n                return register;\n            }\n\n            function replaceGetAttribute(elementName){\n                var fullname = 'HTML' + elementName + 'Element';\n                if(fullname in global === false){\n                    return;\n                }\n\n                var original = global[fullname].prototype.getAttribute;\n                global[fullname].prototype.getAttribute = function(name){\n                    if(name === 'src'){\n                        var realSrc;\n                        for(var i = 0,max = lazyAttrs.length; i < max; i++){\n                            realSrc = original.call(this,lazyAttrs[i]);\n                            if(realSrc){\n                                break;\n                            }\n                        }\n\n                        return realSrc || original.call(this,name);\n                    }\n\n                    // our own lazyloader will go through theses lines\n                    // because we use getAttribute(opts.src)\n                    return original.call(this,name);\n                };\n            }\n\n            function merge(defaults,opts){\n                for(var name in defaults){\n                    if(opts[name] === undefined){\n                        opts[name] = defaults[name];\n                    }\n                }\n\n                return opts;\n            }\n\n            // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html\n            function indexOf(value){\n                for(var i = this.length; i-- && this[i] !== value;){}\n                return i;\n            }\n\n            module.exports = lazyload;\n\n            // export default impush;\n            /* WEBPACK VAR INJECTION */\n        }.call(exports,(function(){\n            return this;\n        }())))\n\n        /***/\n    },\n    /* 2 */\n    /***/\n    function(module,exports){\n\n        'use strict';\n\n        var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector){\n\n            // parse slide data (url, title, size ...) from DOM elements\n            // (children of gallerySelector)\n            var parseThumbnailElements = function parseThumbnailElements(el){\n                el = el.parentNode.parentNode;\n                var thumbElements = el.getElementsByClassName('thumb'),\n                    numNodes = thumbElements.length,\n                    items = [],\n                    figureEl,\n                    linkEl,\n                    size,\n                    type,\n                    // video or not\n                    target,\n                    item;\n\n                for(var i = 0; i < numNodes; i++){\n\n                    figureEl = thumbElements[i]; //\n\n                    // include only element nodes\n                    if(figureEl.nodeType !== 1){\n                        continue;\n                    }\n\n                    linkEl = figureEl.children[0]; //\n\n                    size = linkEl.getAttribute('data-size').split('x');\n                    type = linkEl.getAttribute('data-type');\n                    target = linkEl.getAttribute('data-target');\n                    // create slide object\n                    item = {\n                        src:linkEl.getAttribute('href'),\n                        w:parseInt(size[0],10),\n                        h:parseInt(size[1],10)\n                    };\n\n                    if(figureEl.children.length > 1){\n                        item.title = figureEl.children[1].innerHTML;\n                    }\n\n                    if(linkEl.children.length > 0){\n                        item.msrc = linkEl.children[0].getAttribute('src');\n                        item.type = type;\n                        item.target = target;\n                        item.html = '<video src=\"' + target + '\" controls=\"controls\" autoplay=\"autoplay\"></video>';\n                        if(type === 'video'){\n                            //item.src = null;\n                        }\n                    }\n\n                    item.el = figureEl; // save link to element for getThumbBoundsFn\n                    items.push(item);\n                }\n\n                return items;\n            };\n\n            // find nearest parent element\n            var closest = function closest(el,fn){\n                return el && (fn(el) ? el : closest(el.parentNode,fn));\n            };\n\n            // triggers when user clicks on thumbnail\n            var onThumbnailsClick = function onThumbnailsClick(e){\n                e = e || window.event;\n                e.preventDefault ? e.preventDefault() : e.returnValue = false;\n\n                var eTarget = e.target || e.srcElement;\n\n                // find root element of slide\n                var clickedListItem = closest(eTarget,function(el){\n                    return el.tagName && el.tagName.toUpperCase() === 'FIGURE';\n                });\n\n                if(!clickedListItem){\n                    return;\n                }\n\n                // find index of clicked item by looping through all child nodes\n                // alternatively, you may define index via data- attribute\n                var clickedGallery = clickedListItem.parentNode,\n\n                    // childNodes = clickedListItem.parentNode.childNodes,\n                    // numChildNodes = childNodes.length,\n                    childNodes = document.getElementsByClassName('thumb'),\n                    numChildNodes = childNodes.length,\n                    nodeIndex = 0,\n                    index;\n\n                for(var i = 0; i < numChildNodes; i++){\n                    if(childNodes[i].nodeType !== 1){\n                        continue;\n                    }\n\n                    if(childNodes[i] === clickedListItem){\n                        index = nodeIndex;\n                        break;\n                    }\n                    nodeIndex++;\n                }\n\n                if(index >= 0){\n                    // open PhotoSwipe if valid index found\n                    openPhotoSwipe(index,clickedGallery);\n                }\n                return false;\n            };\n\n            // parse picture index and gallery index from URL (#&pid=1&gid=2)\n            var photoswipeParseHash = function photoswipeParseHash(){\n                var hash = window.location.hash.substring(1),\n                    params = {};\n\n                if(hash.length < 5){\n                    return params;\n                }\n\n                var vars = hash.split('&');\n                for(var i = 0; i < vars.length; i++){\n                    if(!vars[i]){\n                        continue;\n                    }\n                    var pair = vars[i].split('=');\n                    if(pair.length < 2){\n                        continue;\n                    }\n                    params[pair[0]] = pair[1];\n                }\n\n                if(params.gid){\n                    params.gid = parseInt(params.gid,10);\n                }\n\n                return params;\n            };\n\n            var openPhotoSwipe = function openPhotoSwipe(index,galleryElement,disableAnimation,fromURL){\n                var pswpElement = document.querySelectorAll('.pswp')[0],\n                    gallery,\n                    options,\n                    items;\n\n                items = parseThumbnailElements(galleryElement);\n                // define options (if needed)\n                options = {\n\n                    // define gallery index (for URL)\n                    galleryUID:galleryElement.getAttribute('data-pswp-uid'),\n\n                    getThumbBoundsFn:function getThumbBoundsFn(index){\n                        // See Options -> getThumbBoundsFn section of documentation for more info\n                        var thumbnail = items[index].el.getElementsByTagName('img')[0],\n                            // find thumbnail\n                            pageYScroll = window.pageYOffset || document.documentElement.scrollTop,\n                            rect = thumbnail.getBoundingClientRect();\n\n                        return {\n                            x:rect.left,\n                            y:rect.top + pageYScroll,\n                            w:rect.width\n                        };\n                    }\n\n                };\n\n                // PhotoSwipe opened from URL\n                if(fromURL){\n                    if(options.galleryPIDs){\n                        // parse real index when custom PIDs are used\n                        // http://photoswipe.com/documentation/faq.html#custom-pid-in-url\n                        for(var j = 0; j < items.length; j++){\n                            if(items[j].pid == index){\n                                options.index = j;\n                                break;\n                            }\n                        }\n                    }else{\n                        // in URL indexes start from 1\n                        options.index = parseInt(index,10) - 1;\n                    }\n                }else{\n                    options.index = parseInt(index,10);\n                }\n\n                // exit if index not found\n                if(isNaN(options.index)){\n                    return;\n                }\n\n                if(disableAnimation){\n                    options.showAnimationDuration = 0;\n                }\n\n                // Pass data to PhotoSwipe and initialize it\n                gallery = new PhotoSwipe(pswpElement,PhotoSwipeUI_Default,items,options);\n                gallery.init();\n\n                var $tempVideo;\n                var stopVideoHandle = function stopVideoHandle(){\n                    if($tempVideo){\n                        $tempVideo.remove();\n                        $tempVideo = null;\n                    }\n                };\n                var changeHandle = function changeHandle(){\n                    var item = gallery.currItem;\n                    stopVideoHandle();\n                    if(item.type === 'video'){\n                        var $ctn = item.container;\n                        var style = $ctn.getElementsByClassName('pswp__img')[0].style;\n                        var $video = document.createElement('video');\n                        $video.setAttribute('autoplay','autoplay');\n                        $video.setAttribute('controls','controls');\n                        $video.setAttribute('src',item.target);\n                        $video.style.width = style.width;\n                        $video.style.height = style.height;\n                        $video.style.position = 'absolute';\n                        $video.style.zIndex = 2;\n                        $tempVideo = $video;\n                        $ctn.appendChild($video);\n                    }\n                };\n                gallery.listen('initialZoomIn',changeHandle);\n                gallery.listen('afterChange',changeHandle);\n                gallery.listen('initialZoomOut',stopVideoHandle);\n            };\n\n            // loop through all gallery elements and bind events\n            var galleryElements = document.querySelectorAll(gallerySelector);\n            for(var i = 0,l = galleryElements.length; i < l; i++){\n                galleryElements[i].setAttribute('data-pswp-uid',i + 1);\n                galleryElements[i].onclick = onThumbnailsClick;\n            }\n\n            // Parse URL and open gallery if it contains #&pid=3&gid=1\n            var hashData = photoswipeParseHash();\n            if(hashData.pid && hashData.gid){\n                openPhotoSwipe(hashData.pid,galleryElements[hashData.gid - 1],true,true);\n            }\n        };\n\n        var Viewer = function(){\n            function init(){\n                initPhotoSwipeFromDOM('.photos');\n            }\n\n            return {\n                init:init\n            };\n        }();\n\n        module.exports = Viewer;\n\n        /***/\n    },\n    /* 3 */\n    /***/\n    function(module,exports){\n\n        /* WEBPACK VAR INJECTION */\n        (function(global){\n            module.exports = inViewport;\n\n            var instances = [];\n            var supportsMutationObserver = typeof global.MutationObserver === 'function';\n\n            function inViewport(elt,params,cb){\n                var opts = {\n                    container:global.document.body,\n                    offset:0\n                };\n\n                if(params === undefined || typeof params === 'function'){\n                    cb = params;\n                    params = {};\n                }\n\n                var container = opts.container = params.container || opts.container;\n                var offset = opts.offset = params.offset || opts.offset;\n\n                for(var i = 0; i < instances.length; i++){\n                    if(instances[i].container === container){\n                        return instances[i].isInViewport(elt,offset,cb);\n                    }\n                }\n\n                return instances[\n                instances.push(createInViewport(container)) - 1\n                    ].isInViewport(elt,offset,cb);\n            }\n\n            function addEvent(el,type,fn){\n                if(el.attachEvent){\n                    el.attachEvent('on' + type,fn);\n                }else{\n                    el.addEventListener(type,fn,false);\n                }\n            }\n\n            function debounce(func,wait,immediate){\n                var timeout;\n                return function(){\n                    var context = this,\n                        args = arguments;\n                    var callNow = immediate && !timeout;\n                    clearTimeout(timeout);\n                    timeout = setTimeout(later,wait);\n                    if(callNow) func.apply(context,args);\n\n                    function later(){\n                        timeout = null;\n                        if(!immediate) func.apply(context,args);\n                    }\n                };\n            }\n\n            // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708\n            var contains = function(){\n                if(!global.document){\n                    return true;\n                }\n                return global.document.documentElement.compareDocumentPosition ?\n                    function(a,b){\n                        return !!(a.compareDocumentPosition(b) & 16);\n                    } :\n                    global.document.documentElement.contains ?\n                        function(a,b){\n                            return a !== b && (a.contains ? a.contains(b) : false);\n                        } :\n                        function(a,b){\n                            while(b = b.parentNode){\n                                if(b === a){\n                                    return true;\n                                }\n                            }\n                            return false;\n                        };\n            }\n\n            function createInViewport(container){\n                var watches = createWatches();\n\n                var scrollContainer = container === global.document.body ? global : container;\n                var debouncedCheck = debounce(watches.checkAll(watchInViewport),15);\n\n                addEvent(scrollContainer,'scroll',debouncedCheck);\n\n                if(scrollContainer === global){\n                    addEvent(global,'resize',debouncedCheck);\n                }\n\n                if(supportsMutationObserver){\n                    observeDOM(watches,container,debouncedCheck);\n                }\n\n                // failsafe check, every 200ms we check for visible images\n                // usecase: a hidden parent containing eleements\n                // when the parent becomes visible, we have no event that the children\n                // became visible\n                setInterval(debouncedCheck,150);\n\n                function isInViewport(elt,offset,cb){\n                    if(!cb){\n                        return isVisible(elt,offset);\n                    }\n\n                    var remote = createRemote(elt,offset,cb);\n                    remote.watch();\n                    return remote;\n                }\n\n                function createRemote(elt,offset,cb){\n                    function watch(){\n                        watches.add(elt,offset,cb);\n                    }\n\n                    function dispose(){\n                        watches.remove(elt);\n                    }\n\n                    return {\n                        watch:watch,\n                        dispose:dispose\n                    };\n                }\n\n                function watchInViewport(elt,offset,cb){\n                    if(isVisible(elt,offset)){\n                        watches.remove(elt);\n                        cb(elt);\n                    }\n                }\n\n                function isVisible(elt,offset){\n                    if(!contains(global.document.documentElement,elt) || !contains(global.document.documentElement,container)){\n                        return false;\n                    }\n\n                    // Check if the element is visible\n                    // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js\n                    if(!elt.offsetWidth || !elt.offsetHeight){\n                        return false;\n                    }\n\n                    var eltRect = elt.getBoundingClientRect();\n                    var viewport = {};\n\n                    if(container === global.document.body){\n                        viewport = {\n                            top:-offset,\n                            left:-offset,\n                            right:global.document.documentElement.clientWidth + offset,\n                            bottom:global.document.documentElement.clientHeight + offset\n                        };\n                    }else{\n                        var containerRect = container.getBoundingClientRect();\n                        viewport = {\n                            top:containerRect.top - offset,\n                            left:containerRect.left - offset,\n                            right:containerRect.right + offset,\n                            bottom:containerRect.bottom + offset\n                        };\n                    }\n\n                    // The element must overlap with the visible part of the viewport\n                    var visible =\n                        (\n                            (eltRect.right > viewport.left) &&\n                            (eltRect.left < viewport.right) &&\n                            (eltRect.bottom > viewport.top) &&\n                            (eltRect.top < viewport.bottom)\n                        );\n\n                    return visible;\n                }\n\n                return {\n                    container:container,\n                    isInViewport:isInViewport\n                };\n            }\n\n            function createWatches(){\n                var watches = [];\n\n                function add(elt,offset,cb){\n                    if(!isWatched(elt)){\n                        watches.push([elt,offset,cb]);\n                    }\n                }\n\n                function remove(elt){\n                    var pos = indexOf(elt);\n                    if(pos !== -1){\n                        watches.splice(pos,1);\n                    }\n                }\n\n                function indexOf(elt){\n                    for(var i = watches.length - 1; i >= 0; i--){\n                        if(watches[i][0] === elt){\n                            return i;\n                        }\n                    }\n                    return -1;\n                }\n\n                function isWatched(elt){\n                    return indexOf(elt) !== -1;\n                }\n\n                function checkAll(cb){\n                    return function(){\n                        for(var i = watches.length - 1; i >= 0; i--){\n                            cb.apply(this,watches[i]);\n                        }\n                    };\n                }\n\n                return {\n                    add:add,\n                    remove:remove,\n                    isWatched:isWatched,\n                    checkAll:checkAll\n                };\n            }\n\n            function observeDOM(watches,container,cb){\n                var observer = new MutationObserver(watch);\n                var filter = Array.prototype.filter;\n                var concat = Array.prototype.concat;\n\n                observer.observe(container,{\n                    childList:true,\n                    subtree:true,\n                    // changes like style/width/height/display will be catched\n                    attributes:true\n                });\n\n                function watch(mutations){\n                    // some new DOM nodes where previously watched\n                    // we should check their positions\n                    if(mutations.some(knownNodes) === true){\n                        setTimeout(cb,0);\n                    }\n                }\n\n                function knownNodes(mutation){\n                    var nodes = concat.call([],\n                        Array.prototype.slice.call(mutation.addedNodes),\n                        mutation.target\n                    );\n                    return filter.call(nodes,watches.isWatched).length > 0;\n                }\n            }\n\n            /* WEBPACK VAR INJECTION */\n        }.call(exports,(function(){\n            return this;\n        }())))\n\n        /***/\n    }\n    /******/\n]);","date":"2020-11-09T02:39:37.475Z","updated":"2020-05-22T06:24:20.000Z","path":"photos/ins.js","layout":"false","title":"","comments":1,"_id":"cknb3zrl700372yku92nq2bf7","content":"/******/\n(function(modules){ // webpackBootstrap\n    /******/ // The module cache\n    /******/\n    var installedModules = {};\n    /******/\n    /******/ // The require function\n    /******/\n    function __webpack_require__(moduleId){\n        /******/\n        /******/ // Check if module is in cache\n        /******/\n        if(installedModules[moduleId])\n        /******/\n            return installedModules[moduleId].exports;\n        /******/\n        /******/ // Create a new module (and put it into the cache)\n        /******/\n        var module = installedModules[moduleId] = {\n            /******/\n            exports:{},\n            /******/\n            id:moduleId,\n            /******/\n            loaded:false\n            /******/\n        };\n        /******/\n        /******/ // Execute the module function\n        /******/\n        modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);\n        /******/\n        /******/ // Flag the module as loaded\n        /******/\n        module.loaded = true;\n        /******/\n        /******/ // Return the exports of the module\n        /******/\n        return module.exports;\n        /******/\n    }\n\n    /******/\n    /******/\n    /******/ // expose the modules object (__webpack_modules__)\n    /******/\n    __webpack_require__.m = modules;\n    /******/\n    /******/ // expose the module cache\n    /******/\n    __webpack_require__.c = installedModules;\n    /******/\n    /******/ // __webpack_public_path__\n    /******/\n    __webpack_require__.p = \"/dist/\";\n    /******/\n    /******/ // Load entry module and return exports\n    /******/\n    return __webpack_require__(0);\n    /******/\n})\n/************************************************************************/\n/******/\n([\n    /* 0 */\n    /***/\n    function(module,exports,__webpack_require__){\n\n        'use strict';\n\n        __webpack_require__(1);\n\n        var _view = __webpack_require__(2);\n\n        var _view2 = _interopRequireDefault(_view);\n\n        function _interopRequireDefault(obj){\n            return obj && obj.__esModule ? obj : {\n                default:obj\n            };\n        }\n\n        /**\n         * @name impush-client\n         * @description 这个项目让我发家致富…\n         * @date 2016-12-1\n         */\n\n        var _collection = [];\n        var _count = 0;\n        var searchData;\n\n        function addMask(elem){\n            var rect = elem.getBoundingClientRect();\n            var style = getComputedStyle(elem,null);\n\n            var mask = document.createElement('i');\n            mask.className = 'icon-film';\n            mask.style.color = '#fff';\n            mask.style.fontSize = '26px';\n            mask.style.position = 'absolute';\n            mask.style.right = '10px';\n            mask.style.bottom = '10px';\n            mask.style.zIndex = 1;\n            elem.parentNode.appendChild(mask);\n        }\n\n        var createVideoIncon = function createVideoIncon(){\n            var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]');\n            for(var i = 0,len = $videoImg.length; i < len; i++){\n                addMask($videoImg[i]);\n            }\n        };\n        var render = function render(res){\n            var ulTmpl = \"\";\n            for(var j = 0,len2 = res.list.length; j < len2; j++){\n                var data = res.list[j].arr;\n                var liTmpl = \"\";\n                for(var i = 0,len = data.link.length; i < len; i++){\n                    var minSrc = 'https://raw.githubusercontent.com/0000zjn/Blog-File-Back-Up/master/min_photos/' + data.link[i];\n                    var src = 'https://raw.githubusercontent.com/0000zjn/Blog-File-Back-Up/master/photos/' + data.link[i];\n                    var type = data.type[i];\n                    var target = src + (type === 'video' ? '.mp4' : '.jpg');\n                    src += '';\n\n                    liTmpl += '<figure class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\">\\\n                <a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"1080x1080\" data-type=\"' + type + '\" data-target=\"' + src + '\">\\\n                  <img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"/assets/img/empty.png\" itemprop=\"thumbnail\" onload=\"lzld(this)\">\\\n                </a>\\\n                <figcaption style=\"display:none\" itemprop=\"caption description\">' + data.text[i] + '</figcaption>\\\n            </figure>';\n                }\n                ulTmpl = ulTmpl + '<section class=\"archives album\"><h1 class=\"year\">' + data.year + '年<em>' + data.month + '月</em></h1>\\\n        <ul class=\"img-box-ul\">' + liTmpl + '</ul>\\\n        </section>';\n            }\n            document.querySelector('.instagram').innerHTML = '<div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\">' + ulTmpl + '</div>';\n            createVideoIncon();\n            _view2.default.init();\n        };\n\n        var replacer = function replacer(str){\n            var arr = str.split(\"/\");\n            return \"/assets/ins/\" + arr[arr.length - 1];\n        };\n\n        var ctrler = function ctrler(data){\n            var imgObj = {};\n            for(var i = 0,len = data.length; i < len; i++){\n                var y = data[i].y;\n                var m = data[i].m;\n                var src = replacer(data[i].src);\n                var text = data[i].text;\n                var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m);\n                if(imgObj[key]){\n                    imgObj[key].srclist.push(src);\n                    imgObj[key].text.push(text);\n                }else{\n                    imgObj[key] = {\n                        year:y,\n                        month:m,\n                        srclist:[src],\n                        text:[text]\n                    };\n                }\n            }\n            render(imgObj);\n        };\n\n        function loadData(success){\n            if(!searchData){\n                var xhr = new XMLHttpRequest();\n                xhr.open('GET','./data.json?t=' + +new Date(),true);\n\n                xhr.onload = function(){\n                    if(this.status >= 200 && this.status < 300){\n                        var res = JSON.parse(this.response);\n                        searchData = res;\n                        success(searchData);\n                    }else{\n                        console.error(this.statusText);\n                    }\n                };\n\n                xhr.onerror = function(){\n                    console.error(this.statusText);\n                };\n\n                xhr.send();\n            }else{\n                success(searchData);\n            }\n        }\n\n        var Ins = {\n            init:function init(){\n                loadData(function(data){\n                    render(data);\n                });\n            }\n        };\n\n        Ins.init();\n\n        // export default impush;\n\n        /***/\n    },\n    /* 1 */\n    /***/\n    function(module,exports,__webpack_require__){\n\n        /* WEBPACK VAR INJECTION */\n        (function(global){\n            'use strict';\n\n            var inViewport = __webpack_require__(3);\n            var lazyAttrs = ['data-src'];\n\n            global.lzld = lazyload();\n\n            // Provide libs using getAttribute early to get the good src\n            // and not the fake data-src\n            replaceGetAttribute('Image');\n            replaceGetAttribute('IFrame');\n\n            function registerLazyAttr(attr){\n                if(indexOf.call(lazyAttrs,attr) === -1){\n                    lazyAttrs.push(attr);\n                }\n            }\n\n            function lazyload(opts){\n                opts = merge({\n                    'offset':333,\n                    'src':'data-src',\n                    'container':false\n                },opts || {});\n\n                if(typeof opts.src === 'string'){\n                    registerLazyAttr(opts.src);\n                }\n\n                var elts = [];\n\n                function show(elt){\n                    var src = findRealSrc(elt);\n\n                    if(src){\n                        elt.src = src;\n                    }\n\n                    elt.setAttribute('data-lzled',true);\n                    elts[indexOf.call(elts,elt)] = null;\n                }\n\n                function findRealSrc(elt){\n                    if(typeof opts.src === 'function'){\n                        return opts.src(elt);\n                    }\n\n                    return elt.getAttribute(opts.src);\n                }\n\n                function register(elt){\n                    elt.onload = null;\n                    elt.removeAttribute('onload');\n                    elt.onerror = null;\n                    elt.removeAttribute('onerror');\n\n                    if(indexOf.call(elts,elt) === -1){\n                        inViewport(elt,opts,show);\n                    }\n                }\n\n                return register;\n            }\n\n            function replaceGetAttribute(elementName){\n                var fullname = 'HTML' + elementName + 'Element';\n                if(fullname in global === false){\n                    return;\n                }\n\n                var original = global[fullname].prototype.getAttribute;\n                global[fullname].prototype.getAttribute = function(name){\n                    if(name === 'src'){\n                        var realSrc;\n                        for(var i = 0,max = lazyAttrs.length; i < max; i++){\n                            realSrc = original.call(this,lazyAttrs[i]);\n                            if(realSrc){\n                                break;\n                            }\n                        }\n\n                        return realSrc || original.call(this,name);\n                    }\n\n                    // our own lazyloader will go through theses lines\n                    // because we use getAttribute(opts.src)\n                    return original.call(this,name);\n                };\n            }\n\n            function merge(defaults,opts){\n                for(var name in defaults){\n                    if(opts[name] === undefined){\n                        opts[name] = defaults[name];\n                    }\n                }\n\n                return opts;\n            }\n\n            // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html\n            function indexOf(value){\n                for(var i = this.length; i-- && this[i] !== value;){}\n                return i;\n            }\n\n            module.exports = lazyload;\n\n            // export default impush;\n            /* WEBPACK VAR INJECTION */\n        }.call(exports,(function(){\n            return this;\n        }())))\n\n        /***/\n    },\n    /* 2 */\n    /***/\n    function(module,exports){\n\n        'use strict';\n\n        var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector){\n\n            // parse slide data (url, title, size ...) from DOM elements\n            // (children of gallerySelector)\n            var parseThumbnailElements = function parseThumbnailElements(el){\n                el = el.parentNode.parentNode;\n                var thumbElements = el.getElementsByClassName('thumb'),\n                    numNodes = thumbElements.length,\n                    items = [],\n                    figureEl,\n                    linkEl,\n                    size,\n                    type,\n                    // video or not\n                    target,\n                    item;\n\n                for(var i = 0; i < numNodes; i++){\n\n                    figureEl = thumbElements[i]; //\n\n                    // include only element nodes\n                    if(figureEl.nodeType !== 1){\n                        continue;\n                    }\n\n                    linkEl = figureEl.children[0]; //\n\n                    size = linkEl.getAttribute('data-size').split('x');\n                    type = linkEl.getAttribute('data-type');\n                    target = linkEl.getAttribute('data-target');\n                    // create slide object\n                    item = {\n                        src:linkEl.getAttribute('href'),\n                        w:parseInt(size[0],10),\n                        h:parseInt(size[1],10)\n                    };\n\n                    if(figureEl.children.length > 1){\n                        item.title = figureEl.children[1].innerHTML;\n                    }\n\n                    if(linkEl.children.length > 0){\n                        item.msrc = linkEl.children[0].getAttribute('src');\n                        item.type = type;\n                        item.target = target;\n                        item.html = '<video src=\"' + target + '\" controls=\"controls\" autoplay=\"autoplay\"></video>';\n                        if(type === 'video'){\n                            //item.src = null;\n                        }\n                    }\n\n                    item.el = figureEl; // save link to element for getThumbBoundsFn\n                    items.push(item);\n                }\n\n                return items;\n            };\n\n            // find nearest parent element\n            var closest = function closest(el,fn){\n                return el && (fn(el) ? el : closest(el.parentNode,fn));\n            };\n\n            // triggers when user clicks on thumbnail\n            var onThumbnailsClick = function onThumbnailsClick(e){\n                e = e || window.event;\n                e.preventDefault ? e.preventDefault() : e.returnValue = false;\n\n                var eTarget = e.target || e.srcElement;\n\n                // find root element of slide\n                var clickedListItem = closest(eTarget,function(el){\n                    return el.tagName && el.tagName.toUpperCase() === 'FIGURE';\n                });\n\n                if(!clickedListItem){\n                    return;\n                }\n\n                // find index of clicked item by looping through all child nodes\n                // alternatively, you may define index via data- attribute\n                var clickedGallery = clickedListItem.parentNode,\n\n                    // childNodes = clickedListItem.parentNode.childNodes,\n                    // numChildNodes = childNodes.length,\n                    childNodes = document.getElementsByClassName('thumb'),\n                    numChildNodes = childNodes.length,\n                    nodeIndex = 0,\n                    index;\n\n                for(var i = 0; i < numChildNodes; i++){\n                    if(childNodes[i].nodeType !== 1){\n                        continue;\n                    }\n\n                    if(childNodes[i] === clickedListItem){\n                        index = nodeIndex;\n                        break;\n                    }\n                    nodeIndex++;\n                }\n\n                if(index >= 0){\n                    // open PhotoSwipe if valid index found\n                    openPhotoSwipe(index,clickedGallery);\n                }\n                return false;\n            };\n\n            // parse picture index and gallery index from URL (#&pid=1&gid=2)\n            var photoswipeParseHash = function photoswipeParseHash(){\n                var hash = window.location.hash.substring(1),\n                    params = {};\n\n                if(hash.length < 5){\n                    return params;\n                }\n\n                var vars = hash.split('&');\n                for(var i = 0; i < vars.length; i++){\n                    if(!vars[i]){\n                        continue;\n                    }\n                    var pair = vars[i].split('=');\n                    if(pair.length < 2){\n                        continue;\n                    }\n                    params[pair[0]] = pair[1];\n                }\n\n                if(params.gid){\n                    params.gid = parseInt(params.gid,10);\n                }\n\n                return params;\n            };\n\n            var openPhotoSwipe = function openPhotoSwipe(index,galleryElement,disableAnimation,fromURL){\n                var pswpElement = document.querySelectorAll('.pswp')[0],\n                    gallery,\n                    options,\n                    items;\n\n                items = parseThumbnailElements(galleryElement);\n                // define options (if needed)\n                options = {\n\n                    // define gallery index (for URL)\n                    galleryUID:galleryElement.getAttribute('data-pswp-uid'),\n\n                    getThumbBoundsFn:function getThumbBoundsFn(index){\n                        // See Options -> getThumbBoundsFn section of documentation for more info\n                        var thumbnail = items[index].el.getElementsByTagName('img')[0],\n                            // find thumbnail\n                            pageYScroll = window.pageYOffset || document.documentElement.scrollTop,\n                            rect = thumbnail.getBoundingClientRect();\n\n                        return {\n                            x:rect.left,\n                            y:rect.top + pageYScroll,\n                            w:rect.width\n                        };\n                    }\n\n                };\n\n                // PhotoSwipe opened from URL\n                if(fromURL){\n                    if(options.galleryPIDs){\n                        // parse real index when custom PIDs are used\n                        // http://photoswipe.com/documentation/faq.html#custom-pid-in-url\n                        for(var j = 0; j < items.length; j++){\n                            if(items[j].pid == index){\n                                options.index = j;\n                                break;\n                            }\n                        }\n                    }else{\n                        // in URL indexes start from 1\n                        options.index = parseInt(index,10) - 1;\n                    }\n                }else{\n                    options.index = parseInt(index,10);\n                }\n\n                // exit if index not found\n                if(isNaN(options.index)){\n                    return;\n                }\n\n                if(disableAnimation){\n                    options.showAnimationDuration = 0;\n                }\n\n                // Pass data to PhotoSwipe and initialize it\n                gallery = new PhotoSwipe(pswpElement,PhotoSwipeUI_Default,items,options);\n                gallery.init();\n\n                var $tempVideo;\n                var stopVideoHandle = function stopVideoHandle(){\n                    if($tempVideo){\n                        $tempVideo.remove();\n                        $tempVideo = null;\n                    }\n                };\n                var changeHandle = function changeHandle(){\n                    var item = gallery.currItem;\n                    stopVideoHandle();\n                    if(item.type === 'video'){\n                        var $ctn = item.container;\n                        var style = $ctn.getElementsByClassName('pswp__img')[0].style;\n                        var $video = document.createElement('video');\n                        $video.setAttribute('autoplay','autoplay');\n                        $video.setAttribute('controls','controls');\n                        $video.setAttribute('src',item.target);\n                        $video.style.width = style.width;\n                        $video.style.height = style.height;\n                        $video.style.position = 'absolute';\n                        $video.style.zIndex = 2;\n                        $tempVideo = $video;\n                        $ctn.appendChild($video);\n                    }\n                };\n                gallery.listen('initialZoomIn',changeHandle);\n                gallery.listen('afterChange',changeHandle);\n                gallery.listen('initialZoomOut',stopVideoHandle);\n            };\n\n            // loop through all gallery elements and bind events\n            var galleryElements = document.querySelectorAll(gallerySelector);\n            for(var i = 0,l = galleryElements.length; i < l; i++){\n                galleryElements[i].setAttribute('data-pswp-uid',i + 1);\n                galleryElements[i].onclick = onThumbnailsClick;\n            }\n\n            // Parse URL and open gallery if it contains #&pid=3&gid=1\n            var hashData = photoswipeParseHash();\n            if(hashData.pid && hashData.gid){\n                openPhotoSwipe(hashData.pid,galleryElements[hashData.gid - 1],true,true);\n            }\n        };\n\n        var Viewer = function(){\n            function init(){\n                initPhotoSwipeFromDOM('.photos');\n            }\n\n            return {\n                init:init\n            };\n        }();\n\n        module.exports = Viewer;\n\n        /***/\n    },\n    /* 3 */\n    /***/\n    function(module,exports){\n\n        /* WEBPACK VAR INJECTION */\n        (function(global){\n            module.exports = inViewport;\n\n            var instances = [];\n            var supportsMutationObserver = typeof global.MutationObserver === 'function';\n\n            function inViewport(elt,params,cb){\n                var opts = {\n                    container:global.document.body,\n                    offset:0\n                };\n\n                if(params === undefined || typeof params === 'function'){\n                    cb = params;\n                    params = {};\n                }\n\n                var container = opts.container = params.container || opts.container;\n                var offset = opts.offset = params.offset || opts.offset;\n\n                for(var i = 0; i < instances.length; i++){\n                    if(instances[i].container === container){\n                        return instances[i].isInViewport(elt,offset,cb);\n                    }\n                }\n\n                return instances[\n                instances.push(createInViewport(container)) - 1\n                    ].isInViewport(elt,offset,cb);\n            }\n\n            function addEvent(el,type,fn){\n                if(el.attachEvent){\n                    el.attachEvent('on' + type,fn);\n                }else{\n                    el.addEventListener(type,fn,false);\n                }\n            }\n\n            function debounce(func,wait,immediate){\n                var timeout;\n                return function(){\n                    var context = this,\n                        args = arguments;\n                    var callNow = immediate && !timeout;\n                    clearTimeout(timeout);\n                    timeout = setTimeout(later,wait);\n                    if(callNow) func.apply(context,args);\n\n                    function later(){\n                        timeout = null;\n                        if(!immediate) func.apply(context,args);\n                    }\n                };\n            }\n\n            // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708\n            var contains = function(){\n                if(!global.document){\n                    return true;\n                }\n                return global.document.documentElement.compareDocumentPosition ?\n                    function(a,b){\n                        return !!(a.compareDocumentPosition(b) & 16);\n                    } :\n                    global.document.documentElement.contains ?\n                        function(a,b){\n                            return a !== b && (a.contains ? a.contains(b) : false);\n                        } :\n                        function(a,b){\n                            while(b = b.parentNode){\n                                if(b === a){\n                                    return true;\n                                }\n                            }\n                            return false;\n                        };\n            }\n\n            function createInViewport(container){\n                var watches = createWatches();\n\n                var scrollContainer = container === global.document.body ? global : container;\n                var debouncedCheck = debounce(watches.checkAll(watchInViewport),15);\n\n                addEvent(scrollContainer,'scroll',debouncedCheck);\n\n                if(scrollContainer === global){\n                    addEvent(global,'resize',debouncedCheck);\n                }\n\n                if(supportsMutationObserver){\n                    observeDOM(watches,container,debouncedCheck);\n                }\n\n                // failsafe check, every 200ms we check for visible images\n                // usecase: a hidden parent containing eleements\n                // when the parent becomes visible, we have no event that the children\n                // became visible\n                setInterval(debouncedCheck,150);\n\n                function isInViewport(elt,offset,cb){\n                    if(!cb){\n                        return isVisible(elt,offset);\n                    }\n\n                    var remote = createRemote(elt,offset,cb);\n                    remote.watch();\n                    return remote;\n                }\n\n                function createRemote(elt,offset,cb){\n                    function watch(){\n                        watches.add(elt,offset,cb);\n                    }\n\n                    function dispose(){\n                        watches.remove(elt);\n                    }\n\n                    return {\n                        watch:watch,\n                        dispose:dispose\n                    };\n                }\n\n                function watchInViewport(elt,offset,cb){\n                    if(isVisible(elt,offset)){\n                        watches.remove(elt);\n                        cb(elt);\n                    }\n                }\n\n                function isVisible(elt,offset){\n                    if(!contains(global.document.documentElement,elt) || !contains(global.document.documentElement,container)){\n                        return false;\n                    }\n\n                    // Check if the element is visible\n                    // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js\n                    if(!elt.offsetWidth || !elt.offsetHeight){\n                        return false;\n                    }\n\n                    var eltRect = elt.getBoundingClientRect();\n                    var viewport = {};\n\n                    if(container === global.document.body){\n                        viewport = {\n                            top:-offset,\n                            left:-offset,\n                            right:global.document.documentElement.clientWidth + offset,\n                            bottom:global.document.documentElement.clientHeight + offset\n                        };\n                    }else{\n                        var containerRect = container.getBoundingClientRect();\n                        viewport = {\n                            top:containerRect.top - offset,\n                            left:containerRect.left - offset,\n                            right:containerRect.right + offset,\n                            bottom:containerRect.bottom + offset\n                        };\n                    }\n\n                    // The element must overlap with the visible part of the viewport\n                    var visible =\n                        (\n                            (eltRect.right > viewport.left) &&\n                            (eltRect.left < viewport.right) &&\n                            (eltRect.bottom > viewport.top) &&\n                            (eltRect.top < viewport.bottom)\n                        );\n\n                    return visible;\n                }\n\n                return {\n                    container:container,\n                    isInViewport:isInViewport\n                };\n            }\n\n            function createWatches(){\n                var watches = [];\n\n                function add(elt,offset,cb){\n                    if(!isWatched(elt)){\n                        watches.push([elt,offset,cb]);\n                    }\n                }\n\n                function remove(elt){\n                    var pos = indexOf(elt);\n                    if(pos !== -1){\n                        watches.splice(pos,1);\n                    }\n                }\n\n                function indexOf(elt){\n                    for(var i = watches.length - 1; i >= 0; i--){\n                        if(watches[i][0] === elt){\n                            return i;\n                        }\n                    }\n                    return -1;\n                }\n\n                function isWatched(elt){\n                    return indexOf(elt) !== -1;\n                }\n\n                function checkAll(cb){\n                    return function(){\n                        for(var i = watches.length - 1; i >= 0; i--){\n                            cb.apply(this,watches[i]);\n                        }\n                    };\n                }\n\n                return {\n                    add:add,\n                    remove:remove,\n                    isWatched:isWatched,\n                    checkAll:checkAll\n                };\n            }\n\n            function observeDOM(watches,container,cb){\n                var observer = new MutationObserver(watch);\n                var filter = Array.prototype.filter;\n                var concat = Array.prototype.concat;\n\n                observer.observe(container,{\n                    childList:true,\n                    subtree:true,\n                    // changes like style/width/height/display will be catched\n                    attributes:true\n                });\n\n                function watch(mutations){\n                    // some new DOM nodes where previously watched\n                    // we should check their positions\n                    if(mutations.some(knownNodes) === true){\n                        setTimeout(cb,0);\n                    }\n                }\n\n                function knownNodes(mutation){\n                    var nodes = concat.call([],\n                        Array.prototype.slice.call(mutation.addedNodes),\n                        mutation.target\n                    );\n                    return filter.call(nodes,watches.isWatched).length > 0;\n                }\n            }\n\n            /* WEBPACK VAR INJECTION */\n        }.call(exports,(function(){\n            return this;\n        }())))\n\n        /***/\n    }\n    /******/\n]);","site":{"data":{}},"excerpt":"","more":"/******/\n(function(modules){ // webpackBootstrap\n    /******/ // The module cache\n    /******/\n    var installedModules = {};\n    /******/\n    /******/ // The require function\n    /******/\n    function __webpack_require__(moduleId){\n        /******/\n        /******/ // Check if module is in cache\n        /******/\n        if(installedModules[moduleId])\n        /******/\n            return installedModules[moduleId].exports;\n        /******/\n        /******/ // Create a new module (and put it into the cache)\n        /******/\n        var module = installedModules[moduleId] = {\n            /******/\n            exports:{},\n            /******/\n            id:moduleId,\n            /******/\n            loaded:false\n            /******/\n        };\n        /******/\n        /******/ // Execute the module function\n        /******/\n        modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);\n        /******/\n        /******/ // Flag the module as loaded\n        /******/\n        module.loaded = true;\n        /******/\n        /******/ // Return the exports of the module\n        /******/\n        return module.exports;\n        /******/\n    }\n\n    /******/\n    /******/\n    /******/ // expose the modules object (__webpack_modules__)\n    /******/\n    __webpack_require__.m = modules;\n    /******/\n    /******/ // expose the module cache\n    /******/\n    __webpack_require__.c = installedModules;\n    /******/\n    /******/ // __webpack_public_path__\n    /******/\n    __webpack_require__.p = \"/dist/\";\n    /******/\n    /******/ // Load entry module and return exports\n    /******/\n    return __webpack_require__(0);\n    /******/\n})\n/************************************************************************/\n/******/\n([\n    /* 0 */\n    /***/\n    function(module,exports,__webpack_require__){\n\n        'use strict';\n\n        __webpack_require__(1);\n\n        var _view = __webpack_require__(2);\n\n        var _view2 = _interopRequireDefault(_view);\n\n        function _interopRequireDefault(obj){\n            return obj && obj.__esModule ? obj : {\n                default:obj\n            };\n        }\n\n        /**\n         * @name impush-client\n         * @description 这个项目让我发家致富…\n         * @date 2016-12-1\n         */\n\n        var _collection = [];\n        var _count = 0;\n        var searchData;\n\n        function addMask(elem){\n            var rect = elem.getBoundingClientRect();\n            var style = getComputedStyle(elem,null);\n\n            var mask = document.createElement('i');\n            mask.className = 'icon-film';\n            mask.style.color = '#fff';\n            mask.style.fontSize = '26px';\n            mask.style.position = 'absolute';\n            mask.style.right = '10px';\n            mask.style.bottom = '10px';\n            mask.style.zIndex = 1;\n            elem.parentNode.appendChild(mask);\n        }\n\n        var createVideoIncon = function createVideoIncon(){\n            var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]');\n            for(var i = 0,len = $videoImg.length; i < len; i++){\n                addMask($videoImg[i]);\n            }\n        };\n        var render = function render(res){\n            var ulTmpl = \"\";\n            for(var j = 0,len2 = res.list.length; j < len2; j++){\n                var data = res.list[j].arr;\n                var liTmpl = \"\";\n                for(var i = 0,len = data.link.length; i < len; i++){\n                    var minSrc = 'https://raw.githubusercontent.com/0000zjn/Blog-File-Back-Up/master/min_photos/' + data.link[i];\n                    var src = 'https://raw.githubusercontent.com/0000zjn/Blog-File-Back-Up/master/photos/' + data.link[i];\n                    var type = data.type[i];\n                    var target = src + (type === 'video' ? '.mp4' : '.jpg');\n                    src += '';\n\n                    liTmpl += '<figure class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\">\\\n                <a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"1080x1080\" data-type=\"' + type + '\" data-target=\"' + src + '\">\\\n                  <img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"/assets/img/empty.png\" itemprop=\"thumbnail\" onload=\"lzld(this)\">\\\n                </a>\\\n                <figcaption style=\"display:none\" itemprop=\"caption description\">' + data.text[i] + '</figcaption>\\\n            </figure>';\n                }\n                ulTmpl = ulTmpl + '<section class=\"archives album\"><h1 class=\"year\">' + data.year + '年<em>' + data.month + '月</em></h1>\\\n        <ul class=\"img-box-ul\">' + liTmpl + '</ul>\\\n        </section>';\n            }\n            document.querySelector('.instagram').innerHTML = '<div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\">' + ulTmpl + '</div>';\n            createVideoIncon();\n            _view2.default.init();\n        };\n\n        var replacer = function replacer(str){\n            var arr = str.split(\"/\");\n            return \"/assets/ins/\" + arr[arr.length - 1];\n        };\n\n        var ctrler = function ctrler(data){\n            var imgObj = {};\n            for(var i = 0,len = data.length; i < len; i++){\n                var y = data[i].y;\n                var m = data[i].m;\n                var src = replacer(data[i].src);\n                var text = data[i].text;\n                var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m);\n                if(imgObj[key]){\n                    imgObj[key].srclist.push(src);\n                    imgObj[key].text.push(text);\n                }else{\n                    imgObj[key] = {\n                        year:y,\n                        month:m,\n                        srclist:[src],\n                        text:[text]\n                    };\n                }\n            }\n            render(imgObj);\n        };\n\n        function loadData(success){\n            if(!searchData){\n                var xhr = new XMLHttpRequest();\n                xhr.open('GET','./data.json?t=' + +new Date(),true);\n\n                xhr.onload = function(){\n                    if(this.status >= 200 && this.status < 300){\n                        var res = JSON.parse(this.response);\n                        searchData = res;\n                        success(searchData);\n                    }else{\n                        console.error(this.statusText);\n                    }\n                };\n\n                xhr.onerror = function(){\n                    console.error(this.statusText);\n                };\n\n                xhr.send();\n            }else{\n                success(searchData);\n            }\n        }\n\n        var Ins = {\n            init:function init(){\n                loadData(function(data){\n                    render(data);\n                });\n            }\n        };\n\n        Ins.init();\n\n        // export default impush;\n\n        /***/\n    },\n    /* 1 */\n    /***/\n    function(module,exports,__webpack_require__){\n\n        /* WEBPACK VAR INJECTION */\n        (function(global){\n            'use strict';\n\n            var inViewport = __webpack_require__(3);\n            var lazyAttrs = ['data-src'];\n\n            global.lzld = lazyload();\n\n            // Provide libs using getAttribute early to get the good src\n            // and not the fake data-src\n            replaceGetAttribute('Image');\n            replaceGetAttribute('IFrame');\n\n            function registerLazyAttr(attr){\n                if(indexOf.call(lazyAttrs,attr) === -1){\n                    lazyAttrs.push(attr);\n                }\n            }\n\n            function lazyload(opts){\n                opts = merge({\n                    'offset':333,\n                    'src':'data-src',\n                    'container':false\n                },opts || {});\n\n                if(typeof opts.src === 'string'){\n                    registerLazyAttr(opts.src);\n                }\n\n                var elts = [];\n\n                function show(elt){\n                    var src = findRealSrc(elt);\n\n                    if(src){\n                        elt.src = src;\n                    }\n\n                    elt.setAttribute('data-lzled',true);\n                    elts[indexOf.call(elts,elt)] = null;\n                }\n\n                function findRealSrc(elt){\n                    if(typeof opts.src === 'function'){\n                        return opts.src(elt);\n                    }\n\n                    return elt.getAttribute(opts.src);\n                }\n\n                function register(elt){\n                    elt.onload = null;\n                    elt.removeAttribute('onload');\n                    elt.onerror = null;\n                    elt.removeAttribute('onerror');\n\n                    if(indexOf.call(elts,elt) === -1){\n                        inViewport(elt,opts,show);\n                    }\n                }\n\n                return register;\n            }\n\n            function replaceGetAttribute(elementName){\n                var fullname = 'HTML' + elementName + 'Element';\n                if(fullname in global === false){\n                    return;\n                }\n\n                var original = global[fullname].prototype.getAttribute;\n                global[fullname].prototype.getAttribute = function(name){\n                    if(name === 'src'){\n                        var realSrc;\n                        for(var i = 0,max = lazyAttrs.length; i < max; i++){\n                            realSrc = original.call(this,lazyAttrs[i]);\n                            if(realSrc){\n                                break;\n                            }\n                        }\n\n                        return realSrc || original.call(this,name);\n                    }\n\n                    // our own lazyloader will go through theses lines\n                    // because we use getAttribute(opts.src)\n                    return original.call(this,name);\n                };\n            }\n\n            function merge(defaults,opts){\n                for(var name in defaults){\n                    if(opts[name] === undefined){\n                        opts[name] = defaults[name];\n                    }\n                }\n\n                return opts;\n            }\n\n            // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html\n            function indexOf(value){\n                for(var i = this.length; i-- && this[i] !== value;){}\n                return i;\n            }\n\n            module.exports = lazyload;\n\n            // export default impush;\n            /* WEBPACK VAR INJECTION */\n        }.call(exports,(function(){\n            return this;\n        }())))\n\n        /***/\n    },\n    /* 2 */\n    /***/\n    function(module,exports){\n\n        'use strict';\n\n        var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector){\n\n            // parse slide data (url, title, size ...) from DOM elements\n            // (children of gallerySelector)\n            var parseThumbnailElements = function parseThumbnailElements(el){\n                el = el.parentNode.parentNode;\n                var thumbElements = el.getElementsByClassName('thumb'),\n                    numNodes = thumbElements.length,\n                    items = [],\n                    figureEl,\n                    linkEl,\n                    size,\n                    type,\n                    // video or not\n                    target,\n                    item;\n\n                for(var i = 0; i < numNodes; i++){\n\n                    figureEl = thumbElements[i]; //\n\n                    // include only element nodes\n                    if(figureEl.nodeType !== 1){\n                        continue;\n                    }\n\n                    linkEl = figureEl.children[0]; //\n\n                    size = linkEl.getAttribute('data-size').split('x');\n                    type = linkEl.getAttribute('data-type');\n                    target = linkEl.getAttribute('data-target');\n                    // create slide object\n                    item = {\n                        src:linkEl.getAttribute('href'),\n                        w:parseInt(size[0],10),\n                        h:parseInt(size[1],10)\n                    };\n\n                    if(figureEl.children.length > 1){\n                        item.title = figureEl.children[1].innerHTML;\n                    }\n\n                    if(linkEl.children.length > 0){\n                        item.msrc = linkEl.children[0].getAttribute('src');\n                        item.type = type;\n                        item.target = target;\n                        item.html = '<video src=\"' + target + '\" controls=\"controls\" autoplay=\"autoplay\"></video>';\n                        if(type === 'video'){\n                            //item.src = null;\n                        }\n                    }\n\n                    item.el = figureEl; // save link to element for getThumbBoundsFn\n                    items.push(item);\n                }\n\n                return items;\n            };\n\n            // find nearest parent element\n            var closest = function closest(el,fn){\n                return el && (fn(el) ? el : closest(el.parentNode,fn));\n            };\n\n            // triggers when user clicks on thumbnail\n            var onThumbnailsClick = function onThumbnailsClick(e){\n                e = e || window.event;\n                e.preventDefault ? e.preventDefault() : e.returnValue = false;\n\n                var eTarget = e.target || e.srcElement;\n\n                // find root element of slide\n                var clickedListItem = closest(eTarget,function(el){\n                    return el.tagName && el.tagName.toUpperCase() === 'FIGURE';\n                });\n\n                if(!clickedListItem){\n                    return;\n                }\n\n                // find index of clicked item by looping through all child nodes\n                // alternatively, you may define index via data- attribute\n                var clickedGallery = clickedListItem.parentNode,\n\n                    // childNodes = clickedListItem.parentNode.childNodes,\n                    // numChildNodes = childNodes.length,\n                    childNodes = document.getElementsByClassName('thumb'),\n                    numChildNodes = childNodes.length,\n                    nodeIndex = 0,\n                    index;\n\n                for(var i = 0; i < numChildNodes; i++){\n                    if(childNodes[i].nodeType !== 1){\n                        continue;\n                    }\n\n                    if(childNodes[i] === clickedListItem){\n                        index = nodeIndex;\n                        break;\n                    }\n                    nodeIndex++;\n                }\n\n                if(index >= 0){\n                    // open PhotoSwipe if valid index found\n                    openPhotoSwipe(index,clickedGallery);\n                }\n                return false;\n            };\n\n            // parse picture index and gallery index from URL (#&pid=1&gid=2)\n            var photoswipeParseHash = function photoswipeParseHash(){\n                var hash = window.location.hash.substring(1),\n                    params = {};\n\n                if(hash.length < 5){\n                    return params;\n                }\n\n                var vars = hash.split('&');\n                for(var i = 0; i < vars.length; i++){\n                    if(!vars[i]){\n                        continue;\n                    }\n                    var pair = vars[i].split('=');\n                    if(pair.length < 2){\n                        continue;\n                    }\n                    params[pair[0]] = pair[1];\n                }\n\n                if(params.gid){\n                    params.gid = parseInt(params.gid,10);\n                }\n\n                return params;\n            };\n\n            var openPhotoSwipe = function openPhotoSwipe(index,galleryElement,disableAnimation,fromURL){\n                var pswpElement = document.querySelectorAll('.pswp')[0],\n                    gallery,\n                    options,\n                    items;\n\n                items = parseThumbnailElements(galleryElement);\n                // define options (if needed)\n                options = {\n\n                    // define gallery index (for URL)\n                    galleryUID:galleryElement.getAttribute('data-pswp-uid'),\n\n                    getThumbBoundsFn:function getThumbBoundsFn(index){\n                        // See Options -> getThumbBoundsFn section of documentation for more info\n                        var thumbnail = items[index].el.getElementsByTagName('img')[0],\n                            // find thumbnail\n                            pageYScroll = window.pageYOffset || document.documentElement.scrollTop,\n                            rect = thumbnail.getBoundingClientRect();\n\n                        return {\n                            x:rect.left,\n                            y:rect.top + pageYScroll,\n                            w:rect.width\n                        };\n                    }\n\n                };\n\n                // PhotoSwipe opened from URL\n                if(fromURL){\n                    if(options.galleryPIDs){\n                        // parse real index when custom PIDs are used\n                        // http://photoswipe.com/documentation/faq.html#custom-pid-in-url\n                        for(var j = 0; j < items.length; j++){\n                            if(items[j].pid == index){\n                                options.index = j;\n                                break;\n                            }\n                        }\n                    }else{\n                        // in URL indexes start from 1\n                        options.index = parseInt(index,10) - 1;\n                    }\n                }else{\n                    options.index = parseInt(index,10);\n                }\n\n                // exit if index not found\n                if(isNaN(options.index)){\n                    return;\n                }\n\n                if(disableAnimation){\n                    options.showAnimationDuration = 0;\n                }\n\n                // Pass data to PhotoSwipe and initialize it\n                gallery = new PhotoSwipe(pswpElement,PhotoSwipeUI_Default,items,options);\n                gallery.init();\n\n                var $tempVideo;\n                var stopVideoHandle = function stopVideoHandle(){\n                    if($tempVideo){\n                        $tempVideo.remove();\n                        $tempVideo = null;\n                    }\n                };\n                var changeHandle = function changeHandle(){\n                    var item = gallery.currItem;\n                    stopVideoHandle();\n                    if(item.type === 'video'){\n                        var $ctn = item.container;\n                        var style = $ctn.getElementsByClassName('pswp__img')[0].style;\n                        var $video = document.createElement('video');\n                        $video.setAttribute('autoplay','autoplay');\n                        $video.setAttribute('controls','controls');\n                        $video.setAttribute('src',item.target);\n                        $video.style.width = style.width;\n                        $video.style.height = style.height;\n                        $video.style.position = 'absolute';\n                        $video.style.zIndex = 2;\n                        $tempVideo = $video;\n                        $ctn.appendChild($video);\n                    }\n                };\n                gallery.listen('initialZoomIn',changeHandle);\n                gallery.listen('afterChange',changeHandle);\n                gallery.listen('initialZoomOut',stopVideoHandle);\n            };\n\n            // loop through all gallery elements and bind events\n            var galleryElements = document.querySelectorAll(gallerySelector);\n            for(var i = 0,l = galleryElements.length; i < l; i++){\n                galleryElements[i].setAttribute('data-pswp-uid',i + 1);\n                galleryElements[i].onclick = onThumbnailsClick;\n            }\n\n            // Parse URL and open gallery if it contains #&pid=3&gid=1\n            var hashData = photoswipeParseHash();\n            if(hashData.pid && hashData.gid){\n                openPhotoSwipe(hashData.pid,galleryElements[hashData.gid - 1],true,true);\n            }\n        };\n\n        var Viewer = function(){\n            function init(){\n                initPhotoSwipeFromDOM('.photos');\n            }\n\n            return {\n                init:init\n            };\n        }();\n\n        module.exports = Viewer;\n\n        /***/\n    },\n    /* 3 */\n    /***/\n    function(module,exports){\n\n        /* WEBPACK VAR INJECTION */\n        (function(global){\n            module.exports = inViewport;\n\n            var instances = [];\n            var supportsMutationObserver = typeof global.MutationObserver === 'function';\n\n            function inViewport(elt,params,cb){\n                var opts = {\n                    container:global.document.body,\n                    offset:0\n                };\n\n                if(params === undefined || typeof params === 'function'){\n                    cb = params;\n                    params = {};\n                }\n\n                var container = opts.container = params.container || opts.container;\n                var offset = opts.offset = params.offset || opts.offset;\n\n                for(var i = 0; i < instances.length; i++){\n                    if(instances[i].container === container){\n                        return instances[i].isInViewport(elt,offset,cb);\n                    }\n                }\n\n                return instances[\n                instances.push(createInViewport(container)) - 1\n                    ].isInViewport(elt,offset,cb);\n            }\n\n            function addEvent(el,type,fn){\n                if(el.attachEvent){\n                    el.attachEvent('on' + type,fn);\n                }else{\n                    el.addEventListener(type,fn,false);\n                }\n            }\n\n            function debounce(func,wait,immediate){\n                var timeout;\n                return function(){\n                    var context = this,\n                        args = arguments;\n                    var callNow = immediate && !timeout;\n                    clearTimeout(timeout);\n                    timeout = setTimeout(later,wait);\n                    if(callNow) func.apply(context,args);\n\n                    function later(){\n                        timeout = null;\n                        if(!immediate) func.apply(context,args);\n                    }\n                };\n            }\n\n            // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708\n            var contains = function(){\n                if(!global.document){\n                    return true;\n                }\n                return global.document.documentElement.compareDocumentPosition ?\n                    function(a,b){\n                        return !!(a.compareDocumentPosition(b) & 16);\n                    } :\n                    global.document.documentElement.contains ?\n                        function(a,b){\n                            return a !== b && (a.contains ? a.contains(b) : false);\n                        } :\n                        function(a,b){\n                            while(b = b.parentNode){\n                                if(b === a){\n                                    return true;\n                                }\n                            }\n                            return false;\n                        };\n            }\n\n            function createInViewport(container){\n                var watches = createWatches();\n\n                var scrollContainer = container === global.document.body ? global : container;\n                var debouncedCheck = debounce(watches.checkAll(watchInViewport),15);\n\n                addEvent(scrollContainer,'scroll',debouncedCheck);\n\n                if(scrollContainer === global){\n                    addEvent(global,'resize',debouncedCheck);\n                }\n\n                if(supportsMutationObserver){\n                    observeDOM(watches,container,debouncedCheck);\n                }\n\n                // failsafe check, every 200ms we check for visible images\n                // usecase: a hidden parent containing eleements\n                // when the parent becomes visible, we have no event that the children\n                // became visible\n                setInterval(debouncedCheck,150);\n\n                function isInViewport(elt,offset,cb){\n                    if(!cb){\n                        return isVisible(elt,offset);\n                    }\n\n                    var remote = createRemote(elt,offset,cb);\n                    remote.watch();\n                    return remote;\n                }\n\n                function createRemote(elt,offset,cb){\n                    function watch(){\n                        watches.add(elt,offset,cb);\n                    }\n\n                    function dispose(){\n                        watches.remove(elt);\n                    }\n\n                    return {\n                        watch:watch,\n                        dispose:dispose\n                    };\n                }\n\n                function watchInViewport(elt,offset,cb){\n                    if(isVisible(elt,offset)){\n                        watches.remove(elt);\n                        cb(elt);\n                    }\n                }\n\n                function isVisible(elt,offset){\n                    if(!contains(global.document.documentElement,elt) || !contains(global.document.documentElement,container)){\n                        return false;\n                    }\n\n                    // Check if the element is visible\n                    // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js\n                    if(!elt.offsetWidth || !elt.offsetHeight){\n                        return false;\n                    }\n\n                    var eltRect = elt.getBoundingClientRect();\n                    var viewport = {};\n\n                    if(container === global.document.body){\n                        viewport = {\n                            top:-offset,\n                            left:-offset,\n                            right:global.document.documentElement.clientWidth + offset,\n                            bottom:global.document.documentElement.clientHeight + offset\n                        };\n                    }else{\n                        var containerRect = container.getBoundingClientRect();\n                        viewport = {\n                            top:containerRect.top - offset,\n                            left:containerRect.left - offset,\n                            right:containerRect.right + offset,\n                            bottom:containerRect.bottom + offset\n                        };\n                    }\n\n                    // The element must overlap with the visible part of the viewport\n                    var visible =\n                        (\n                            (eltRect.right > viewport.left) &&\n                            (eltRect.left < viewport.right) &&\n                            (eltRect.bottom > viewport.top) &&\n                            (eltRect.top < viewport.bottom)\n                        );\n\n                    return visible;\n                }\n\n                return {\n                    container:container,\n                    isInViewport:isInViewport\n                };\n            }\n\n            function createWatches(){\n                var watches = [];\n\n                function add(elt,offset,cb){\n                    if(!isWatched(elt)){\n                        watches.push([elt,offset,cb]);\n                    }\n                }\n\n                function remove(elt){\n                    var pos = indexOf(elt);\n                    if(pos !== -1){\n                        watches.splice(pos,1);\n                    }\n                }\n\n                function indexOf(elt){\n                    for(var i = watches.length - 1; i >= 0; i--){\n                        if(watches[i][0] === elt){\n                            return i;\n                        }\n                    }\n                    return -1;\n                }\n\n                function isWatched(elt){\n                    return indexOf(elt) !== -1;\n                }\n\n                function checkAll(cb){\n                    return function(){\n                        for(var i = watches.length - 1; i >= 0; i--){\n                            cb.apply(this,watches[i]);\n                        }\n                    };\n                }\n\n                return {\n                    add:add,\n                    remove:remove,\n                    isWatched:isWatched,\n                    checkAll:checkAll\n                };\n            }\n\n            function observeDOM(watches,container,cb){\n                var observer = new MutationObserver(watch);\n                var filter = Array.prototype.filter;\n                var concat = Array.prototype.concat;\n\n                observer.observe(container,{\n                    childList:true,\n                    subtree:true,\n                    // changes like style/width/height/display will be catched\n                    attributes:true\n                });\n\n                function watch(mutations){\n                    // some new DOM nodes where previously watched\n                    // we should check their positions\n                    if(mutations.some(knownNodes) === true){\n                        setTimeout(cb,0);\n                    }\n                }\n\n                function knownNodes(mutation){\n                    var nodes = concat.call([],\n                        Array.prototype.slice.call(mutation.addedNodes),\n                        mutation.target\n                    );\n                    return filter.call(nodes,watches.isWatched).length > 0;\n                }\n            }\n\n            /* WEBPACK VAR INJECTION */\n        }.call(exports,(function(){\n            return this;\n        }())))\n\n        /***/\n    }\n    /******/\n]);"}],"Post":[{"title":"CentOS下的SS/SSR/BBR配置","date":"2018-07-02T11:51:00.000Z","updated":"2019-06-04T06:21:00.000Z","_content":"> 本文为自用Shadowsocks配置的备忘教程。\n\n<!-- more -->\n\n# 1. [SS配置][1]\n## 1.1 一键安装（Python版）：\n```\nwget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\n \nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n如出现错误提示“bash: wget: command not found”。可以请在先执行`yum -y install wget`命令\n接着按照提醒输入你的密码，端口和加密方式（aes-256-cfb）。\n\n# 2. [SSR配置][2]\n## 2.1 一键部署ssr\n```\nyum -y install wget\n\nwget -N --no-check-certificate https://softs.fun/Bash/ssr.sh && chmod +x ssr.sh && bash ssr.sh\n```\n调出界面：\n```\nbash ssr.sh\n```\n# 3. BBR配置\n## 3.1 [OpenVZ 以外的，比如 KVM、Xen、VMware等][3]\n- 使用root用户登录，运行以下命令：\n```\nwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh && chmod +x bbr.sh && ./bbr.sh\n```\n---\n- 安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。\n重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：\n```\nuname -r\n```\n---\n- 查看内核版本，显示为最新版就表示 OK 了\n```\nsysctl net.ipv4.tcp_available_congestion_control\n```\n返回值一般为：\nnet.ipv4.tcp_available_congestion_control = bbr cubic reno\n或者为：\nnet.ipv4.tcp_available_congestion_control = reno cubic bbr\n\n---\n```\nsysctl net.ipv4.tcp_congestion_control\n```\n返回值一般为：\nnet.ipv4.tcp_congestion_control = bbr\n\n---\n```\nsysctl net.core.default_qdisc\n```\n返回值一般为：\nnet.core.default_qdisc = fq\n\n---\n\n```\nlsmod | grep bbr\n```\n返回值有 tcp_bbr 模块即说明 bbr 已启动。注意：并不是所有的 VPS 都会有此返回值，若没有也属正常。\n\n---\n## 3.2 [搬瓦工OpenVZ 平台 Google BBR 一键安装脚本][4]\n```\nwget https://raw.githubusercontent.com/kuoruan/shell-scripts/master/ovz-bbr/ovz-bbr-installer.sh\nchmod +x ovz-bbr-installer.sh\n./ovz-bbr-installer.sh\n```\n---\n# 4. Shadowsocks 一键安装脚本（四合一）\n- 安装：\n```\nwget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh\nchmod +x shadowsocks-all.sh\n./shadowsocks-all.sh 2>&1 | tee shadowsocks-all.log\n```\n- 安装完成后，脚本提示如下\n```\nCongratulations, your_shadowsocks_version install completed!\nYour Server IP        :your_server_ip\nYour Server Port      :your_server_port\nYour Password         :your_password\nYour Encryption Method:your_encryption_method\n\nYour QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)\n ss://your_encryption_method:your_password@your_server_ip:your_server_port\nYour QR Code has been saved as a PNG file path:\n your_path.png\n\nWelcome to visit:https://teddysun.com/486.html\nEnjoy it!\n```\n- 卸载方法\n若已安装多个版本，则卸载时也需多次运行（每次卸载一种）\n使用root用户登录，运行以下命令：\n```\n./shadowsocks-all.sh uninstall\n```\n\n- 启动脚本\n启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。\n```\nShadowsocks-Python 版：\n/etc/init.d/shadowsocks-python start | stop | restart | status\n\nShadowsocksR 版：\n/etc/init.d/shadowsocks-r start | stop | restart | status\n\nShadowsocks-Go 版：\n/etc/init.d/shadowsocks-go start | stop | restart | status\n\nShadowsocks-libev 版：\n/etc/init.d/shadowsocks-libev start | stop | restart | status\n```\n- 各版本默认配置文件\n```\nShadowsocks-Python 版：\n/etc/shadowsocks-python/config.json\n\nShadowsocksR 版：\n/etc/shadowsocks-r/config.json\n\nShadowsocks-Go 版：\n/etc/shadowsocks-go/config.json\n\nShadowsocks-libev 版：\n/etc/shadowsocks-libev/config.json\n```\n---\n# 5. simple-obfs混淆客户端设置\n下载 obfs-local.zip：\nhttps://github.com/shadowsocks/simple-obfs/releases\n下载后，解压出来的文件一定要和 Windows 客户端的 exe 文件放在同一文件夹下\n插件程序：obfs-local\n插件选项:obfs=http;obfs-host=www.bing.com  (http混淆时，网址随便写国内能访问到的)\n\n  [1]: https://blog.csdn.net/weixin_42288676/article/details/80607837\n  [2]: https://blog.csdn.net/weixin_42288676/article/details/80517662\n  [3]: https://teddysun.com/489.html\n  [4]: https://www.bawagon.com/openvz-google-bbr/\n","source":"_posts/2018/CentOS下的SS-SSR-BBR配置.md","raw":"---\ntitle: CentOS下的SS/SSR/BBR配置\ndate: 2018-07-02 19:51\nupdated: 2019-06-04 14:21\ntags: 代理\n---\n> 本文为自用Shadowsocks配置的备忘教程。\n\n<!-- more -->\n\n# 1. [SS配置][1]\n## 1.1 一键安装（Python版）：\n```\nwget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\n \nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n如出现错误提示“bash: wget: command not found”。可以请在先执行`yum -y install wget`命令\n接着按照提醒输入你的密码，端口和加密方式（aes-256-cfb）。\n\n# 2. [SSR配置][2]\n## 2.1 一键部署ssr\n```\nyum -y install wget\n\nwget -N --no-check-certificate https://softs.fun/Bash/ssr.sh && chmod +x ssr.sh && bash ssr.sh\n```\n调出界面：\n```\nbash ssr.sh\n```\n# 3. BBR配置\n## 3.1 [OpenVZ 以外的，比如 KVM、Xen、VMware等][3]\n- 使用root用户登录，运行以下命令：\n```\nwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh && chmod +x bbr.sh && ./bbr.sh\n```\n---\n- 安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。\n重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：\n```\nuname -r\n```\n---\n- 查看内核版本，显示为最新版就表示 OK 了\n```\nsysctl net.ipv4.tcp_available_congestion_control\n```\n返回值一般为：\nnet.ipv4.tcp_available_congestion_control = bbr cubic reno\n或者为：\nnet.ipv4.tcp_available_congestion_control = reno cubic bbr\n\n---\n```\nsysctl net.ipv4.tcp_congestion_control\n```\n返回值一般为：\nnet.ipv4.tcp_congestion_control = bbr\n\n---\n```\nsysctl net.core.default_qdisc\n```\n返回值一般为：\nnet.core.default_qdisc = fq\n\n---\n\n```\nlsmod | grep bbr\n```\n返回值有 tcp_bbr 模块即说明 bbr 已启动。注意：并不是所有的 VPS 都会有此返回值，若没有也属正常。\n\n---\n## 3.2 [搬瓦工OpenVZ 平台 Google BBR 一键安装脚本][4]\n```\nwget https://raw.githubusercontent.com/kuoruan/shell-scripts/master/ovz-bbr/ovz-bbr-installer.sh\nchmod +x ovz-bbr-installer.sh\n./ovz-bbr-installer.sh\n```\n---\n# 4. Shadowsocks 一键安装脚本（四合一）\n- 安装：\n```\nwget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh\nchmod +x shadowsocks-all.sh\n./shadowsocks-all.sh 2>&1 | tee shadowsocks-all.log\n```\n- 安装完成后，脚本提示如下\n```\nCongratulations, your_shadowsocks_version install completed!\nYour Server IP        :your_server_ip\nYour Server Port      :your_server_port\nYour Password         :your_password\nYour Encryption Method:your_encryption_method\n\nYour QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)\n ss://your_encryption_method:your_password@your_server_ip:your_server_port\nYour QR Code has been saved as a PNG file path:\n your_path.png\n\nWelcome to visit:https://teddysun.com/486.html\nEnjoy it!\n```\n- 卸载方法\n若已安装多个版本，则卸载时也需多次运行（每次卸载一种）\n使用root用户登录，运行以下命令：\n```\n./shadowsocks-all.sh uninstall\n```\n\n- 启动脚本\n启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。\n```\nShadowsocks-Python 版：\n/etc/init.d/shadowsocks-python start | stop | restart | status\n\nShadowsocksR 版：\n/etc/init.d/shadowsocks-r start | stop | restart | status\n\nShadowsocks-Go 版：\n/etc/init.d/shadowsocks-go start | stop | restart | status\n\nShadowsocks-libev 版：\n/etc/init.d/shadowsocks-libev start | stop | restart | status\n```\n- 各版本默认配置文件\n```\nShadowsocks-Python 版：\n/etc/shadowsocks-python/config.json\n\nShadowsocksR 版：\n/etc/shadowsocks-r/config.json\n\nShadowsocks-Go 版：\n/etc/shadowsocks-go/config.json\n\nShadowsocks-libev 版：\n/etc/shadowsocks-libev/config.json\n```\n---\n# 5. simple-obfs混淆客户端设置\n下载 obfs-local.zip：\nhttps://github.com/shadowsocks/simple-obfs/releases\n下载后，解压出来的文件一定要和 Windows 客户端的 exe 文件放在同一文件夹下\n插件程序：obfs-local\n插件选项:obfs=http;obfs-host=www.bing.com  (http混淆时，网址随便写国内能访问到的)\n\n  [1]: https://blog.csdn.net/weixin_42288676/article/details/80607837\n  [2]: https://blog.csdn.net/weixin_42288676/article/details/80517662\n  [3]: https://teddysun.com/489.html\n  [4]: https://www.bawagon.com/openvz-google-bbr/\n","slug":"2018-CentOS下的SS-SSR-BBR配置","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrjj00012ykucnyq2ozi","content":"<blockquote>\n<p>本文为自用Shadowsocks配置的备忘教程。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h1 id=\"1-SS配置\"><a href=\"#1-SS配置\" class=\"headerlink\" title=\"1. SS配置\"></a>1. <a href=\"https://blog.csdn.net/weixin_42288676/article/details/80607837\">SS配置</a></h1><h2 id=\"1-1-一键安装（Python版）：\"><a href=\"#1-1-一键安装（Python版）：\" class=\"headerlink\" title=\"1.1 一键安装（Python版）：\"></a>1.1 一键安装（Python版）：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --no-check-certificate -O shadowsocks.sh https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks.sh</span><br><span class=\"line\"> </span><br><span class=\"line\">chmod +x shadowsocks.sh</span><br><span class=\"line\">.&#x2F;shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure>\n<p>如出现错误提示“bash: wget: command not found”。可以请在先执行<code>yum -y install wget</code>命令<br>接着按照提醒输入你的密码，端口和加密方式（aes-256-cfb）。</p>\n<h1 id=\"2-SSR配置\"><a href=\"#2-SSR配置\" class=\"headerlink\" title=\"2. SSR配置\"></a>2. <a href=\"https://blog.csdn.net/weixin_42288676/article/details/80517662\">SSR配置</a></h1><h2 id=\"2-1-一键部署ssr\"><a href=\"#2-1-一键部署ssr\" class=\"headerlink\" title=\"2.1 一键部署ssr\"></a>2.1 一键部署ssr</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install wget</span><br><span class=\"line\"></span><br><span class=\"line\">wget -N --no-check-certificate https:&#x2F;&#x2F;softs.fun&#x2F;Bash&#x2F;ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure>\n<p>调出界面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash ssr.sh</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-BBR配置\"><a href=\"#3-BBR配置\" class=\"headerlink\" title=\"3. BBR配置\"></a>3. BBR配置</h1><h2 id=\"3-1-OpenVZ-以外的，比如-KVM、Xen、VMware等\"><a href=\"#3-1-OpenVZ-以外的，比如-KVM、Xen、VMware等\" class=\"headerlink\" title=\"3.1 OpenVZ 以外的，比如 KVM、Xen、VMware等\"></a>3.1 <a href=\"https://teddysun.com/489.html\">OpenVZ 以外的，比如 KVM、Xen、VMware等</a></h2><ul>\n<li>使用root用户登录，运行以下命令：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; .&#x2F;bbr.sh</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<ul>\n<li>安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。<br>重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -r</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<ul>\n<li>查看内核版本，显示为最新版就表示 OK 了<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure>\n返回值一般为：<br>net.ipv4.tcp_available_congestion_control = bbr cubic reno<br>或者为：<br>net.ipv4.tcp_available_congestion_control = reno cubic bbr</li>\n</ul>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure>\n<p>返回值一般为：<br>net.ipv4.tcp_congestion_control = bbr</p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl net.core.default_qdisc</span><br></pre></td></tr></table></figure>\n<p>返回值一般为：<br>net.core.default_qdisc = fq</p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmod | grep bbr</span><br></pre></td></tr></table></figure>\n<p>返回值有 tcp_bbr 模块即说明 bbr 已启动。注意：并不是所有的 VPS 都会有此返回值，若没有也属正常。</p>\n<hr>\n<h2 id=\"3-2-搬瓦工OpenVZ-平台-Google-BBR-一键安装脚本\"><a href=\"#3-2-搬瓦工OpenVZ-平台-Google-BBR-一键安装脚本\" class=\"headerlink\" title=\"3.2 搬瓦工OpenVZ 平台 Google BBR 一键安装脚本\"></a>3.2 <a href=\"https://www.bawagon.com/openvz-google-bbr/\">搬瓦工OpenVZ 平台 Google BBR 一键安装脚本</a></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kuoruan&#x2F;shell-scripts&#x2F;master&#x2F;ovz-bbr&#x2F;ovz-bbr-installer.sh</span><br><span class=\"line\">chmod +x ovz-bbr-installer.sh</span><br><span class=\"line\">.&#x2F;ovz-bbr-installer.sh</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"4-Shadowsocks-一键安装脚本（四合一）\"><a href=\"#4-Shadowsocks-一键安装脚本（四合一）\" class=\"headerlink\" title=\"4. Shadowsocks 一键安装脚本（四合一）\"></a>4. Shadowsocks 一键安装脚本（四合一）</h1><ul>\n<li><p>安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --no-check-certificate -O shadowsocks-all.sh https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks-all.sh</span><br><span class=\"line\">chmod +x shadowsocks-all.sh</span><br><span class=\"line\">.&#x2F;shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure></li>\n<li><p>安装完成后，脚本提示如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Congratulations, your_shadowsocks_version install completed!</span><br><span class=\"line\">Your Server IP        :your_server_ip</span><br><span class=\"line\">Your Server Port      :your_server_port</span><br><span class=\"line\">Your Password         :your_password</span><br><span class=\"line\">Your Encryption Method:your_encryption_method</span><br><span class=\"line\"></span><br><span class=\"line\">Your QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)</span><br><span class=\"line\"> ss:&#x2F;&#x2F;your_encryption_method:your_password@your_server_ip:your_server_port</span><br><span class=\"line\">Your QR Code has been saved as a PNG file path:</span><br><span class=\"line\"> your_path.png</span><br><span class=\"line\"></span><br><span class=\"line\">Welcome to visit:https:&#x2F;&#x2F;teddysun.com&#x2F;486.html</span><br><span class=\"line\">Enjoy it!</span><br></pre></td></tr></table></figure></li>\n<li><p>卸载方法<br>若已安装多个版本，则卸载时也需多次运行（每次卸载一种）<br>使用root用户登录，运行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;shadowsocks-all.sh uninstall</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动脚本<br>启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shadowsocks-Python 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks-python start | stop | restart | status</span><br><span class=\"line\"></span><br><span class=\"line\">ShadowsocksR 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks-r start | stop | restart | status</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-Go 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks-go start | stop | restart | status</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-libev 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks-libev start | stop | restart | status</span><br></pre></td></tr></table></figure></li>\n<li><p>各版本默认配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shadowsocks-Python 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;shadowsocks-python&#x2F;config.json</span><br><span class=\"line\"></span><br><span class=\"line\">ShadowsocksR 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;shadowsocks-r&#x2F;config.json</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-Go 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;shadowsocks-go&#x2F;config.json</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-libev 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;shadowsocks-libev&#x2F;config.json</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h1 id=\"5-simple-obfs混淆客户端设置\"><a href=\"#5-simple-obfs混淆客户端设置\" class=\"headerlink\" title=\"5. simple-obfs混淆客户端设置\"></a>5. simple-obfs混淆客户端设置</h1><p>下载 obfs-local.zip：<br><a href=\"https://github.com/shadowsocks/simple-obfs/releases\">https://github.com/shadowsocks/simple-obfs/releases</a><br>下载后，解压出来的文件一定要和 Windows 客户端的 exe 文件放在同一文件夹下<br>插件程序：obfs-local<br>插件选项:obfs=http;obfs-host=<a href=\"http://www.bing.com/\">www.bing.com</a>  (http混淆时，网址随便写国内能访问到的)</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文为自用Shadowsocks配置的备忘教程。</p>\n</blockquote>","more":"<h1 id=\"1-SS配置\"><a href=\"#1-SS配置\" class=\"headerlink\" title=\"1. SS配置\"></a>1. <a href=\"https://blog.csdn.net/weixin_42288676/article/details/80607837\">SS配置</a></h1><h2 id=\"1-1-一键安装（Python版）：\"><a href=\"#1-1-一键安装（Python版）：\" class=\"headerlink\" title=\"1.1 一键安装（Python版）：\"></a>1.1 一键安装（Python版）：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --no-check-certificate -O shadowsocks.sh https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks.sh</span><br><span class=\"line\"> </span><br><span class=\"line\">chmod +x shadowsocks.sh</span><br><span class=\"line\">.&#x2F;shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure>\n<p>如出现错误提示“bash: wget: command not found”。可以请在先执行<code>yum -y install wget</code>命令<br>接着按照提醒输入你的密码，端口和加密方式（aes-256-cfb）。</p>\n<h1 id=\"2-SSR配置\"><a href=\"#2-SSR配置\" class=\"headerlink\" title=\"2. SSR配置\"></a>2. <a href=\"https://blog.csdn.net/weixin_42288676/article/details/80517662\">SSR配置</a></h1><h2 id=\"2-1-一键部署ssr\"><a href=\"#2-1-一键部署ssr\" class=\"headerlink\" title=\"2.1 一键部署ssr\"></a>2.1 一键部署ssr</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install wget</span><br><span class=\"line\"></span><br><span class=\"line\">wget -N --no-check-certificate https:&#x2F;&#x2F;softs.fun&#x2F;Bash&#x2F;ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure>\n<p>调出界面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash ssr.sh</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-BBR配置\"><a href=\"#3-BBR配置\" class=\"headerlink\" title=\"3. BBR配置\"></a>3. BBR配置</h1><h2 id=\"3-1-OpenVZ-以外的，比如-KVM、Xen、VMware等\"><a href=\"#3-1-OpenVZ-以外的，比如-KVM、Xen、VMware等\" class=\"headerlink\" title=\"3.1 OpenVZ 以外的，比如 KVM、Xen、VMware等\"></a>3.1 <a href=\"https://teddysun.com/489.html\">OpenVZ 以外的，比如 KVM、Xen、VMware等</a></h2><ul>\n<li>使用root用户登录，运行以下命令：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; .&#x2F;bbr.sh</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<ul>\n<li>安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。<br>重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -r</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<ul>\n<li>查看内核版本，显示为最新版就表示 OK 了<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure>\n返回值一般为：<br>net.ipv4.tcp_available_congestion_control = bbr cubic reno<br>或者为：<br>net.ipv4.tcp_available_congestion_control = reno cubic bbr</li>\n</ul>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure>\n<p>返回值一般为：<br>net.ipv4.tcp_congestion_control = bbr</p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl net.core.default_qdisc</span><br></pre></td></tr></table></figure>\n<p>返回值一般为：<br>net.core.default_qdisc = fq</p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmod | grep bbr</span><br></pre></td></tr></table></figure>\n<p>返回值有 tcp_bbr 模块即说明 bbr 已启动。注意：并不是所有的 VPS 都会有此返回值，若没有也属正常。</p>\n<hr>\n<h2 id=\"3-2-搬瓦工OpenVZ-平台-Google-BBR-一键安装脚本\"><a href=\"#3-2-搬瓦工OpenVZ-平台-Google-BBR-一键安装脚本\" class=\"headerlink\" title=\"3.2 搬瓦工OpenVZ 平台 Google BBR 一键安装脚本\"></a>3.2 <a href=\"https://www.bawagon.com/openvz-google-bbr/\">搬瓦工OpenVZ 平台 Google BBR 一键安装脚本</a></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kuoruan&#x2F;shell-scripts&#x2F;master&#x2F;ovz-bbr&#x2F;ovz-bbr-installer.sh</span><br><span class=\"line\">chmod +x ovz-bbr-installer.sh</span><br><span class=\"line\">.&#x2F;ovz-bbr-installer.sh</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"4-Shadowsocks-一键安装脚本（四合一）\"><a href=\"#4-Shadowsocks-一键安装脚本（四合一）\" class=\"headerlink\" title=\"4. Shadowsocks 一键安装脚本（四合一）\"></a>4. Shadowsocks 一键安装脚本（四合一）</h1><ul>\n<li><p>安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --no-check-certificate -O shadowsocks-all.sh https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks-all.sh</span><br><span class=\"line\">chmod +x shadowsocks-all.sh</span><br><span class=\"line\">.&#x2F;shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure></li>\n<li><p>安装完成后，脚本提示如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Congratulations, your_shadowsocks_version install completed!</span><br><span class=\"line\">Your Server IP        :your_server_ip</span><br><span class=\"line\">Your Server Port      :your_server_port</span><br><span class=\"line\">Your Password         :your_password</span><br><span class=\"line\">Your Encryption Method:your_encryption_method</span><br><span class=\"line\"></span><br><span class=\"line\">Your QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)</span><br><span class=\"line\"> ss:&#x2F;&#x2F;your_encryption_method:your_password@your_server_ip:your_server_port</span><br><span class=\"line\">Your QR Code has been saved as a PNG file path:</span><br><span class=\"line\"> your_path.png</span><br><span class=\"line\"></span><br><span class=\"line\">Welcome to visit:https:&#x2F;&#x2F;teddysun.com&#x2F;486.html</span><br><span class=\"line\">Enjoy it!</span><br></pre></td></tr></table></figure></li>\n<li><p>卸载方法<br>若已安装多个版本，则卸载时也需多次运行（每次卸载一种）<br>使用root用户登录，运行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;shadowsocks-all.sh uninstall</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动脚本<br>启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shadowsocks-Python 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks-python start | stop | restart | status</span><br><span class=\"line\"></span><br><span class=\"line\">ShadowsocksR 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks-r start | stop | restart | status</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-Go 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks-go start | stop | restart | status</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-libev 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks-libev start | stop | restart | status</span><br></pre></td></tr></table></figure></li>\n<li><p>各版本默认配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shadowsocks-Python 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;shadowsocks-python&#x2F;config.json</span><br><span class=\"line\"></span><br><span class=\"line\">ShadowsocksR 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;shadowsocks-r&#x2F;config.json</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-Go 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;shadowsocks-go&#x2F;config.json</span><br><span class=\"line\"></span><br><span class=\"line\">Shadowsocks-libev 版：</span><br><span class=\"line\">&#x2F;etc&#x2F;shadowsocks-libev&#x2F;config.json</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h1 id=\"5-simple-obfs混淆客户端设置\"><a href=\"#5-simple-obfs混淆客户端设置\" class=\"headerlink\" title=\"5. simple-obfs混淆客户端设置\"></a>5. simple-obfs混淆客户端设置</h1><p>下载 obfs-local.zip：<br><a href=\"https://github.com/shadowsocks/simple-obfs/releases\">https://github.com/shadowsocks/simple-obfs/releases</a><br>下载后，解压出来的文件一定要和 Windows 客户端的 exe 文件放在同一文件夹下<br>插件程序：obfs-local<br>插件选项:obfs=http;obfs-host=<a href=\"http://www.bing.com/\">www.bing.com</a>  (http混淆时，网址随便写国内能访问到的)</p>"},{"title":"ES6","date":"2018-11-06T09:16:00.000Z","updated":"2019-06-04T06:18:00.000Z","_content":"# 0. 箭头函数\n\n箭头函数里指向的this是声明此函数的地方（比如window），所以涉及指向问题（如new、this等操作）需考虑用function还是箭头函数。\n\n<!-- more -->\n\n# 1. 常量：let和const\n- 暂时性死区\n    如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n\n    ```\n    var tmp = 123;\n    if (true) {\n        tmp = 'abc'; // ReferenceError\n        let tmp;\n    }\n    //上面代码中，存在全局变量tmp，但是块级作用域内\n    //let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，\n    //所以在let声明变量前，对tmp赋值会报错。\n    ```\n    总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。\n\n\n# 2. Promise\n## 2.1 常用方法\n- Promise.prototype.then()：参数A B分别为promise的resolve,reject的回调函数，参数至少填一个\n- Promise.prototype.catch()：可视为.then(null,func2)的简写\n- Promise.resolve()：快速创建一个状态为fulfilled(解决)的Promise对象，参数为.then()的参数的参数\n- Promise.reject()：快速创建一个状态为rejected(拒绝)的Promise对象，参数为回调函数的参数\n- Promise.all()：将多个Promise对象变成一个Promise对象\n- Promise.race()：和all()同样接受多个对象，不同的是，race()接受的对象中，哪个对象返回的快就返回哪个对象\n\n## 2.2 示例代码\n- then()的链式使用\n```\n//第一个异步任务\nfunction run_a(){\n    return new Promise(function(resolve, reject){\n        //假设已经进行了异步操作，并且获得了数据\n        resolve(\"step1\");\n    });\n}\n//第二个异步任务\nfunction run_b(data_a){\n    return new Promise(function(resolve, reject){\n        //假设已经进行了异步操作，并且获得了数据\n        console.log(data_a);\n        resolve(\"step2\");\n    });\n}\n//第三个异步任务\nfunction run_c(data_b){\n    return new Promise(function(resolve, reject){\n        //假设已经进行了异步操作，并且获得了数据\n        console.log(data_b);\n        resolve(\"step3\");\n    });\n}\n\n//连续调用\nrun_a().then(function(data){\n    return run_b(data);\n}).then(function(data){\n    return run_c(data);\n}).then(function(data){\n    console.log(data);\n});\n\n/*运行结果\n  step1\n  step2\n  step3\n*/\n```\n- then()和catch()\n```\n new Promise((resolve,reject) => {\n    resolve('成功了');\n    console.log('Promise过程代码');\n    reject('失败了');\n}).then(result => {\n    console.log(result,\"resovle执行\");\n}, result => {\n    console.log(result,\"reject执行\");\n})\n//结果：\"成功了 resovle执行\"\n//没有变成失败的原因：状态从pending变成fullfilled后不可变了\n```\n等效于：promise(...).then(...).catch(...)\n```\n new Promise((resolve,reject) => {\n    resolve('成功了');\n    console.log('Promise过程代码');\n    reject('失败了');\n}).then(result => {\n    console.log(result,\"resovle执行\");\n}).catch(result => {\n    console.log(result,\"reject执行\");\n})\n```\n- Promise.all()\n```\nlet p1 = Promise.resolve(123);\nlet p2 = Promise.resolve('hello');\nlet p3 = Promise.resolve('success');\n\n\nPromise.all([p1,p2,p3]).then(result => {\n    console.log(result);\n})\n//结果：[ 123, 'hello', 'success' ]\n```\n成功之后就是数组类型，当所有状态都是成功状态才返回数组，只要其中有一个的对象是reject的，就返回reject的状态值。\n```\nlet p1 = Promise.resolve(123);\nlet p2 = Promise.resolve('hello');\nlet p4 = Promise.reject('error');\n\nPromise.all([p1,p2,p4]).then(result => {\n    console.log(result);\n}).catch(result => {\n    console.log(result);\n});\n//结果：error\n```\n## 2.3 异常处理\nPormise内部的错误外界用try-catch捕捉不到，抛出的错误只能通过.catch()来捕捉，所以建议**在Promise链的尾部接一个catch**：\n```\ntry {\n    let p = new Promise((resolve, reject) => {\n        throw new Error(\"I'm error\");\n    });\n}catch(e) {\n    console.log('catch',e);//无法执行\n}\n\n\nnew Promise((resolve, reject) => {\n    throw new Error(\"I'm error\");\n}).catch(result => {\n    console.log(result);//可以打印\n});\n```\n","source":"_posts/2018/ES6.md","raw":"---\ntitle: ES6\ndate: 2018-11-06 17:16\nupdated: 2019-06-04 14:18\ntags: JS\n---\n# 0. 箭头函数\n\n箭头函数里指向的this是声明此函数的地方（比如window），所以涉及指向问题（如new、this等操作）需考虑用function还是箭头函数。\n\n<!-- more -->\n\n# 1. 常量：let和const\n- 暂时性死区\n    如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n\n    ```\n    var tmp = 123;\n    if (true) {\n        tmp = 'abc'; // ReferenceError\n        let tmp;\n    }\n    //上面代码中，存在全局变量tmp，但是块级作用域内\n    //let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，\n    //所以在let声明变量前，对tmp赋值会报错。\n    ```\n    总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。\n\n\n# 2. Promise\n## 2.1 常用方法\n- Promise.prototype.then()：参数A B分别为promise的resolve,reject的回调函数，参数至少填一个\n- Promise.prototype.catch()：可视为.then(null,func2)的简写\n- Promise.resolve()：快速创建一个状态为fulfilled(解决)的Promise对象，参数为.then()的参数的参数\n- Promise.reject()：快速创建一个状态为rejected(拒绝)的Promise对象，参数为回调函数的参数\n- Promise.all()：将多个Promise对象变成一个Promise对象\n- Promise.race()：和all()同样接受多个对象，不同的是，race()接受的对象中，哪个对象返回的快就返回哪个对象\n\n## 2.2 示例代码\n- then()的链式使用\n```\n//第一个异步任务\nfunction run_a(){\n    return new Promise(function(resolve, reject){\n        //假设已经进行了异步操作，并且获得了数据\n        resolve(\"step1\");\n    });\n}\n//第二个异步任务\nfunction run_b(data_a){\n    return new Promise(function(resolve, reject){\n        //假设已经进行了异步操作，并且获得了数据\n        console.log(data_a);\n        resolve(\"step2\");\n    });\n}\n//第三个异步任务\nfunction run_c(data_b){\n    return new Promise(function(resolve, reject){\n        //假设已经进行了异步操作，并且获得了数据\n        console.log(data_b);\n        resolve(\"step3\");\n    });\n}\n\n//连续调用\nrun_a().then(function(data){\n    return run_b(data);\n}).then(function(data){\n    return run_c(data);\n}).then(function(data){\n    console.log(data);\n});\n\n/*运行结果\n  step1\n  step2\n  step3\n*/\n```\n- then()和catch()\n```\n new Promise((resolve,reject) => {\n    resolve('成功了');\n    console.log('Promise过程代码');\n    reject('失败了');\n}).then(result => {\n    console.log(result,\"resovle执行\");\n}, result => {\n    console.log(result,\"reject执行\");\n})\n//结果：\"成功了 resovle执行\"\n//没有变成失败的原因：状态从pending变成fullfilled后不可变了\n```\n等效于：promise(...).then(...).catch(...)\n```\n new Promise((resolve,reject) => {\n    resolve('成功了');\n    console.log('Promise过程代码');\n    reject('失败了');\n}).then(result => {\n    console.log(result,\"resovle执行\");\n}).catch(result => {\n    console.log(result,\"reject执行\");\n})\n```\n- Promise.all()\n```\nlet p1 = Promise.resolve(123);\nlet p2 = Promise.resolve('hello');\nlet p3 = Promise.resolve('success');\n\n\nPromise.all([p1,p2,p3]).then(result => {\n    console.log(result);\n})\n//结果：[ 123, 'hello', 'success' ]\n```\n成功之后就是数组类型，当所有状态都是成功状态才返回数组，只要其中有一个的对象是reject的，就返回reject的状态值。\n```\nlet p1 = Promise.resolve(123);\nlet p2 = Promise.resolve('hello');\nlet p4 = Promise.reject('error');\n\nPromise.all([p1,p2,p4]).then(result => {\n    console.log(result);\n}).catch(result => {\n    console.log(result);\n});\n//结果：error\n```\n## 2.3 异常处理\nPormise内部的错误外界用try-catch捕捉不到，抛出的错误只能通过.catch()来捕捉，所以建议**在Promise链的尾部接一个catch**：\n```\ntry {\n    let p = new Promise((resolve, reject) => {\n        throw new Error(\"I'm error\");\n    });\n}catch(e) {\n    console.log('catch',e);//无法执行\n}\n\n\nnew Promise((resolve, reject) => {\n    throw new Error(\"I'm error\");\n}).catch(result => {\n    console.log(result);//可以打印\n});\n```\n","slug":"2018-ES6","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrjm00032ykuday8cep4","content":"<h1 id=\"0-箭头函数\"><a href=\"#0-箭头函数\" class=\"headerlink\" title=\"0. 箭头函数\"></a>0. 箭头函数</h1><p>箭头函数里指向的this是声明此函数的地方（比如window），所以涉及指向问题（如new、this等操作）需考虑用function还是箭头函数。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"1-常量：let和const\"><a href=\"#1-常量：let和const\" class=\"headerlink\" title=\"1. 常量：let和const\"></a>1. 常量：let和const</h1><ul>\n<li><p>暂时性死区<br>  如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tmp &#x3D; 123;</span><br><span class=\"line\">if (true) &#123;</span><br><span class=\"line\">    tmp &#x3D; &#39;abc&#39;; &#x2F;&#x2F; ReferenceError</span><br><span class=\"line\">    let tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;上面代码中，存在全局变量tmp，但是块级作用域内</span><br><span class=\"line\">&#x2F;&#x2F;let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，</span><br><span class=\"line\">&#x2F;&#x2F;所以在let声明变量前，对tmp赋值会报错。</span><br></pre></td></tr></table></figure>\n<p>  总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>\n</li>\n</ul>\n<h1 id=\"2-Promise\"><a href=\"#2-Promise\" class=\"headerlink\" title=\"2. Promise\"></a>2. Promise</h1><h2 id=\"2-1-常用方法\"><a href=\"#2-1-常用方法\" class=\"headerlink\" title=\"2.1 常用方法\"></a>2.1 常用方法</h2><ul>\n<li>Promise.prototype.then()：参数A B分别为promise的resolve,reject的回调函数，参数至少填一个</li>\n<li>Promise.prototype.catch()：可视为.then(null,func2)的简写</li>\n<li>Promise.resolve()：快速创建一个状态为fulfilled(解决)的Promise对象，参数为.then()的参数的参数</li>\n<li>Promise.reject()：快速创建一个状态为rejected(拒绝)的Promise对象，参数为回调函数的参数</li>\n<li>Promise.all()：将多个Promise对象变成一个Promise对象</li>\n<li>Promise.race()：和all()同样接受多个对象，不同的是，race()接受的对象中，哪个对象返回的快就返回哪个对象</li>\n</ul>\n<h2 id=\"2-2-示例代码\"><a href=\"#2-2-示例代码\" class=\"headerlink\" title=\"2.2 示例代码\"></a>2.2 示例代码</h2><ul>\n<li>then()的链式使用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;第一个异步任务</span><br><span class=\"line\">function run_a()&#123;</span><br><span class=\"line\">    return new Promise(function(resolve, reject)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;假设已经进行了异步操作，并且获得了数据</span><br><span class=\"line\">        resolve(&quot;step1&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;第二个异步任务</span><br><span class=\"line\">function run_b(data_a)&#123;</span><br><span class=\"line\">    return new Promise(function(resolve, reject)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;假设已经进行了异步操作，并且获得了数据</span><br><span class=\"line\">        console.log(data_a);</span><br><span class=\"line\">        resolve(&quot;step2&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;第三个异步任务</span><br><span class=\"line\">function run_c(data_b)&#123;</span><br><span class=\"line\">    return new Promise(function(resolve, reject)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;假设已经进行了异步操作，并且获得了数据</span><br><span class=\"line\">        console.log(data_b);</span><br><span class=\"line\">        resolve(&quot;step3&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;连续调用</span><br><span class=\"line\">run_a().then(function(data)&#123;</span><br><span class=\"line\">    return run_b(data);</span><br><span class=\"line\">&#125;).then(function(data)&#123;</span><br><span class=\"line\">    return run_c(data);</span><br><span class=\"line\">&#125;).then(function(data)&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*运行结果</span><br><span class=\"line\">  step1</span><br><span class=\"line\">  step2</span><br><span class=\"line\">  step3</span><br><span class=\"line\">*&#x2F;</span><br></pre></td></tr></table></figure></li>\n<li>then()和catch()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class=\"line\">    resolve(&#39;成功了&#39;);</span><br><span class=\"line\">    console.log(&#39;Promise过程代码&#39;);</span><br><span class=\"line\">    reject(&#39;失败了&#39;);</span><br><span class=\"line\">&#125;).then(result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result,&quot;resovle执行&quot;);</span><br><span class=\"line\">&#125;, result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result,&quot;reject执行&quot;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#x2F;&#x2F;结果：&quot;成功了 resovle执行&quot;</span><br><span class=\"line\">&#x2F;&#x2F;没有变成失败的原因：状态从pending变成fullfilled后不可变了</span><br></pre></td></tr></table></figure>\n等效于：promise(…).then(…).catch(…)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class=\"line\">    resolve(&#39;成功了&#39;);</span><br><span class=\"line\">    console.log(&#39;Promise过程代码&#39;);</span><br><span class=\"line\">    reject(&#39;失败了&#39;);</span><br><span class=\"line\">&#125;).then(result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result,&quot;resovle执行&quot;);</span><br><span class=\"line\">&#125;).catch(result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result,&quot;reject执行&quot;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li>Promise.all()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 &#x3D; Promise.resolve(123);</span><br><span class=\"line\">let p2 &#x3D; Promise.resolve(&#39;hello&#39;);</span><br><span class=\"line\">let p3 &#x3D; Promise.resolve(&#39;success&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1,p2,p3]).then(result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#x2F;&#x2F;结果：[ 123, &#39;hello&#39;, &#39;success&#39; ]</span><br></pre></td></tr></table></figure>\n成功之后就是数组类型，当所有状态都是成功状态才返回数组，只要其中有一个的对象是reject的，就返回reject的状态值。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 &#x3D; Promise.resolve(123);</span><br><span class=\"line\">let p2 &#x3D; Promise.resolve(&#39;hello&#39;);</span><br><span class=\"line\">let p4 &#x3D; Promise.reject(&#39;error&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1,p2,p4]).then(result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result);</span><br><span class=\"line\">&#125;).catch(result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#x2F;&#x2F;结果：error</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3-异常处理\"><a href=\"#2-3-异常处理\" class=\"headerlink\" title=\"2.3 异常处理\"></a>2.3 异常处理</h2>Pormise内部的错误外界用try-catch捕捉不到，抛出的错误只能通过.catch()来捕捉，所以建议<strong>在Promise链的尾部接一个catch</strong>：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class=\"line\">        throw new Error(&quot;I&#39;m error&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;catch(e) &#123;</span><br><span class=\"line\">    console.log(&#39;catch&#39;,e);&#x2F;&#x2F;无法执行</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class=\"line\">    throw new Error(&quot;I&#39;m error&quot;);</span><br><span class=\"line\">&#125;).catch(result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result);&#x2F;&#x2F;可以打印</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"0-箭头函数\"><a href=\"#0-箭头函数\" class=\"headerlink\" title=\"0. 箭头函数\"></a>0. 箭头函数</h1><p>箭头函数里指向的this是声明此函数的地方（比如window），所以涉及指向问题（如new、this等操作）需考虑用function还是箭头函数。</p>","more":"<h1 id=\"1-常量：let和const\"><a href=\"#1-常量：let和const\" class=\"headerlink\" title=\"1. 常量：let和const\"></a>1. 常量：let和const</h1><ul>\n<li><p>暂时性死区<br>  如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tmp &#x3D; 123;</span><br><span class=\"line\">if (true) &#123;</span><br><span class=\"line\">    tmp &#x3D; &#39;abc&#39;; &#x2F;&#x2F; ReferenceError</span><br><span class=\"line\">    let tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;上面代码中，存在全局变量tmp，但是块级作用域内</span><br><span class=\"line\">&#x2F;&#x2F;let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，</span><br><span class=\"line\">&#x2F;&#x2F;所以在let声明变量前，对tmp赋值会报错。</span><br></pre></td></tr></table></figure>\n<p>  总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>\n</li>\n</ul>\n<h1 id=\"2-Promise\"><a href=\"#2-Promise\" class=\"headerlink\" title=\"2. Promise\"></a>2. Promise</h1><h2 id=\"2-1-常用方法\"><a href=\"#2-1-常用方法\" class=\"headerlink\" title=\"2.1 常用方法\"></a>2.1 常用方法</h2><ul>\n<li>Promise.prototype.then()：参数A B分别为promise的resolve,reject的回调函数，参数至少填一个</li>\n<li>Promise.prototype.catch()：可视为.then(null,func2)的简写</li>\n<li>Promise.resolve()：快速创建一个状态为fulfilled(解决)的Promise对象，参数为.then()的参数的参数</li>\n<li>Promise.reject()：快速创建一个状态为rejected(拒绝)的Promise对象，参数为回调函数的参数</li>\n<li>Promise.all()：将多个Promise对象变成一个Promise对象</li>\n<li>Promise.race()：和all()同样接受多个对象，不同的是，race()接受的对象中，哪个对象返回的快就返回哪个对象</li>\n</ul>\n<h2 id=\"2-2-示例代码\"><a href=\"#2-2-示例代码\" class=\"headerlink\" title=\"2.2 示例代码\"></a>2.2 示例代码</h2><ul>\n<li>then()的链式使用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;第一个异步任务</span><br><span class=\"line\">function run_a()&#123;</span><br><span class=\"line\">    return new Promise(function(resolve, reject)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;假设已经进行了异步操作，并且获得了数据</span><br><span class=\"line\">        resolve(&quot;step1&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;第二个异步任务</span><br><span class=\"line\">function run_b(data_a)&#123;</span><br><span class=\"line\">    return new Promise(function(resolve, reject)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;假设已经进行了异步操作，并且获得了数据</span><br><span class=\"line\">        console.log(data_a);</span><br><span class=\"line\">        resolve(&quot;step2&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;第三个异步任务</span><br><span class=\"line\">function run_c(data_b)&#123;</span><br><span class=\"line\">    return new Promise(function(resolve, reject)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;假设已经进行了异步操作，并且获得了数据</span><br><span class=\"line\">        console.log(data_b);</span><br><span class=\"line\">        resolve(&quot;step3&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;连续调用</span><br><span class=\"line\">run_a().then(function(data)&#123;</span><br><span class=\"line\">    return run_b(data);</span><br><span class=\"line\">&#125;).then(function(data)&#123;</span><br><span class=\"line\">    return run_c(data);</span><br><span class=\"line\">&#125;).then(function(data)&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*运行结果</span><br><span class=\"line\">  step1</span><br><span class=\"line\">  step2</span><br><span class=\"line\">  step3</span><br><span class=\"line\">*&#x2F;</span><br></pre></td></tr></table></figure></li>\n<li>then()和catch()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class=\"line\">    resolve(&#39;成功了&#39;);</span><br><span class=\"line\">    console.log(&#39;Promise过程代码&#39;);</span><br><span class=\"line\">    reject(&#39;失败了&#39;);</span><br><span class=\"line\">&#125;).then(result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result,&quot;resovle执行&quot;);</span><br><span class=\"line\">&#125;, result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result,&quot;reject执行&quot;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#x2F;&#x2F;结果：&quot;成功了 resovle执行&quot;</span><br><span class=\"line\">&#x2F;&#x2F;没有变成失败的原因：状态从pending变成fullfilled后不可变了</span><br></pre></td></tr></table></figure>\n等效于：promise(…).then(…).catch(…)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class=\"line\">    resolve(&#39;成功了&#39;);</span><br><span class=\"line\">    console.log(&#39;Promise过程代码&#39;);</span><br><span class=\"line\">    reject(&#39;失败了&#39;);</span><br><span class=\"line\">&#125;).then(result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result,&quot;resovle执行&quot;);</span><br><span class=\"line\">&#125;).catch(result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result,&quot;reject执行&quot;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li>Promise.all()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 &#x3D; Promise.resolve(123);</span><br><span class=\"line\">let p2 &#x3D; Promise.resolve(&#39;hello&#39;);</span><br><span class=\"line\">let p3 &#x3D; Promise.resolve(&#39;success&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1,p2,p3]).then(result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#x2F;&#x2F;结果：[ 123, &#39;hello&#39;, &#39;success&#39; ]</span><br></pre></td></tr></table></figure>\n成功之后就是数组类型，当所有状态都是成功状态才返回数组，只要其中有一个的对象是reject的，就返回reject的状态值。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 &#x3D; Promise.resolve(123);</span><br><span class=\"line\">let p2 &#x3D; Promise.resolve(&#39;hello&#39;);</span><br><span class=\"line\">let p4 &#x3D; Promise.reject(&#39;error&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1,p2,p4]).then(result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result);</span><br><span class=\"line\">&#125;).catch(result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#x2F;&#x2F;结果：error</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3-异常处理\"><a href=\"#2-3-异常处理\" class=\"headerlink\" title=\"2.3 异常处理\"></a>2.3 异常处理</h2>Pormise内部的错误外界用try-catch捕捉不到，抛出的错误只能通过.catch()来捕捉，所以建议<strong>在Promise链的尾部接一个catch</strong>：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class=\"line\">        throw new Error(&quot;I&#39;m error&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;catch(e) &#123;</span><br><span class=\"line\">    console.log(&#39;catch&#39;,e);&#x2F;&#x2F;无法执行</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class=\"line\">    throw new Error(&quot;I&#39;m error&quot;);</span><br><span class=\"line\">&#125;).catch(result &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(result);&#x2F;&#x2F;可以打印</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"JSP基础","date":"2018-06-08T10:50:00.000Z","updated":"2018-06-08T10:50:00.000Z","_content":"> JSP这么麻烦的东西就应该圆润地进垃圾桶！\n\n<!-- more -->\n\n# 1. JSP基础语法\n## 1.1 JSP指令\n- page：页面顶端，可有多个\n- include：将外部文件嵌入当前jsp文件并解析\n- taglib：使用标签库自定义的标签\n\n## 1.2 JSP脚本、声明、表达式\n```\n<% java脚本代码%>\n<%! Java代码%>//定义方法和变量，写入到\n<%=表达式 %>//表达式不以分号结束\n```\n\n## 1.3 JSP页面生命周期\n```flow\n1=>start: 用户第一次发出请求index.jsp\n2=>condition: 是否第一次请求\n3=>operation: JSP引擎把该JSP文件转换成一个servlet，\n生成字节码文件并执行jspInit()\n4=>operation: 访问生成的字节码文件\n5=>end: 解析执行，jspService()\n\n1->2->3->5\n2(yes)->3\n2(no)->4->5\n```\njspService()方法被调用来处理客户端请求。一请求一线程。\n\n## 1.4 JSP四种范围对象的作用域\n作用域范围从小到大顺序：\npageContext--request--session--application\n \n其中：\n**pageContext：**\n作用域仅限于当前页面对象，可以近似于理解为java的this对象，离开当前JSP页面（无论是redirect还是forward），则pageContext中的所有属性值就会丢失。\n**request：**\n作用域是同一个请求之内，在页面跳转时，如果通过forward方式跳转，则forward目标页面仍然可以拿到request中的属性值。如果通过redirect方式进行页面跳转，由于redirect相当于重新发出的请求，此种场景下，request中的属性值会丢失。\n**session：**\nsession的作用域是在一个会话的生命周期内，会话失效，则session中的数据也随之丢失。\n**application：**\n作用域是最大的，只要服务器不停止，则application对象就一直存在，并且为所有会话所共享。\n\n# 2. JSP内置对象\n 1. out\n 2. request\n 3. response\n 4. session\n 5. application\n 6. Page\n 7. pageContext\n 8. exception\n 9. config\n\n## 2.1 out\n缓冲区：Buffer，用碗吃饭\nout对象：JspWriter类的实例\n常用方法：\n1. void println()向客户端打印字符串\n2. void clear()清除缓冲区内容，在flush后使用会抛出异常\n3. void clearBuffer()不抛异常\n4. void flush()结算缓冲区内容到客户端\n5. int getBufferSize()返回缓冲区字节大小，不设则为0\n6. int getRemaining()返回缓冲区剩余空间\n7. boolean isAutoFlush()返回缓冲区满时，是自动清空还是抛出异常\n8. void close()关闭输出流\n\n## 2.2 request\n- 客户端请求封装在request对象中，通过它才能了解到客户的需求，然后做出响应。\n- 它是HttpServletRequest类的实例。\n- request对象具有请求域，即完成客户端的请求之前一直有效。\n\n- request常用方法：\n    1. String getParamenter(String name) 返回name指定参数的参数值\n    2. String[] getParameterValues(String name)返回包含参数name的所有返回值\n    3. void setAttribute(String,Object) 存储此请求中的属性\n    4. object getAttribute(String name) 返回指定属性的属性值\n    5. String getContentType() 得到请求体的MIME属性\n    6. String getProtocol 返回请求用的协议类型及版本号\n    7. String getServerName() 返回接受请求的服务器主机\n    ```\n    在作用域里设置键值对<%request.setAttribute(\"pwd\",\"123456\"); %>\n    获取密码：<%=request.getAttribute(\"pwd\") %><br>\n    请求体的MIME类型：<%=request.getContentType() %><br>\n    协议类型及版本号：<%=request.getProtocol() %><br>\n    服务器主机名：<%=request.getServerName() %><br>\n    服务器端口号：<%=request.getServerPort() %><br>\n    请求文件的长度：<%=request.getContentLength() %><br>\n    请求客户端的IP地址：<%=request.getRemoteAddr() %><br>\n    <!--只能获取静态的IP地址，动态的话获取不到-->\n    请求的真实路径：<%=request.getRealPath(\"request.jsp\") %><br>\n    请求的上下文路径：<%=request.getContextPath() %><br>\n    \n    ```\n- 中文乱码问题：\n    post表单提交：request.setCharacterEncoding(\"utf-8\");\n    URL传参：修改server.xml文件\n\n","source":"_posts/2018/JSP基础.md","raw":"---\ntitle: JSP基础\ndate: 2018-06-08 18:50\nupdated: 2018-06-08 18:50\ntags: JAVA\n---\n> JSP这么麻烦的东西就应该圆润地进垃圾桶！\n\n<!-- more -->\n\n# 1. JSP基础语法\n## 1.1 JSP指令\n- page：页面顶端，可有多个\n- include：将外部文件嵌入当前jsp文件并解析\n- taglib：使用标签库自定义的标签\n\n## 1.2 JSP脚本、声明、表达式\n```\n<% java脚本代码%>\n<%! Java代码%>//定义方法和变量，写入到\n<%=表达式 %>//表达式不以分号结束\n```\n\n## 1.3 JSP页面生命周期\n```flow\n1=>start: 用户第一次发出请求index.jsp\n2=>condition: 是否第一次请求\n3=>operation: JSP引擎把该JSP文件转换成一个servlet，\n生成字节码文件并执行jspInit()\n4=>operation: 访问生成的字节码文件\n5=>end: 解析执行，jspService()\n\n1->2->3->5\n2(yes)->3\n2(no)->4->5\n```\njspService()方法被调用来处理客户端请求。一请求一线程。\n\n## 1.4 JSP四种范围对象的作用域\n作用域范围从小到大顺序：\npageContext--request--session--application\n \n其中：\n**pageContext：**\n作用域仅限于当前页面对象，可以近似于理解为java的this对象，离开当前JSP页面（无论是redirect还是forward），则pageContext中的所有属性值就会丢失。\n**request：**\n作用域是同一个请求之内，在页面跳转时，如果通过forward方式跳转，则forward目标页面仍然可以拿到request中的属性值。如果通过redirect方式进行页面跳转，由于redirect相当于重新发出的请求，此种场景下，request中的属性值会丢失。\n**session：**\nsession的作用域是在一个会话的生命周期内，会话失效，则session中的数据也随之丢失。\n**application：**\n作用域是最大的，只要服务器不停止，则application对象就一直存在，并且为所有会话所共享。\n\n# 2. JSP内置对象\n 1. out\n 2. request\n 3. response\n 4. session\n 5. application\n 6. Page\n 7. pageContext\n 8. exception\n 9. config\n\n## 2.1 out\n缓冲区：Buffer，用碗吃饭\nout对象：JspWriter类的实例\n常用方法：\n1. void println()向客户端打印字符串\n2. void clear()清除缓冲区内容，在flush后使用会抛出异常\n3. void clearBuffer()不抛异常\n4. void flush()结算缓冲区内容到客户端\n5. int getBufferSize()返回缓冲区字节大小，不设则为0\n6. int getRemaining()返回缓冲区剩余空间\n7. boolean isAutoFlush()返回缓冲区满时，是自动清空还是抛出异常\n8. void close()关闭输出流\n\n## 2.2 request\n- 客户端请求封装在request对象中，通过它才能了解到客户的需求，然后做出响应。\n- 它是HttpServletRequest类的实例。\n- request对象具有请求域，即完成客户端的请求之前一直有效。\n\n- request常用方法：\n    1. String getParamenter(String name) 返回name指定参数的参数值\n    2. String[] getParameterValues(String name)返回包含参数name的所有返回值\n    3. void setAttribute(String,Object) 存储此请求中的属性\n    4. object getAttribute(String name) 返回指定属性的属性值\n    5. String getContentType() 得到请求体的MIME属性\n    6. String getProtocol 返回请求用的协议类型及版本号\n    7. String getServerName() 返回接受请求的服务器主机\n    ```\n    在作用域里设置键值对<%request.setAttribute(\"pwd\",\"123456\"); %>\n    获取密码：<%=request.getAttribute(\"pwd\") %><br>\n    请求体的MIME类型：<%=request.getContentType() %><br>\n    协议类型及版本号：<%=request.getProtocol() %><br>\n    服务器主机名：<%=request.getServerName() %><br>\n    服务器端口号：<%=request.getServerPort() %><br>\n    请求文件的长度：<%=request.getContentLength() %><br>\n    请求客户端的IP地址：<%=request.getRemoteAddr() %><br>\n    <!--只能获取静态的IP地址，动态的话获取不到-->\n    请求的真实路径：<%=request.getRealPath(\"request.jsp\") %><br>\n    请求的上下文路径：<%=request.getContextPath() %><br>\n    \n    ```\n- 中文乱码问题：\n    post表单提交：request.setCharacterEncoding(\"utf-8\");\n    URL传参：修改server.xml文件\n\n","slug":"2018-JSP基础","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrjs00062ykud8kkhofc","content":"<blockquote>\n<p>JSP这么麻烦的东西就应该圆润地进垃圾桶！</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h1 id=\"1-JSP基础语法\"><a href=\"#1-JSP基础语法\" class=\"headerlink\" title=\"1. JSP基础语法\"></a>1. JSP基础语法</h1><h2 id=\"1-1-JSP指令\"><a href=\"#1-1-JSP指令\" class=\"headerlink\" title=\"1.1 JSP指令\"></a>1.1 JSP指令</h2><ul>\n<li>page：页面顶端，可有多个</li>\n<li>include：将外部文件嵌入当前jsp文件并解析</li>\n<li>taglib：使用标签库自定义的标签</li>\n</ul>\n<h2 id=\"1-2-JSP脚本、声明、表达式\"><a href=\"#1-2-JSP脚本、声明、表达式\" class=\"headerlink\" title=\"1.2 JSP脚本、声明、表达式\"></a>1.2 JSP脚本、声明、表达式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% java脚本代码%&gt;</span><br><span class=\"line\">&lt;%! Java代码%&gt;&#x2F;&#x2F;定义方法和变量，写入到</span><br><span class=\"line\">&lt;%&#x3D;表达式 %&gt;&#x2F;&#x2F;表达式不以分号结束</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-JSP页面生命周期\"><a href=\"#1-3-JSP页面生命周期\" class=\"headerlink\" title=\"1.3 JSP页面生命周期\"></a>1.3 JSP页面生命周期</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&#x3D;&gt;start: 用户第一次发出请求index.jsp</span><br><span class=\"line\">2&#x3D;&gt;condition: 是否第一次请求</span><br><span class=\"line\">3&#x3D;&gt;operation: JSP引擎把该JSP文件转换成一个servlet，</span><br><span class=\"line\">生成字节码文件并执行jspInit()</span><br><span class=\"line\">4&#x3D;&gt;operation: 访问生成的字节码文件</span><br><span class=\"line\">5&#x3D;&gt;end: 解析执行，jspService()</span><br><span class=\"line\"></span><br><span class=\"line\">1-&gt;2-&gt;3-&gt;5</span><br><span class=\"line\">2(yes)-&gt;3</span><br><span class=\"line\">2(no)-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>\n<p>jspService()方法被调用来处理客户端请求。一请求一线程。</p>\n<h2 id=\"1-4-JSP四种范围对象的作用域\"><a href=\"#1-4-JSP四种范围对象的作用域\" class=\"headerlink\" title=\"1.4 JSP四种范围对象的作用域\"></a>1.4 JSP四种范围对象的作用域</h2><p>作用域范围从小到大顺序：<br>pageContext–request–session–application</p>\n<p>其中：<br><strong>pageContext：</strong><br>作用域仅限于当前页面对象，可以近似于理解为java的this对象，离开当前JSP页面（无论是redirect还是forward），则pageContext中的所有属性值就会丢失。<br><strong>request：</strong><br>作用域是同一个请求之内，在页面跳转时，如果通过forward方式跳转，则forward目标页面仍然可以拿到request中的属性值。如果通过redirect方式进行页面跳转，由于redirect相当于重新发出的请求，此种场景下，request中的属性值会丢失。<br><strong>session：</strong><br>session的作用域是在一个会话的生命周期内，会话失效，则session中的数据也随之丢失。<br><strong>application：</strong><br>作用域是最大的，只要服务器不停止，则application对象就一直存在，并且为所有会话所共享。</p>\n<h1 id=\"2-JSP内置对象\"><a href=\"#2-JSP内置对象\" class=\"headerlink\" title=\"2. JSP内置对象\"></a>2. JSP内置对象</h1><ol>\n<li>out</li>\n<li>request</li>\n<li>response</li>\n<li>session</li>\n<li>application</li>\n<li>Page</li>\n<li>pageContext</li>\n<li>exception</li>\n<li>config</li>\n</ol>\n<h2 id=\"2-1-out\"><a href=\"#2-1-out\" class=\"headerlink\" title=\"2.1 out\"></a>2.1 out</h2><p>缓冲区：Buffer，用碗吃饭<br>out对象：JspWriter类的实例<br>常用方法：</p>\n<ol>\n<li>void println()向客户端打印字符串</li>\n<li>void clear()清除缓冲区内容，在flush后使用会抛出异常</li>\n<li>void clearBuffer()不抛异常</li>\n<li>void flush()结算缓冲区内容到客户端</li>\n<li>int getBufferSize()返回缓冲区字节大小，不设则为0</li>\n<li>int getRemaining()返回缓冲区剩余空间</li>\n<li>boolean isAutoFlush()返回缓冲区满时，是自动清空还是抛出异常</li>\n<li>void close()关闭输出流</li>\n</ol>\n<h2 id=\"2-2-request\"><a href=\"#2-2-request\" class=\"headerlink\" title=\"2.2 request\"></a>2.2 request</h2><ul>\n<li><p>客户端请求封装在request对象中，通过它才能了解到客户的需求，然后做出响应。</p>\n</li>\n<li><p>它是HttpServletRequest类的实例。</p>\n</li>\n<li><p>request对象具有请求域，即完成客户端的请求之前一直有效。</p>\n</li>\n<li><p>request常用方法：</p>\n<ol>\n<li>String getParamenter(String name) 返回name指定参数的参数值</li>\n<li>String[] getParameterValues(String name)返回包含参数name的所有返回值</li>\n<li>void setAttribute(String,Object) 存储此请求中的属性</li>\n<li>object getAttribute(String name) 返回指定属性的属性值</li>\n<li>String getContentType() 得到请求体的MIME属性</li>\n<li>String getProtocol 返回请求用的协议类型及版本号</li>\n<li>String getServerName() 返回接受请求的服务器主机<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在作用域里设置键值对&lt;%request.setAttribute(&quot;pwd&quot;,&quot;123456&quot;); %&gt;</span><br><span class=\"line\">获取密码：&lt;%&#x3D;request.getAttribute(&quot;pwd&quot;) %&gt;&lt;br&gt;</span><br><span class=\"line\">请求体的MIME类型：&lt;%&#x3D;request.getContentType() %&gt;&lt;br&gt;</span><br><span class=\"line\">协议类型及版本号：&lt;%&#x3D;request.getProtocol() %&gt;&lt;br&gt;</span><br><span class=\"line\">服务器主机名：&lt;%&#x3D;request.getServerName() %&gt;&lt;br&gt;</span><br><span class=\"line\">服务器端口号：&lt;%&#x3D;request.getServerPort() %&gt;&lt;br&gt;</span><br><span class=\"line\">请求文件的长度：&lt;%&#x3D;request.getContentLength() %&gt;&lt;br&gt;</span><br><span class=\"line\">请求客户端的IP地址：&lt;%&#x3D;request.getRemoteAddr() %&gt;&lt;br&gt;</span><br><span class=\"line\">&lt;!--只能获取静态的IP地址，动态的话获取不到--&gt;</span><br><span class=\"line\">请求的真实路径：&lt;%&#x3D;request.getRealPath(&quot;request.jsp&quot;) %&gt;&lt;br&gt;</span><br><span class=\"line\">请求的上下文路径：&lt;%&#x3D;request.getContextPath() %&gt;&lt;br&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>中文乱码问题：<br>  post表单提交：request.setCharacterEncoding(“utf-8”);<br>  URL传参：修改server.xml文件</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>JSP这么麻烦的东西就应该圆润地进垃圾桶！</p>\n</blockquote>","more":"<h1 id=\"1-JSP基础语法\"><a href=\"#1-JSP基础语法\" class=\"headerlink\" title=\"1. JSP基础语法\"></a>1. JSP基础语法</h1><h2 id=\"1-1-JSP指令\"><a href=\"#1-1-JSP指令\" class=\"headerlink\" title=\"1.1 JSP指令\"></a>1.1 JSP指令</h2><ul>\n<li>page：页面顶端，可有多个</li>\n<li>include：将外部文件嵌入当前jsp文件并解析</li>\n<li>taglib：使用标签库自定义的标签</li>\n</ul>\n<h2 id=\"1-2-JSP脚本、声明、表达式\"><a href=\"#1-2-JSP脚本、声明、表达式\" class=\"headerlink\" title=\"1.2 JSP脚本、声明、表达式\"></a>1.2 JSP脚本、声明、表达式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% java脚本代码%&gt;</span><br><span class=\"line\">&lt;%! Java代码%&gt;&#x2F;&#x2F;定义方法和变量，写入到</span><br><span class=\"line\">&lt;%&#x3D;表达式 %&gt;&#x2F;&#x2F;表达式不以分号结束</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-JSP页面生命周期\"><a href=\"#1-3-JSP页面生命周期\" class=\"headerlink\" title=\"1.3 JSP页面生命周期\"></a>1.3 JSP页面生命周期</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&#x3D;&gt;start: 用户第一次发出请求index.jsp</span><br><span class=\"line\">2&#x3D;&gt;condition: 是否第一次请求</span><br><span class=\"line\">3&#x3D;&gt;operation: JSP引擎把该JSP文件转换成一个servlet，</span><br><span class=\"line\">生成字节码文件并执行jspInit()</span><br><span class=\"line\">4&#x3D;&gt;operation: 访问生成的字节码文件</span><br><span class=\"line\">5&#x3D;&gt;end: 解析执行，jspService()</span><br><span class=\"line\"></span><br><span class=\"line\">1-&gt;2-&gt;3-&gt;5</span><br><span class=\"line\">2(yes)-&gt;3</span><br><span class=\"line\">2(no)-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>\n<p>jspService()方法被调用来处理客户端请求。一请求一线程。</p>\n<h2 id=\"1-4-JSP四种范围对象的作用域\"><a href=\"#1-4-JSP四种范围对象的作用域\" class=\"headerlink\" title=\"1.4 JSP四种范围对象的作用域\"></a>1.4 JSP四种范围对象的作用域</h2><p>作用域范围从小到大顺序：<br>pageContext–request–session–application</p>\n<p>其中：<br><strong>pageContext：</strong><br>作用域仅限于当前页面对象，可以近似于理解为java的this对象，离开当前JSP页面（无论是redirect还是forward），则pageContext中的所有属性值就会丢失。<br><strong>request：</strong><br>作用域是同一个请求之内，在页面跳转时，如果通过forward方式跳转，则forward目标页面仍然可以拿到request中的属性值。如果通过redirect方式进行页面跳转，由于redirect相当于重新发出的请求，此种场景下，request中的属性值会丢失。<br><strong>session：</strong><br>session的作用域是在一个会话的生命周期内，会话失效，则session中的数据也随之丢失。<br><strong>application：</strong><br>作用域是最大的，只要服务器不停止，则application对象就一直存在，并且为所有会话所共享。</p>\n<h1 id=\"2-JSP内置对象\"><a href=\"#2-JSP内置对象\" class=\"headerlink\" title=\"2. JSP内置对象\"></a>2. JSP内置对象</h1><ol>\n<li>out</li>\n<li>request</li>\n<li>response</li>\n<li>session</li>\n<li>application</li>\n<li>Page</li>\n<li>pageContext</li>\n<li>exception</li>\n<li>config</li>\n</ol>\n<h2 id=\"2-1-out\"><a href=\"#2-1-out\" class=\"headerlink\" title=\"2.1 out\"></a>2.1 out</h2><p>缓冲区：Buffer，用碗吃饭<br>out对象：JspWriter类的实例<br>常用方法：</p>\n<ol>\n<li>void println()向客户端打印字符串</li>\n<li>void clear()清除缓冲区内容，在flush后使用会抛出异常</li>\n<li>void clearBuffer()不抛异常</li>\n<li>void flush()结算缓冲区内容到客户端</li>\n<li>int getBufferSize()返回缓冲区字节大小，不设则为0</li>\n<li>int getRemaining()返回缓冲区剩余空间</li>\n<li>boolean isAutoFlush()返回缓冲区满时，是自动清空还是抛出异常</li>\n<li>void close()关闭输出流</li>\n</ol>\n<h2 id=\"2-2-request\"><a href=\"#2-2-request\" class=\"headerlink\" title=\"2.2 request\"></a>2.2 request</h2><ul>\n<li><p>客户端请求封装在request对象中，通过它才能了解到客户的需求，然后做出响应。</p>\n</li>\n<li><p>它是HttpServletRequest类的实例。</p>\n</li>\n<li><p>request对象具有请求域，即完成客户端的请求之前一直有效。</p>\n</li>\n<li><p>request常用方法：</p>\n<ol>\n<li>String getParamenter(String name) 返回name指定参数的参数值</li>\n<li>String[] getParameterValues(String name)返回包含参数name的所有返回值</li>\n<li>void setAttribute(String,Object) 存储此请求中的属性</li>\n<li>object getAttribute(String name) 返回指定属性的属性值</li>\n<li>String getContentType() 得到请求体的MIME属性</li>\n<li>String getProtocol 返回请求用的协议类型及版本号</li>\n<li>String getServerName() 返回接受请求的服务器主机<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在作用域里设置键值对&lt;%request.setAttribute(&quot;pwd&quot;,&quot;123456&quot;); %&gt;</span><br><span class=\"line\">获取密码：&lt;%&#x3D;request.getAttribute(&quot;pwd&quot;) %&gt;&lt;br&gt;</span><br><span class=\"line\">请求体的MIME类型：&lt;%&#x3D;request.getContentType() %&gt;&lt;br&gt;</span><br><span class=\"line\">协议类型及版本号：&lt;%&#x3D;request.getProtocol() %&gt;&lt;br&gt;</span><br><span class=\"line\">服务器主机名：&lt;%&#x3D;request.getServerName() %&gt;&lt;br&gt;</span><br><span class=\"line\">服务器端口号：&lt;%&#x3D;request.getServerPort() %&gt;&lt;br&gt;</span><br><span class=\"line\">请求文件的长度：&lt;%&#x3D;request.getContentLength() %&gt;&lt;br&gt;</span><br><span class=\"line\">请求客户端的IP地址：&lt;%&#x3D;request.getRemoteAddr() %&gt;&lt;br&gt;</span><br><span class=\"line\">&lt;!--只能获取静态的IP地址，动态的话获取不到--&gt;</span><br><span class=\"line\">请求的真实路径：&lt;%&#x3D;request.getRealPath(&quot;request.jsp&quot;) %&gt;&lt;br&gt;</span><br><span class=\"line\">请求的上下文路径：&lt;%&#x3D;request.getContextPath() %&gt;&lt;br&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>中文乱码问题：<br>  post表单提交：request.setCharacterEncoding(“utf-8”);<br>  URL传参：修改server.xml文件</p>\n</li>\n</ul>"},{"title":"JavaScript基础","date":"2018-07-13T06:48:00.000Z","updated":"2018-07-13T06:48:00.000Z","_content":"> 重学JavaScript时做的笔记。JS的语法真的是让人又爱又恨~\n# 1. Sundry\n- switch()参数可为多种类型\n- 标签：\n    ```\n    outerloop:\n    for (var i = 0; i < 10; i++)\n    {\n        innerloop:\n        for (var j = 0; j < 10; j++)\n        {\n            if (j > 3)\n            {\n                break;\n            }\n            if (i == 2)\n            {\n                break innerloop;//跳过了i=2的情况\n            }\n            if (i == 4)\n            {\n                break outerloop;//i=4时结束\n            }\n            document.write(\"i=\" + i + \" j=\" + j + \"\");\n        }\n    }\n    ```\n\n<!-- more -->\n\n- constructor 属性返回变量的构造函数的原型\n    ```\n    (3.14).constructor//返回ƒ String() { [native code] }\n    \n    function isArray(myArray) {\n        return myArray.constructor.toString().indexOf(\"Array\") > -1;\n    }\n    ```\n- 严格模式：`\"use strict\";`\n- Operator + 可用于将变量转换为数字：\n    ```\n    var y = \"5\";      // y 是一个字符串\n    var x = + y;      // x 是一个数字\n    ```\n    \n- Form提交前验证：\n    ```\n    <form onsubmit=\"return validate()\">\n    //validate方法返回false则不提交\n    ```\n    \n- 变量声明时如果不使用var关键字，那么它就是一个全局变量，即便它在函数内定义。\n- eval('str')\n    解析器解析str代码，功能上类似于Function\n\n- 变量、函数提升机制：\n    ```\n    var c = 2;\n    function c(){\n　　    console.log(1);\n    }\n    c();\n    //报错，c未定义。\n    //var c 和函数c被提升，c=2是表达式，后执行。\n    //所以c()时，c不再是一个函数。\n    ```\n\n# 2. 正则\n- `var patt=/pattern/modifiers;`\n- pattern（模式） 以^开头，$结尾\n\n- test() 方法用于检测一个字符串是否匹配某个模式\n    ```\n    /e/.test(\"The best things in life are free!\");\n    >> true\n    ```\n    \n- exec() 方法用于检索字符串中的正则表达式的匹配(返回第一个匹配值)\n    ```\n    /e[1-9]/.exec(\"The be1st things in life are fre2e!\");\n    >>e1\n    ```\n    \n\n# 3. 错误\n- try-catch：\n    ```\n    try { \n        adddlert(\"Welcome guest!\"); \n    } catch(err) { \n        txt+=\"错误描述：\" + err.message; \n        alert(txt); \n    } \n    ```\n \n- throw：err即throw\n    ```\n    try { \n        if(x == \"\")  throw \"值为空\";\n    }\n    catch(err) {\n        message.innerHTML = \"错误: \" + err;\n    }       \n    ```\n\n# 4. JSON\n- 将一个 JSON 字符串转换为 JavaScript 对象(使可操作)\n    ```\n    var text = '{ \"sites\" : [' +\n        '{ \"name\":\"Runoob\" , \"url\":\"www.runoob.com\" },' +\n        '{ \"name\":\"Google\" , \"url\":\"www.google.com\" },' +\n        '{ \"name\":\"Taobao\" , \"url\":\"www.taobao.com\" } ]}';\n    \n    obj = JSON.parse(text);\n    document.getElementById(\"demo\").innerHTML = obj.sites[1].name + \" \" + obj.sites[1].url;\n    ```\n- 将 JavaScript 值转换为 JSON 字符串(单行)\n> JSON.stringify(value[, replacer[, space]]);\n\n\n# 5. 函数\n- 显式参数(Parameters)就是形参，隐式参数(Arguments)：实参\n- 实例对象、类对象、局部变量(局部函数)\n    ```\n    function Person(national,age)\n    {\n        this.age = age;  //实例对象，每个示例不同\n        Person.national = national;  //类对象,所用实例公用\n        var bb = 0; //局部变量，外面不能访问（类似局部函数）\n    }\n    ```\n\n- 创建新方法\n    ```\n    //原型属性、方法，此方法可被所有String对象使用\n    String.prototype.funcName=function(){}\n    //以字面量方法创建\n    String.prototype = {\n        constructor:String;\n        //如果不写，新对象的构造器会重写String的构造器即Object(花括号)\n        name:\"zs\";\n        id:1\n    }\n    //实例属性、方法（实例通过.__proto__访问）\n    str.funcName=function(){}\n    ```\n\n- 函数自动调用(只会执行一次)：\n    ```\n    <p id=\"demo\"></p>\n    <script>\n    (function(){\n        document.getElementById(\"demo\").innerHTML = \"Hello! 我是自己调用的\";\n    })();\n    </script>\n    ```\n\n- 用构造函数调用函数\n    ```\n    // 构造函数:\n    function myFunction(arg1, arg2){\n        this.firstName = arg1;\n        this.lastName = arg2;//如果直接当方法调用，this指window对象\n        this.fullName = function(){\n            return this.firstName + \" \" + this.lastName;\n        }\n    }\n    var x = new myFunction(\"John\",\"Doe\");\n    console.log(x.fullName());          // \"John Doe\"\n    console.log(x.firstName);           // 返回 \"John\"\n    ```\n\n- 用函数方法调用函数（call() 和 apply()）（对象冒充），this指一参\n    ```\n    function myFunction(a, b) {\n        return a * b;\n    }\n    myObject = myFunction.call(myObject, 10, 2);     // 返回 20\n    //或\n    myArray = [10, 2];\n    myObject = myFunction.apply(myObject, myArray);  // 二参为参数数组\n    ```\n \n- 闭包（closure）：\n    - 就是能够读取其他函数内部变量的函数，在JS中，只有子函数可以访问父函数的内部变量。\n    - 即：闭包是可访问上一层函数作用域里变量的函数，即便上一层函数已经关闭。\n    + 所以只要把子函数作为返回值，我们就可以在父函数外部读取它的私有变量且该变量不会随父函数结束而回收。\n    + 实例：\n        ```\n        var add = (function () {\n            var counter = 0;\n            return function () {return counter += 1;}\n        })();\n        //自我调用使函数只执行一次，设置私有计数器为0。并返回函数表达式。\n        add();\n        add();\n        add();\n        //计数器为 3\n        ```\n        \n    - 优点（应用场景）\n        - 希望一个变量长期驻扎在内存当中；\n        - 避免全局变量的污染；\n        - 私有成员的存在\n- arguments 对象\n    在函数代码中，使用特殊对象arguments，开发者无需明确指出参数名，就能访问它们。\n    ```\n    function sayHi() {\n        if (arguments[0] == \"bye\") {\n            return;\n        }\n        alert(arguments[0]);\n    }\n    ```\n    \n    还可以用 arguments 对象检测函数的参数个数:`arguments.length`\n    因为ECMAScript不会验证传递给函数的参数个数是否等于函数定义的参数个数，所以用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载。\n\n- Function 对象（类）\n    **函数实际上是功能完整的对象。**\n    **所有函数都应看作 Function 类的实例**\n    所以Function 类可以表示开发者定义的任何函数，类似于java的反射。\n    ```\n    //下面这个函数\n\n    function sayHi(sName, sMessage) {\n      alert(\"Hello \" + sName + sMessage);\n    }\n    //还可以这样定义它：\n    \n    var sayHi = new Function(\"sName\", \"sMessage\", \"alert(\\\"Hello \\\" + sName + sMessage);\");\n    ```\n\n# 6. DOM\n1. 获取元素\n    ```\n    var x=document.getElementById(\"intro\");\n    var y=document.getElementsByTagName(\"p\");//返回DOM集合非数组\n    var x=document.getElementsByClassName(\"intro\");\n    document.querySelector(\"p.example\");//获取文档中class=\"example\"的第一个<p>元素\n    querySelectorAll();//返回所有的元素\n    ```\n\n2. 改变 HTML 内容\n    ```\n    document.getElementById(\"p1\").innerHTML=\"新文本!\";\n    document.getElementById(\"p1\").outerHTML=\"<p id='p2'>新文本!</p>\";\n    ```\n\n3. 改变 HTML 属性\n    ```\n    document.getElementById(\"image\").src=\"landscape.jpg\";\n    ```\n\n4. 改变CSS\n    ```\n    document.getElementById(\"p2\").style.color=\"blue\";\n    ```\n5. [HTML DOM事件][1]\n    - onclick\n    - onload 和 onunload（进入或离开页面）（处理cookie）\n    - onchange（对输入字段的验证）\n    - onmouseover 和 onmouseout\n    - onmousedown、onmouseup 以及 onclick\n    - onfocus（输入框获得焦点）\n6. EventListener\n    - addEventListener() 方法\n        ```\n        element.addEventListener(event, function, useCapture);\n        element.addEventListener(\"click\", function(){alert(\"1\");});\n        element.addEventListener(\"click\", function(){myFunction(p1, p2);});\n        ```\n        \n        第一个参数是事件的类型 (如\"click\",无\"on\")。\n        第二个参数是事件触发后调用的函数名（无括号）/匿名函数体。\n        第三个参数true:事件捕获；false:事件冒泡。默认false。可选。\n        可向同一个元素中添加多个事件句柄。\n        用\"匿名函数\"调用带参数的函数。\n    - 事件冒泡或事件捕获\n        在'冒泡'中，内部元素的事件先触发，再触发外部元素事件\n        在'捕获'中，外部元素的事件先触发，再触发内部元素事件\n    - 移除由 addEventListener()方法添加的事件句柄\n        element.removeEventListener(\"mousemove\", myFunction);\n7. 节点\n    ```\n    var para = document.createElement(\"p\");\n    var node = document.createTextNode(\"这是一个新的段落。\");\n    para.appendChild(node);\n    var element = document.getElementById(\"div1\");\n    element.appendChild(para);\n    ```\n    \n    - 创建DOM节点 `document.createElement(\"p\")`\n    - 创建文本节点 `document.createTextNode(\"文本\")`\n    - 添加子元素到尾部 `parent.appendChild(child)`\n    - 添加新元素到开始位置 `insertBefore()`\n    - 删除节点 `child.parentNode.removeChild(child);`\n    - 父节点 `child.parentNode`\n    - 子节点 `childNodes`\n    - 第/最后一个子节点 `firstChild` `lastChild`\n    - 下/上一个兄弟节点 `nextSibling` `previousSibling`\n\n# 7. AJAX\n## 7.1 原生xmlhttp\n例子：\n```\nxmlhttp=new XMLHttpRequest();\nxmlhttp.onreadystatechange=function()\n{\n    if (xmlhttp.readyState==4 && xmlhttp.status==200)\n    {\n\t\tconsole.log(xmlhttp.responseText);\n    }\n}\nxmlhttp.open(\"POST\",\"http://www.runoob.com/try/ajax/demo_post.php\",true);\nxmlhttp.setRequestHeader(\"Content-type\",\"application/json;charset=UTF-8\");\nxmlhttp.send(jsonData);\n```\n- 为防止得到缓存结果，可在地址添加随机参数:\n    `\"/ajax/demo_get.php?t=\" + Math.random()`\n- 如果通过 GET 方法发送信息，请向 URL 添加信息：\n    `\"/ajax/demo_get2.php?fname=Henry&lname=Ford\"`\n- onreadystatechange：\n    存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。\n- readyState：\t\n    存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。\n    \n    0: 请求未初始化\n    1: 服务器连接已建立\n    2: 请求已接收\n    3: 请求处理中\n    4: 请求已完成，且响应已就绪\n- status：\n    200: \"OK\"；404: 未找到页面\n\n- Async = false\n    会等到服务器响应就绪才继续执行\n    缺省值为true\n\n- 回调函数（封装，多次使用）\n    函数A作为参数(函数引用)传递到另一个函数B中，并且在函数B执行函数A。\n    我们就说函数A叫做回调函数。\n    如果没有名称(函数表达式)，就叫做匿名回调函数。\n    ```\n    var xmlhttp;\n    function loadXMLDoc(url,cfunc)\n    {\n        xmlhttp=new XMLHttpRequest();\n        xmlhttp.onreadystatechange=cfunc;\n        xmlhttp.open(\"GET\",url,true);\n        xmlhttp.send();\n    }\n    function myFunction()\n    {\n    \tloadXMLDoc(\"/try/ajax/ajax_info.txt\",function()\n    \t{\n    \t\tif (xmlhttp.readyState==4 && xmlhttp.status==200)\n    \t\t{\n    \t\t\tconsole.log(xmlhttp.responseText);\n    \t\t}\n    \t});\n    }\n    ```\n\n## 7.2 jQuery\n```\n$.ajax({\n    type: \"post\",\n    url: \"Demo.aspx/SayHello\",\n    data: {},\n    contentType: \"application/json; charset=utf-8\",\n    dataType: \"json\",//预期服务器返回的数据类型\n    success: function(data) {\n        alert(data.d);//返回的数据用data.d获取内容\n    },\n    error: function(err) {\n        alert(err);\n    }\n});\n```\n\n  [1]: http://www.runoob.com/jsref/dom-obj-event.html","source":"_posts/2018/JavaScript基础.md","raw":"---\ntitle: JavaScript基础\ndate: 2018-07-13 14:48\nupdated: 2018-07-13 14:48\ntags: JS\n---\n> 重学JavaScript时做的笔记。JS的语法真的是让人又爱又恨~\n# 1. Sundry\n- switch()参数可为多种类型\n- 标签：\n    ```\n    outerloop:\n    for (var i = 0; i < 10; i++)\n    {\n        innerloop:\n        for (var j = 0; j < 10; j++)\n        {\n            if (j > 3)\n            {\n                break;\n            }\n            if (i == 2)\n            {\n                break innerloop;//跳过了i=2的情况\n            }\n            if (i == 4)\n            {\n                break outerloop;//i=4时结束\n            }\n            document.write(\"i=\" + i + \" j=\" + j + \"\");\n        }\n    }\n    ```\n\n<!-- more -->\n\n- constructor 属性返回变量的构造函数的原型\n    ```\n    (3.14).constructor//返回ƒ String() { [native code] }\n    \n    function isArray(myArray) {\n        return myArray.constructor.toString().indexOf(\"Array\") > -1;\n    }\n    ```\n- 严格模式：`\"use strict\";`\n- Operator + 可用于将变量转换为数字：\n    ```\n    var y = \"5\";      // y 是一个字符串\n    var x = + y;      // x 是一个数字\n    ```\n    \n- Form提交前验证：\n    ```\n    <form onsubmit=\"return validate()\">\n    //validate方法返回false则不提交\n    ```\n    \n- 变量声明时如果不使用var关键字，那么它就是一个全局变量，即便它在函数内定义。\n- eval('str')\n    解析器解析str代码，功能上类似于Function\n\n- 变量、函数提升机制：\n    ```\n    var c = 2;\n    function c(){\n　　    console.log(1);\n    }\n    c();\n    //报错，c未定义。\n    //var c 和函数c被提升，c=2是表达式，后执行。\n    //所以c()时，c不再是一个函数。\n    ```\n\n# 2. 正则\n- `var patt=/pattern/modifiers;`\n- pattern（模式） 以^开头，$结尾\n\n- test() 方法用于检测一个字符串是否匹配某个模式\n    ```\n    /e/.test(\"The best things in life are free!\");\n    >> true\n    ```\n    \n- exec() 方法用于检索字符串中的正则表达式的匹配(返回第一个匹配值)\n    ```\n    /e[1-9]/.exec(\"The be1st things in life are fre2e!\");\n    >>e1\n    ```\n    \n\n# 3. 错误\n- try-catch：\n    ```\n    try { \n        adddlert(\"Welcome guest!\"); \n    } catch(err) { \n        txt+=\"错误描述：\" + err.message; \n        alert(txt); \n    } \n    ```\n \n- throw：err即throw\n    ```\n    try { \n        if(x == \"\")  throw \"值为空\";\n    }\n    catch(err) {\n        message.innerHTML = \"错误: \" + err;\n    }       \n    ```\n\n# 4. JSON\n- 将一个 JSON 字符串转换为 JavaScript 对象(使可操作)\n    ```\n    var text = '{ \"sites\" : [' +\n        '{ \"name\":\"Runoob\" , \"url\":\"www.runoob.com\" },' +\n        '{ \"name\":\"Google\" , \"url\":\"www.google.com\" },' +\n        '{ \"name\":\"Taobao\" , \"url\":\"www.taobao.com\" } ]}';\n    \n    obj = JSON.parse(text);\n    document.getElementById(\"demo\").innerHTML = obj.sites[1].name + \" \" + obj.sites[1].url;\n    ```\n- 将 JavaScript 值转换为 JSON 字符串(单行)\n> JSON.stringify(value[, replacer[, space]]);\n\n\n# 5. 函数\n- 显式参数(Parameters)就是形参，隐式参数(Arguments)：实参\n- 实例对象、类对象、局部变量(局部函数)\n    ```\n    function Person(national,age)\n    {\n        this.age = age;  //实例对象，每个示例不同\n        Person.national = national;  //类对象,所用实例公用\n        var bb = 0; //局部变量，外面不能访问（类似局部函数）\n    }\n    ```\n\n- 创建新方法\n    ```\n    //原型属性、方法，此方法可被所有String对象使用\n    String.prototype.funcName=function(){}\n    //以字面量方法创建\n    String.prototype = {\n        constructor:String;\n        //如果不写，新对象的构造器会重写String的构造器即Object(花括号)\n        name:\"zs\";\n        id:1\n    }\n    //实例属性、方法（实例通过.__proto__访问）\n    str.funcName=function(){}\n    ```\n\n- 函数自动调用(只会执行一次)：\n    ```\n    <p id=\"demo\"></p>\n    <script>\n    (function(){\n        document.getElementById(\"demo\").innerHTML = \"Hello! 我是自己调用的\";\n    })();\n    </script>\n    ```\n\n- 用构造函数调用函数\n    ```\n    // 构造函数:\n    function myFunction(arg1, arg2){\n        this.firstName = arg1;\n        this.lastName = arg2;//如果直接当方法调用，this指window对象\n        this.fullName = function(){\n            return this.firstName + \" \" + this.lastName;\n        }\n    }\n    var x = new myFunction(\"John\",\"Doe\");\n    console.log(x.fullName());          // \"John Doe\"\n    console.log(x.firstName);           // 返回 \"John\"\n    ```\n\n- 用函数方法调用函数（call() 和 apply()）（对象冒充），this指一参\n    ```\n    function myFunction(a, b) {\n        return a * b;\n    }\n    myObject = myFunction.call(myObject, 10, 2);     // 返回 20\n    //或\n    myArray = [10, 2];\n    myObject = myFunction.apply(myObject, myArray);  // 二参为参数数组\n    ```\n \n- 闭包（closure）：\n    - 就是能够读取其他函数内部变量的函数，在JS中，只有子函数可以访问父函数的内部变量。\n    - 即：闭包是可访问上一层函数作用域里变量的函数，即便上一层函数已经关闭。\n    + 所以只要把子函数作为返回值，我们就可以在父函数外部读取它的私有变量且该变量不会随父函数结束而回收。\n    + 实例：\n        ```\n        var add = (function () {\n            var counter = 0;\n            return function () {return counter += 1;}\n        })();\n        //自我调用使函数只执行一次，设置私有计数器为0。并返回函数表达式。\n        add();\n        add();\n        add();\n        //计数器为 3\n        ```\n        \n    - 优点（应用场景）\n        - 希望一个变量长期驻扎在内存当中；\n        - 避免全局变量的污染；\n        - 私有成员的存在\n- arguments 对象\n    在函数代码中，使用特殊对象arguments，开发者无需明确指出参数名，就能访问它们。\n    ```\n    function sayHi() {\n        if (arguments[0] == \"bye\") {\n            return;\n        }\n        alert(arguments[0]);\n    }\n    ```\n    \n    还可以用 arguments 对象检测函数的参数个数:`arguments.length`\n    因为ECMAScript不会验证传递给函数的参数个数是否等于函数定义的参数个数，所以用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载。\n\n- Function 对象（类）\n    **函数实际上是功能完整的对象。**\n    **所有函数都应看作 Function 类的实例**\n    所以Function 类可以表示开发者定义的任何函数，类似于java的反射。\n    ```\n    //下面这个函数\n\n    function sayHi(sName, sMessage) {\n      alert(\"Hello \" + sName + sMessage);\n    }\n    //还可以这样定义它：\n    \n    var sayHi = new Function(\"sName\", \"sMessage\", \"alert(\\\"Hello \\\" + sName + sMessage);\");\n    ```\n\n# 6. DOM\n1. 获取元素\n    ```\n    var x=document.getElementById(\"intro\");\n    var y=document.getElementsByTagName(\"p\");//返回DOM集合非数组\n    var x=document.getElementsByClassName(\"intro\");\n    document.querySelector(\"p.example\");//获取文档中class=\"example\"的第一个<p>元素\n    querySelectorAll();//返回所有的元素\n    ```\n\n2. 改变 HTML 内容\n    ```\n    document.getElementById(\"p1\").innerHTML=\"新文本!\";\n    document.getElementById(\"p1\").outerHTML=\"<p id='p2'>新文本!</p>\";\n    ```\n\n3. 改变 HTML 属性\n    ```\n    document.getElementById(\"image\").src=\"landscape.jpg\";\n    ```\n\n4. 改变CSS\n    ```\n    document.getElementById(\"p2\").style.color=\"blue\";\n    ```\n5. [HTML DOM事件][1]\n    - onclick\n    - onload 和 onunload（进入或离开页面）（处理cookie）\n    - onchange（对输入字段的验证）\n    - onmouseover 和 onmouseout\n    - onmousedown、onmouseup 以及 onclick\n    - onfocus（输入框获得焦点）\n6. EventListener\n    - addEventListener() 方法\n        ```\n        element.addEventListener(event, function, useCapture);\n        element.addEventListener(\"click\", function(){alert(\"1\");});\n        element.addEventListener(\"click\", function(){myFunction(p1, p2);});\n        ```\n        \n        第一个参数是事件的类型 (如\"click\",无\"on\")。\n        第二个参数是事件触发后调用的函数名（无括号）/匿名函数体。\n        第三个参数true:事件捕获；false:事件冒泡。默认false。可选。\n        可向同一个元素中添加多个事件句柄。\n        用\"匿名函数\"调用带参数的函数。\n    - 事件冒泡或事件捕获\n        在'冒泡'中，内部元素的事件先触发，再触发外部元素事件\n        在'捕获'中，外部元素的事件先触发，再触发内部元素事件\n    - 移除由 addEventListener()方法添加的事件句柄\n        element.removeEventListener(\"mousemove\", myFunction);\n7. 节点\n    ```\n    var para = document.createElement(\"p\");\n    var node = document.createTextNode(\"这是一个新的段落。\");\n    para.appendChild(node);\n    var element = document.getElementById(\"div1\");\n    element.appendChild(para);\n    ```\n    \n    - 创建DOM节点 `document.createElement(\"p\")`\n    - 创建文本节点 `document.createTextNode(\"文本\")`\n    - 添加子元素到尾部 `parent.appendChild(child)`\n    - 添加新元素到开始位置 `insertBefore()`\n    - 删除节点 `child.parentNode.removeChild(child);`\n    - 父节点 `child.parentNode`\n    - 子节点 `childNodes`\n    - 第/最后一个子节点 `firstChild` `lastChild`\n    - 下/上一个兄弟节点 `nextSibling` `previousSibling`\n\n# 7. AJAX\n## 7.1 原生xmlhttp\n例子：\n```\nxmlhttp=new XMLHttpRequest();\nxmlhttp.onreadystatechange=function()\n{\n    if (xmlhttp.readyState==4 && xmlhttp.status==200)\n    {\n\t\tconsole.log(xmlhttp.responseText);\n    }\n}\nxmlhttp.open(\"POST\",\"http://www.runoob.com/try/ajax/demo_post.php\",true);\nxmlhttp.setRequestHeader(\"Content-type\",\"application/json;charset=UTF-8\");\nxmlhttp.send(jsonData);\n```\n- 为防止得到缓存结果，可在地址添加随机参数:\n    `\"/ajax/demo_get.php?t=\" + Math.random()`\n- 如果通过 GET 方法发送信息，请向 URL 添加信息：\n    `\"/ajax/demo_get2.php?fname=Henry&lname=Ford\"`\n- onreadystatechange：\n    存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。\n- readyState：\t\n    存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。\n    \n    0: 请求未初始化\n    1: 服务器连接已建立\n    2: 请求已接收\n    3: 请求处理中\n    4: 请求已完成，且响应已就绪\n- status：\n    200: \"OK\"；404: 未找到页面\n\n- Async = false\n    会等到服务器响应就绪才继续执行\n    缺省值为true\n\n- 回调函数（封装，多次使用）\n    函数A作为参数(函数引用)传递到另一个函数B中，并且在函数B执行函数A。\n    我们就说函数A叫做回调函数。\n    如果没有名称(函数表达式)，就叫做匿名回调函数。\n    ```\n    var xmlhttp;\n    function loadXMLDoc(url,cfunc)\n    {\n        xmlhttp=new XMLHttpRequest();\n        xmlhttp.onreadystatechange=cfunc;\n        xmlhttp.open(\"GET\",url,true);\n        xmlhttp.send();\n    }\n    function myFunction()\n    {\n    \tloadXMLDoc(\"/try/ajax/ajax_info.txt\",function()\n    \t{\n    \t\tif (xmlhttp.readyState==4 && xmlhttp.status==200)\n    \t\t{\n    \t\t\tconsole.log(xmlhttp.responseText);\n    \t\t}\n    \t});\n    }\n    ```\n\n## 7.2 jQuery\n```\n$.ajax({\n    type: \"post\",\n    url: \"Demo.aspx/SayHello\",\n    data: {},\n    contentType: \"application/json; charset=utf-8\",\n    dataType: \"json\",//预期服务器返回的数据类型\n    success: function(data) {\n        alert(data.d);//返回的数据用data.d获取内容\n    },\n    error: function(err) {\n        alert(err);\n    }\n});\n```\n\n  [1]: http://www.runoob.com/jsref/dom-obj-event.html","slug":"2018-JavaScript基础","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrju00082yku0hng4xbu","content":"<blockquote>\n<p>重学JavaScript时做的笔记。JS的语法真的是让人又爱又恨~</p>\n</blockquote>\n<h1 id=\"1-Sundry\"><a href=\"#1-Sundry\" class=\"headerlink\" title=\"1. Sundry\"></a>1. Sundry</h1><ul>\n<li>switch()参数可为多种类型</li>\n<li>标签：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">outerloop:</span><br><span class=\"line\">for (var i &#x3D; 0; i &lt; 10; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    innerloop:</span><br><span class=\"line\">    for (var j &#x3D; 0; j &lt; 10; j++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (j &gt; 3)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (i &#x3D;&#x3D; 2)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            break innerloop;&#x2F;&#x2F;跳过了i&#x3D;2的情况</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (i &#x3D;&#x3D; 4)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            break outerloop;&#x2F;&#x2F;i&#x3D;4时结束</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        document.write(&quot;i&#x3D;&quot; + i + &quot; j&#x3D;&quot; + j + &quot;&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<ul>\n<li><p>constructor 属性返回变量的构造函数的原型</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(3.14).constructor&#x2F;&#x2F;返回ƒ String() &#123; [native code] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function isArray(myArray) &#123;</span><br><span class=\"line\">    return myArray.constructor.toString().indexOf(&quot;Array&quot;) &gt; -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>严格模式：<code>&quot;use strict&quot;;</code></p>\n</li>\n<li><p>Operator + 可用于将变量转换为数字：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var y &#x3D; &quot;5&quot;;      &#x2F;&#x2F; y 是一个字符串</span><br><span class=\"line\">var x &#x3D; + y;      &#x2F;&#x2F; x 是一个数字</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Form提交前验证：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form onsubmit&#x3D;&quot;return validate()&quot;&gt;</span><br><span class=\"line\">&#x2F;&#x2F;validate方法返回false则不提交</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>变量声明时如果不使用var关键字，那么它就是一个全局变量，即便它在函数内定义。</p>\n</li>\n<li><p>eval(‘str’)<br>  解析器解析str代码，功能上类似于Function</p>\n</li>\n<li><p>变量、函数提升机制：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var c &#x3D; 2;</span><br><span class=\"line\">function c()&#123;</span><br><span class=\"line\">　　    console.log(1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">c();</span><br><span class=\"line\">&#x2F;&#x2F;报错，c未定义。</span><br><span class=\"line\">&#x2F;&#x2F;var c 和函数c被提升，c&#x3D;2是表达式，后执行。</span><br><span class=\"line\">&#x2F;&#x2F;所以c()时，c不再是一个函数。</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"2-正则\"><a href=\"#2-正则\" class=\"headerlink\" title=\"2. 正则\"></a>2. 正则</h1><ul>\n<li><p><code>var patt=/pattern/modifiers;</code></p>\n</li>\n<li><p>pattern（模式） 以^开头，$结尾</p>\n</li>\n<li><p>test() 方法用于检测一个字符串是否匹配某个模式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;e&#x2F;.test(&quot;The best things in life are free!&quot;);</span><br><span class=\"line\">&gt;&gt; true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>exec() 方法用于检索字符串中的正则表达式的匹配(返回第一个匹配值)</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;e[1-9]&#x2F;.exec(&quot;The be1st things in life are fre2e!&quot;);</span><br><span class=\"line\">&gt;&gt;e1</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h1 id=\"3-错误\"><a href=\"#3-错误\" class=\"headerlink\" title=\"3. 错误\"></a>3. 错误</h1><ul>\n<li><p>try-catch：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123; </span><br><span class=\"line\">    adddlert(&quot;Welcome guest!&quot;); </span><br><span class=\"line\">&#125; catch(err) &#123; </span><br><span class=\"line\">    txt+&#x3D;&quot;错误描述：&quot; + err.message; </span><br><span class=\"line\">    alert(txt); </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>throw：err即throw</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123; </span><br><span class=\"line\">    if(x &#x3D;&#x3D; &quot;&quot;)  throw &quot;值为空&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">catch(err) &#123;</span><br><span class=\"line\">    message.innerHTML &#x3D; &quot;错误: &quot; + err;</span><br><span class=\"line\">&#125;       </span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"4-JSON\"><a href=\"#4-JSON\" class=\"headerlink\" title=\"4. JSON\"></a>4. JSON</h1><ul>\n<li>将一个 JSON 字符串转换为 JavaScript 对象(使可操作)  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var text &#x3D; &#39;&#123; &quot;sites&quot; : [&#39; +</span><br><span class=\"line\">    &#39;&#123; &quot;name&quot;:&quot;Runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#39; +</span><br><span class=\"line\">    &#39;&#123; &quot;name&quot;:&quot;Google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#39; +</span><br><span class=\"line\">    &#39;&#123; &quot;name&quot;:&quot;Taobao&quot; , &quot;url&quot;:&quot;www.taobao.com&quot; &#125; ]&#125;&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj &#x3D; JSON.parse(text);</span><br><span class=\"line\">document.getElementById(&quot;demo&quot;).innerHTML &#x3D; obj.sites[1].name + &quot; &quot; + obj.sites[1].url;</span><br></pre></td></tr></table></figure></li>\n<li>将 JavaScript 值转换为 JSON 字符串(单行)<blockquote>\n<p>JSON.stringify(value[, replacer[, space]]);</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"5-函数\"><a href=\"#5-函数\" class=\"headerlink\" title=\"5. 函数\"></a>5. 函数</h1><ul>\n<li><p>显式参数(Parameters)就是形参，隐式参数(Arguments)：实参</p>\n</li>\n<li><p>实例对象、类对象、局部变量(局部函数)</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(national,age)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.age &#x3D; age;  &#x2F;&#x2F;实例对象，每个示例不同</span><br><span class=\"line\">    Person.national &#x3D; national;  &#x2F;&#x2F;类对象,所用实例公用</span><br><span class=\"line\">    var bb &#x3D; 0; &#x2F;&#x2F;局部变量，外面不能访问（类似局部函数）</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建新方法</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;原型属性、方法，此方法可被所有String对象使用</span><br><span class=\"line\">String.prototype.funcName&#x3D;function()&#123;&#125;</span><br><span class=\"line\">&#x2F;&#x2F;以字面量方法创建</span><br><span class=\"line\">String.prototype &#x3D; &#123;</span><br><span class=\"line\">    constructor:String;</span><br><span class=\"line\">    &#x2F;&#x2F;如果不写，新对象的构造器会重写String的构造器即Object(花括号)</span><br><span class=\"line\">    name:&quot;zs&quot;;</span><br><span class=\"line\">    id:1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;实例属性、方法（实例通过.__proto__访问）</span><br><span class=\"line\">str.funcName&#x3D;function()&#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数自动调用(只会执行一次)：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">    document.getElementById(&quot;demo&quot;).innerHTML &#x3D; &quot;Hello! 我是自己调用的&quot;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用构造函数调用函数</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 构造函数:</span><br><span class=\"line\">function myFunction(arg1, arg2)&#123;</span><br><span class=\"line\">    this.firstName &#x3D; arg1;</span><br><span class=\"line\">    this.lastName &#x3D; arg2;&#x2F;&#x2F;如果直接当方法调用，this指window对象</span><br><span class=\"line\">    this.fullName &#x3D; function()&#123;</span><br><span class=\"line\">        return this.firstName + &quot; &quot; + this.lastName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var x &#x3D; new myFunction(&quot;John&quot;,&quot;Doe&quot;);</span><br><span class=\"line\">console.log(x.fullName());          &#x2F;&#x2F; &quot;John Doe&quot;</span><br><span class=\"line\">console.log(x.firstName);           &#x2F;&#x2F; 返回 &quot;John&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用函数方法调用函数（call() 和 apply()）（对象冒充），this指一参</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function myFunction(a, b) &#123;</span><br><span class=\"line\">    return a * b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">myObject &#x3D; myFunction.call(myObject, 10, 2);     &#x2F;&#x2F; 返回 20</span><br><span class=\"line\">&#x2F;&#x2F;或</span><br><span class=\"line\">myArray &#x3D; [10, 2];</span><br><span class=\"line\">myObject &#x3D; myFunction.apply(myObject, myArray);  &#x2F;&#x2F; 二参为参数数组</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>闭包（closure）：</p>\n<ul>\n<li>就是能够读取其他函数内部变量的函数，在JS中，只有子函数可以访问父函数的内部变量。</li>\n<li>即：闭包是可访问上一层函数作用域里变量的函数，即便上一层函数已经关闭。</li>\n</ul>\n<ul>\n<li>所以只要把子函数作为返回值，我们就可以在父函数外部读取它的私有变量且该变量不会随父函数结束而回收。</li>\n<li>实例：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var add &#x3D; (function () &#123;</span><br><span class=\"line\">    var counter &#x3D; 0;</span><br><span class=\"line\">    return function () &#123;return counter +&#x3D; 1;&#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">&#x2F;&#x2F;自我调用使函数只执行一次，设置私有计数器为0。并返回函数表达式。</span><br><span class=\"line\">add();</span><br><span class=\"line\">add();</span><br><span class=\"line\">add();</span><br><span class=\"line\">&#x2F;&#x2F;计数器为 3</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>优点（应用场景）<ul>\n<li>希望一个变量长期驻扎在内存当中；</li>\n<li>避免全局变量的污染；</li>\n<li>私有成员的存在</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>arguments 对象<br>  在函数代码中，使用特殊对象arguments，开发者无需明确指出参数名，就能访问它们。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sayHi() &#123;</span><br><span class=\"line\">    if (arguments[0] &#x3D;&#x3D; &quot;bye&quot;) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    alert(arguments[0]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  还可以用 arguments 对象检测函数的参数个数:<code>arguments.length</code><br>  因为ECMAScript不会验证传递给函数的参数个数是否等于函数定义的参数个数，所以用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载。</p>\n</li>\n<li><p>Function 对象（类）<br>  <strong>函数实际上是功能完整的对象。</strong><br>  <strong>所有函数都应看作 Function 类的实例</strong><br>  所以Function 类可以表示开发者定义的任何函数，类似于java的反射。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;下面这个函数</span><br><span class=\"line\"></span><br><span class=\"line\">function sayHi(sName, sMessage) &#123;</span><br><span class=\"line\">  alert(&quot;Hello &quot; + sName + sMessage);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;还可以这样定义它：</span><br><span class=\"line\"></span><br><span class=\"line\">var sayHi &#x3D; new Function(&quot;sName&quot;, &quot;sMessage&quot;, &quot;alert(\\&quot;Hello \\&quot; + sName + sMessage);&quot;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"6-DOM\"><a href=\"#6-DOM\" class=\"headerlink\" title=\"6. DOM\"></a>6. DOM</h1><ol>\n<li><p>获取元素</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x&#x3D;document.getElementById(&quot;intro&quot;);</span><br><span class=\"line\">var y&#x3D;document.getElementsByTagName(&quot;p&quot;);&#x2F;&#x2F;返回DOM集合非数组</span><br><span class=\"line\">var x&#x3D;document.getElementsByClassName(&quot;intro&quot;);</span><br><span class=\"line\">document.querySelector(&quot;p.example&quot;);&#x2F;&#x2F;获取文档中class&#x3D;&quot;example&quot;的第一个&lt;p&gt;元素</span><br><span class=\"line\">querySelectorAll();&#x2F;&#x2F;返回所有的元素</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>改变 HTML 内容</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&quot;p1&quot;).innerHTML&#x3D;&quot;新文本!&quot;;</span><br><span class=\"line\">document.getElementById(&quot;p1&quot;).outerHTML&#x3D;&quot;&lt;p id&#x3D;&#39;p2&#39;&gt;新文本!&lt;&#x2F;p&gt;&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>改变 HTML 属性</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&quot;image&quot;).src&#x3D;&quot;landscape.jpg&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>改变CSS</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&quot;p2&quot;).style.color&#x3D;&quot;blue&quot;;</span><br></pre></td></tr></table></figure></li>\n<li><p><a href=\"http://www.runoob.com/jsref/dom-obj-event.html\">HTML DOM事件</a></p>\n<ul>\n<li>onclick</li>\n<li>onload 和 onunload（进入或离开页面）（处理cookie）</li>\n<li>onchange（对输入字段的验证）</li>\n<li>onmouseover 和 onmouseout</li>\n<li>onmousedown、onmouseup 以及 onclick</li>\n<li>onfocus（输入框获得焦点）</li>\n</ul>\n</li>\n<li><p>EventListener</p>\n<ul>\n<li><p>addEventListener() 方法</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.addEventListener(event, function, useCapture);</span><br><span class=\"line\">element.addEventListener(&quot;click&quot;, function()&#123;alert(&quot;1&quot;);&#125;);</span><br><span class=\"line\">element.addEventListener(&quot;click&quot;, function()&#123;myFunction(p1, p2);&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>  第一个参数是事件的类型 (如”click”,无”on”)。<br>  第二个参数是事件触发后调用的函数名（无括号）/匿名函数体。<br>  第三个参数true:事件捕获；false:事件冒泡。默认false。可选。<br>  可向同一个元素中添加多个事件句柄。<br>  用”匿名函数”调用带参数的函数。</p>\n</li>\n<li><p>事件冒泡或事件捕获<br>  在’冒泡’中，内部元素的事件先触发，再触发外部元素事件<br>  在’捕获’中，外部元素的事件先触发，再触发内部元素事件</p>\n</li>\n<li><p>移除由 addEventListener()方法添加的事件句柄<br>  element.removeEventListener(“mousemove”, myFunction);</p>\n</li>\n</ul>\n</li>\n<li><p>节点</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var para &#x3D; document.createElement(&quot;p&quot;);</span><br><span class=\"line\">var node &#x3D; document.createTextNode(&quot;这是一个新的段落。&quot;);</span><br><span class=\"line\">para.appendChild(node);</span><br><span class=\"line\">var element &#x3D; document.getElementById(&quot;div1&quot;);</span><br><span class=\"line\">element.appendChild(para);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建DOM节点 <code>document.createElement(&quot;p&quot;)</code></li>\n<li>创建文本节点 <code>document.createTextNode(&quot;文本&quot;)</code></li>\n<li>添加子元素到尾部 <code>parent.appendChild(child)</code></li>\n<li>添加新元素到开始位置 <code>insertBefore()</code></li>\n<li>删除节点 <code>child.parentNode.removeChild(child);</code></li>\n<li>父节点 <code>child.parentNode</code></li>\n<li>子节点 <code>childNodes</code></li>\n<li>第/最后一个子节点 <code>firstChild</code> <code>lastChild</code></li>\n<li>下/上一个兄弟节点 <code>nextSibling</code> <code>previousSibling</code></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"7-AJAX\"><a href=\"#7-AJAX\" class=\"headerlink\" title=\"7. AJAX\"></a>7. AJAX</h1><h2 id=\"7-1-原生xmlhttp\"><a href=\"#7-1-原生xmlhttp\" class=\"headerlink\" title=\"7.1 原生xmlhttp\"></a>7.1 原生xmlhttp</h2><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class=\"line\">xmlhttp.onreadystatechange&#x3D;function()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\tconsole.log(xmlhttp.responseText);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">xmlhttp.open(&quot;POST&quot;,&quot;http:&#x2F;&#x2F;www.runoob.com&#x2F;try&#x2F;ajax&#x2F;demo_post.php&quot;,true);</span><br><span class=\"line\">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);</span><br><span class=\"line\">xmlhttp.send(jsonData);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>为防止得到缓存结果，可在地址添加随机参数:<br>  <code>&quot;/ajax/demo_get.php?t=&quot; + Math.random()</code></p>\n</li>\n<li><p>如果通过 GET 方法发送信息，请向 URL 添加信息：<br>  <code>&quot;/ajax/demo_get2.php?fname=Henry&amp;lname=Ford&quot;</code></p>\n</li>\n<li><p>onreadystatechange：<br>  存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</p>\n</li>\n<li><p>readyState：<br>  存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</p>\n<p>  0: 请求未初始化<br>  1: 服务器连接已建立<br>  2: 请求已接收<br>  3: 请求处理中<br>  4: 请求已完成，且响应已就绪</p>\n</li>\n<li><p>status：<br>  200: “OK”；404: 未找到页面</p>\n</li>\n<li><p>Async = false<br>  会等到服务器响应就绪才继续执行<br>  缺省值为true</p>\n</li>\n<li><p>回调函数（封装，多次使用）<br>  函数A作为参数(函数引用)传递到另一个函数B中，并且在函数B执行函数A。<br>  我们就说函数A叫做回调函数。<br>  如果没有名称(函数表达式)，就叫做匿名回调函数。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xmlhttp;</span><br><span class=\"line\">function loadXMLDoc(url,cfunc)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class=\"line\">    xmlhttp.onreadystatechange&#x3D;cfunc;</span><br><span class=\"line\">    xmlhttp.open(&quot;GET&quot;,url,true);</span><br><span class=\"line\">    xmlhttp.send();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function myFunction()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tloadXMLDoc(&quot;&#x2F;try&#x2F;ajax&#x2F;ajax_info.txt&quot;,function()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tconsole.log(xmlhttp.responseText);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"7-2-jQuery\"><a href=\"#7-2-jQuery\" class=\"headerlink\" title=\"7.2 jQuery\"></a>7.2 jQuery</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type: &quot;post&quot;,</span><br><span class=\"line\">    url: &quot;Demo.aspx&#x2F;SayHello&quot;,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    contentType: &quot;application&#x2F;json; charset&#x3D;utf-8&quot;,</span><br><span class=\"line\">    dataType: &quot;json&quot;,&#x2F;&#x2F;预期服务器返回的数据类型</span><br><span class=\"line\">    success: function(data) &#123;</span><br><span class=\"line\">        alert(data.d);&#x2F;&#x2F;返回的数据用data.d获取内容</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error: function(err) &#123;</span><br><span class=\"line\">        alert(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>重学JavaScript时做的笔记。JS的语法真的是让人又爱又恨~</p>\n</blockquote>\n<h1 id=\"1-Sundry\"><a href=\"#1-Sundry\" class=\"headerlink\" title=\"1. Sundry\"></a>1. Sundry</h1><ul>\n<li>switch()参数可为多种类型</li>\n<li>标签：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">outerloop:</span><br><span class=\"line\">for (var i &#x3D; 0; i &lt; 10; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    innerloop:</span><br><span class=\"line\">    for (var j &#x3D; 0; j &lt; 10; j++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (j &gt; 3)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (i &#x3D;&#x3D; 2)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            break innerloop;&#x2F;&#x2F;跳过了i&#x3D;2的情况</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (i &#x3D;&#x3D; 4)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            break outerloop;&#x2F;&#x2F;i&#x3D;4时结束</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        document.write(&quot;i&#x3D;&quot; + i + &quot; j&#x3D;&quot; + j + &quot;&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>","more":"<ul>\n<li><p>constructor 属性返回变量的构造函数的原型</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(3.14).constructor&#x2F;&#x2F;返回ƒ String() &#123; [native code] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function isArray(myArray) &#123;</span><br><span class=\"line\">    return myArray.constructor.toString().indexOf(&quot;Array&quot;) &gt; -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>严格模式：<code>&quot;use strict&quot;;</code></p>\n</li>\n<li><p>Operator + 可用于将变量转换为数字：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var y &#x3D; &quot;5&quot;;      &#x2F;&#x2F; y 是一个字符串</span><br><span class=\"line\">var x &#x3D; + y;      &#x2F;&#x2F; x 是一个数字</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Form提交前验证：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form onsubmit&#x3D;&quot;return validate()&quot;&gt;</span><br><span class=\"line\">&#x2F;&#x2F;validate方法返回false则不提交</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>变量声明时如果不使用var关键字，那么它就是一个全局变量，即便它在函数内定义。</p>\n</li>\n<li><p>eval(‘str’)<br>  解析器解析str代码，功能上类似于Function</p>\n</li>\n<li><p>变量、函数提升机制：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var c &#x3D; 2;</span><br><span class=\"line\">function c()&#123;</span><br><span class=\"line\">　　    console.log(1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">c();</span><br><span class=\"line\">&#x2F;&#x2F;报错，c未定义。</span><br><span class=\"line\">&#x2F;&#x2F;var c 和函数c被提升，c&#x3D;2是表达式，后执行。</span><br><span class=\"line\">&#x2F;&#x2F;所以c()时，c不再是一个函数。</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"2-正则\"><a href=\"#2-正则\" class=\"headerlink\" title=\"2. 正则\"></a>2. 正则</h1><ul>\n<li><p><code>var patt=/pattern/modifiers;</code></p>\n</li>\n<li><p>pattern（模式） 以^开头，$结尾</p>\n</li>\n<li><p>test() 方法用于检测一个字符串是否匹配某个模式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;e&#x2F;.test(&quot;The best things in life are free!&quot;);</span><br><span class=\"line\">&gt;&gt; true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>exec() 方法用于检索字符串中的正则表达式的匹配(返回第一个匹配值)</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;e[1-9]&#x2F;.exec(&quot;The be1st things in life are fre2e!&quot;);</span><br><span class=\"line\">&gt;&gt;e1</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h1 id=\"3-错误\"><a href=\"#3-错误\" class=\"headerlink\" title=\"3. 错误\"></a>3. 错误</h1><ul>\n<li><p>try-catch：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123; </span><br><span class=\"line\">    adddlert(&quot;Welcome guest!&quot;); </span><br><span class=\"line\">&#125; catch(err) &#123; </span><br><span class=\"line\">    txt+&#x3D;&quot;错误描述：&quot; + err.message; </span><br><span class=\"line\">    alert(txt); </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>throw：err即throw</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123; </span><br><span class=\"line\">    if(x &#x3D;&#x3D; &quot;&quot;)  throw &quot;值为空&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">catch(err) &#123;</span><br><span class=\"line\">    message.innerHTML &#x3D; &quot;错误: &quot; + err;</span><br><span class=\"line\">&#125;       </span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"4-JSON\"><a href=\"#4-JSON\" class=\"headerlink\" title=\"4. JSON\"></a>4. JSON</h1><ul>\n<li>将一个 JSON 字符串转换为 JavaScript 对象(使可操作)  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var text &#x3D; &#39;&#123; &quot;sites&quot; : [&#39; +</span><br><span class=\"line\">    &#39;&#123; &quot;name&quot;:&quot;Runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#39; +</span><br><span class=\"line\">    &#39;&#123; &quot;name&quot;:&quot;Google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#39; +</span><br><span class=\"line\">    &#39;&#123; &quot;name&quot;:&quot;Taobao&quot; , &quot;url&quot;:&quot;www.taobao.com&quot; &#125; ]&#125;&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj &#x3D; JSON.parse(text);</span><br><span class=\"line\">document.getElementById(&quot;demo&quot;).innerHTML &#x3D; obj.sites[1].name + &quot; &quot; + obj.sites[1].url;</span><br></pre></td></tr></table></figure></li>\n<li>将 JavaScript 值转换为 JSON 字符串(单行)<blockquote>\n<p>JSON.stringify(value[, replacer[, space]]);</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"5-函数\"><a href=\"#5-函数\" class=\"headerlink\" title=\"5. 函数\"></a>5. 函数</h1><ul>\n<li><p>显式参数(Parameters)就是形参，隐式参数(Arguments)：实参</p>\n</li>\n<li><p>实例对象、类对象、局部变量(局部函数)</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(national,age)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.age &#x3D; age;  &#x2F;&#x2F;实例对象，每个示例不同</span><br><span class=\"line\">    Person.national &#x3D; national;  &#x2F;&#x2F;类对象,所用实例公用</span><br><span class=\"line\">    var bb &#x3D; 0; &#x2F;&#x2F;局部变量，外面不能访问（类似局部函数）</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建新方法</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;原型属性、方法，此方法可被所有String对象使用</span><br><span class=\"line\">String.prototype.funcName&#x3D;function()&#123;&#125;</span><br><span class=\"line\">&#x2F;&#x2F;以字面量方法创建</span><br><span class=\"line\">String.prototype &#x3D; &#123;</span><br><span class=\"line\">    constructor:String;</span><br><span class=\"line\">    &#x2F;&#x2F;如果不写，新对象的构造器会重写String的构造器即Object(花括号)</span><br><span class=\"line\">    name:&quot;zs&quot;;</span><br><span class=\"line\">    id:1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;实例属性、方法（实例通过.__proto__访问）</span><br><span class=\"line\">str.funcName&#x3D;function()&#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数自动调用(只会执行一次)：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">    document.getElementById(&quot;demo&quot;).innerHTML &#x3D; &quot;Hello! 我是自己调用的&quot;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用构造函数调用函数</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 构造函数:</span><br><span class=\"line\">function myFunction(arg1, arg2)&#123;</span><br><span class=\"line\">    this.firstName &#x3D; arg1;</span><br><span class=\"line\">    this.lastName &#x3D; arg2;&#x2F;&#x2F;如果直接当方法调用，this指window对象</span><br><span class=\"line\">    this.fullName &#x3D; function()&#123;</span><br><span class=\"line\">        return this.firstName + &quot; &quot; + this.lastName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var x &#x3D; new myFunction(&quot;John&quot;,&quot;Doe&quot;);</span><br><span class=\"line\">console.log(x.fullName());          &#x2F;&#x2F; &quot;John Doe&quot;</span><br><span class=\"line\">console.log(x.firstName);           &#x2F;&#x2F; 返回 &quot;John&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用函数方法调用函数（call() 和 apply()）（对象冒充），this指一参</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function myFunction(a, b) &#123;</span><br><span class=\"line\">    return a * b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">myObject &#x3D; myFunction.call(myObject, 10, 2);     &#x2F;&#x2F; 返回 20</span><br><span class=\"line\">&#x2F;&#x2F;或</span><br><span class=\"line\">myArray &#x3D; [10, 2];</span><br><span class=\"line\">myObject &#x3D; myFunction.apply(myObject, myArray);  &#x2F;&#x2F; 二参为参数数组</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>闭包（closure）：</p>\n<ul>\n<li>就是能够读取其他函数内部变量的函数，在JS中，只有子函数可以访问父函数的内部变量。</li>\n<li>即：闭包是可访问上一层函数作用域里变量的函数，即便上一层函数已经关闭。</li>\n</ul>\n<ul>\n<li>所以只要把子函数作为返回值，我们就可以在父函数外部读取它的私有变量且该变量不会随父函数结束而回收。</li>\n<li>实例：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var add &#x3D; (function () &#123;</span><br><span class=\"line\">    var counter &#x3D; 0;</span><br><span class=\"line\">    return function () &#123;return counter +&#x3D; 1;&#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">&#x2F;&#x2F;自我调用使函数只执行一次，设置私有计数器为0。并返回函数表达式。</span><br><span class=\"line\">add();</span><br><span class=\"line\">add();</span><br><span class=\"line\">add();</span><br><span class=\"line\">&#x2F;&#x2F;计数器为 3</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>优点（应用场景）<ul>\n<li>希望一个变量长期驻扎在内存当中；</li>\n<li>避免全局变量的污染；</li>\n<li>私有成员的存在</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>arguments 对象<br>  在函数代码中，使用特殊对象arguments，开发者无需明确指出参数名，就能访问它们。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sayHi() &#123;</span><br><span class=\"line\">    if (arguments[0] &#x3D;&#x3D; &quot;bye&quot;) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    alert(arguments[0]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  还可以用 arguments 对象检测函数的参数个数:<code>arguments.length</code><br>  因为ECMAScript不会验证传递给函数的参数个数是否等于函数定义的参数个数，所以用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载。</p>\n</li>\n<li><p>Function 对象（类）<br>  <strong>函数实际上是功能完整的对象。</strong><br>  <strong>所有函数都应看作 Function 类的实例</strong><br>  所以Function 类可以表示开发者定义的任何函数，类似于java的反射。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;下面这个函数</span><br><span class=\"line\"></span><br><span class=\"line\">function sayHi(sName, sMessage) &#123;</span><br><span class=\"line\">  alert(&quot;Hello &quot; + sName + sMessage);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;还可以这样定义它：</span><br><span class=\"line\"></span><br><span class=\"line\">var sayHi &#x3D; new Function(&quot;sName&quot;, &quot;sMessage&quot;, &quot;alert(\\&quot;Hello \\&quot; + sName + sMessage);&quot;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"6-DOM\"><a href=\"#6-DOM\" class=\"headerlink\" title=\"6. DOM\"></a>6. DOM</h1><ol>\n<li><p>获取元素</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x&#x3D;document.getElementById(&quot;intro&quot;);</span><br><span class=\"line\">var y&#x3D;document.getElementsByTagName(&quot;p&quot;);&#x2F;&#x2F;返回DOM集合非数组</span><br><span class=\"line\">var x&#x3D;document.getElementsByClassName(&quot;intro&quot;);</span><br><span class=\"line\">document.querySelector(&quot;p.example&quot;);&#x2F;&#x2F;获取文档中class&#x3D;&quot;example&quot;的第一个&lt;p&gt;元素</span><br><span class=\"line\">querySelectorAll();&#x2F;&#x2F;返回所有的元素</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>改变 HTML 内容</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&quot;p1&quot;).innerHTML&#x3D;&quot;新文本!&quot;;</span><br><span class=\"line\">document.getElementById(&quot;p1&quot;).outerHTML&#x3D;&quot;&lt;p id&#x3D;&#39;p2&#39;&gt;新文本!&lt;&#x2F;p&gt;&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>改变 HTML 属性</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&quot;image&quot;).src&#x3D;&quot;landscape.jpg&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>改变CSS</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&quot;p2&quot;).style.color&#x3D;&quot;blue&quot;;</span><br></pre></td></tr></table></figure></li>\n<li><p><a href=\"http://www.runoob.com/jsref/dom-obj-event.html\">HTML DOM事件</a></p>\n<ul>\n<li>onclick</li>\n<li>onload 和 onunload（进入或离开页面）（处理cookie）</li>\n<li>onchange（对输入字段的验证）</li>\n<li>onmouseover 和 onmouseout</li>\n<li>onmousedown、onmouseup 以及 onclick</li>\n<li>onfocus（输入框获得焦点）</li>\n</ul>\n</li>\n<li><p>EventListener</p>\n<ul>\n<li><p>addEventListener() 方法</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.addEventListener(event, function, useCapture);</span><br><span class=\"line\">element.addEventListener(&quot;click&quot;, function()&#123;alert(&quot;1&quot;);&#125;);</span><br><span class=\"line\">element.addEventListener(&quot;click&quot;, function()&#123;myFunction(p1, p2);&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>  第一个参数是事件的类型 (如”click”,无”on”)。<br>  第二个参数是事件触发后调用的函数名（无括号）/匿名函数体。<br>  第三个参数true:事件捕获；false:事件冒泡。默认false。可选。<br>  可向同一个元素中添加多个事件句柄。<br>  用”匿名函数”调用带参数的函数。</p>\n</li>\n<li><p>事件冒泡或事件捕获<br>  在’冒泡’中，内部元素的事件先触发，再触发外部元素事件<br>  在’捕获’中，外部元素的事件先触发，再触发内部元素事件</p>\n</li>\n<li><p>移除由 addEventListener()方法添加的事件句柄<br>  element.removeEventListener(“mousemove”, myFunction);</p>\n</li>\n</ul>\n</li>\n<li><p>节点</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var para &#x3D; document.createElement(&quot;p&quot;);</span><br><span class=\"line\">var node &#x3D; document.createTextNode(&quot;这是一个新的段落。&quot;);</span><br><span class=\"line\">para.appendChild(node);</span><br><span class=\"line\">var element &#x3D; document.getElementById(&quot;div1&quot;);</span><br><span class=\"line\">element.appendChild(para);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建DOM节点 <code>document.createElement(&quot;p&quot;)</code></li>\n<li>创建文本节点 <code>document.createTextNode(&quot;文本&quot;)</code></li>\n<li>添加子元素到尾部 <code>parent.appendChild(child)</code></li>\n<li>添加新元素到开始位置 <code>insertBefore()</code></li>\n<li>删除节点 <code>child.parentNode.removeChild(child);</code></li>\n<li>父节点 <code>child.parentNode</code></li>\n<li>子节点 <code>childNodes</code></li>\n<li>第/最后一个子节点 <code>firstChild</code> <code>lastChild</code></li>\n<li>下/上一个兄弟节点 <code>nextSibling</code> <code>previousSibling</code></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"7-AJAX\"><a href=\"#7-AJAX\" class=\"headerlink\" title=\"7. AJAX\"></a>7. AJAX</h1><h2 id=\"7-1-原生xmlhttp\"><a href=\"#7-1-原生xmlhttp\" class=\"headerlink\" title=\"7.1 原生xmlhttp\"></a>7.1 原生xmlhttp</h2><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class=\"line\">xmlhttp.onreadystatechange&#x3D;function()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\tconsole.log(xmlhttp.responseText);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">xmlhttp.open(&quot;POST&quot;,&quot;http:&#x2F;&#x2F;www.runoob.com&#x2F;try&#x2F;ajax&#x2F;demo_post.php&quot;,true);</span><br><span class=\"line\">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);</span><br><span class=\"line\">xmlhttp.send(jsonData);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>为防止得到缓存结果，可在地址添加随机参数:<br>  <code>&quot;/ajax/demo_get.php?t=&quot; + Math.random()</code></p>\n</li>\n<li><p>如果通过 GET 方法发送信息，请向 URL 添加信息：<br>  <code>&quot;/ajax/demo_get2.php?fname=Henry&amp;lname=Ford&quot;</code></p>\n</li>\n<li><p>onreadystatechange：<br>  存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</p>\n</li>\n<li><p>readyState：<br>  存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</p>\n<p>  0: 请求未初始化<br>  1: 服务器连接已建立<br>  2: 请求已接收<br>  3: 请求处理中<br>  4: 请求已完成，且响应已就绪</p>\n</li>\n<li><p>status：<br>  200: “OK”；404: 未找到页面</p>\n</li>\n<li><p>Async = false<br>  会等到服务器响应就绪才继续执行<br>  缺省值为true</p>\n</li>\n<li><p>回调函数（封装，多次使用）<br>  函数A作为参数(函数引用)传递到另一个函数B中，并且在函数B执行函数A。<br>  我们就说函数A叫做回调函数。<br>  如果没有名称(函数表达式)，就叫做匿名回调函数。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xmlhttp;</span><br><span class=\"line\">function loadXMLDoc(url,cfunc)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class=\"line\">    xmlhttp.onreadystatechange&#x3D;cfunc;</span><br><span class=\"line\">    xmlhttp.open(&quot;GET&quot;,url,true);</span><br><span class=\"line\">    xmlhttp.send();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function myFunction()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tloadXMLDoc(&quot;&#x2F;try&#x2F;ajax&#x2F;ajax_info.txt&quot;,function()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tconsole.log(xmlhttp.responseText);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"7-2-jQuery\"><a href=\"#7-2-jQuery\" class=\"headerlink\" title=\"7.2 jQuery\"></a>7.2 jQuery</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type: &quot;post&quot;,</span><br><span class=\"line\">    url: &quot;Demo.aspx&#x2F;SayHello&quot;,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    contentType: &quot;application&#x2F;json; charset&#x3D;utf-8&quot;,</span><br><span class=\"line\">    dataType: &quot;json&quot;,&#x2F;&#x2F;预期服务器返回的数据类型</span><br><span class=\"line\">    success: function(data) &#123;</span><br><span class=\"line\">        alert(data.d);&#x2F;&#x2F;返回的数据用data.d获取内容</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error: function(err) &#123;</span><br><span class=\"line\">        alert(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"Java反射","date":"2018-06-17T15:36:00.000Z","updated":"2018-06-16T16:00:00.000Z","_content":"> Spring中IOC的核心原理，将文本转换成jvm对象的方法。【本文有待修善】\n# 1. 获取类信息\n\n<!-- more -->\n\n1. 获取指定类对应的Class对象\n    1. `Class c = ArrayList.class;`\n    2. `Class c = list.getClass();`\n    3. `Class c = Class.forName(\"java.util.ArrayList\");//并加载指定的类`\n2. 获取包名\n`String packageName = c.getPackage().getName();`\n3. 获取类的修饰符\n`int mod = c.getModifiers();`\n`String modifier = Modifier.toString(mod);`\n4. 类的全限定名\n`String className = c.getName();`\n5. 父类\n`Class superC = c.getSuperclass();`\n6. 实现的接口\n`Class interfaces = c.getInterfaces();`\n7. public变量/成员变量及操作\n`Field[] fields = c.getFields();`\n`Field[] fields = c.getDeclaredFields();`\n`Field field = c.getDeclaredField(\"变量名\");`\n`field.set(对象,\"变量值\")`\n8. 构造方法\n`Constructor[] constructors = c.getDeclaredConstructors();`\n9. public方法(包括父类)/自己的的成员方法\n`Method[] methods = c.getMethods();`\n`Method[] methods = c.getDeclaredMethods();`\n10. 通过类的类类型创建该类的对象实例\n`String str = (String)c1.newInstance();//需要有无参数的构造方法`\n\n# 2. 创建对象\n```\nClass c = Class.forName(\"java.util.ArrayList\");\nList list = (List)c.newInstance();\n```\n\n# 3. 方法反射\n`方法对象.invoke(类对象,参数表);`\n```\npublic class MethodDemo1 {\n\tpublic static void main(String[] args) {\n        /**目标：要获取print(int,int)方法\n         *获取一个方法就要获取类的信息\n         *1.获取类的信息首先要获取类的类类型\n         */\n\t\tA a1 = new A();\n\t\tClass c = a1.getClass();\n        try {\n            /*2.获取方法 名称和参数列表来决定  \n             * getMethod获取的是public的方法\n             * getDeclaredMethod自己声明的方法\n             */\n\t\t\tMethod m2 = c.getMethod(\"print\");\n            Method m = c.getDeclaredMethod(\"print\", int.class,int.class);\n\t    \t\n            /*3.进行方法的反射操作\n             *可用o接返回值\n             *没有返回值即null\n             *setAccessible(AccessibleObject[] array, boolean flag) \n             *使用单一安全性检查（为了提高效率）\n             *为一组对象设置accessible标志的便捷方法。\n             *setAccessible(boolean flag) \n             *将单个对象的accessible标志设置为指示的布尔值。\n             */\n            a1.setAccessible(true);\n            Object o = a1.print(10, 20);\n            Object o = m.invoke(a1,new Object[]{10,20});\n            Object o = m.invoke(a1, 10,20);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\nclass A{\n\tpublic void print(){\n\t\tSystem.out.println(\"helloworld\");\n\t}\n\tprivate void print(int a,int b){\n\t\tSystem.out.println(a+b);\n\t}\n\tpublic void print(String a,String b){\n\t\tSystem.out.println(a.toUpperCase()+\",\"+b.toLowerCase());\n\t}\n}\n```\n\n\n\n\n","source":"_posts/2018/Java反射.md","raw":"---\ntitle: Java反射\ndate: 2018-06-17 23:36\nupdated: 2018-06-17\ntags: Java\n---\n> Spring中IOC的核心原理，将文本转换成jvm对象的方法。【本文有待修善】\n# 1. 获取类信息\n\n<!-- more -->\n\n1. 获取指定类对应的Class对象\n    1. `Class c = ArrayList.class;`\n    2. `Class c = list.getClass();`\n    3. `Class c = Class.forName(\"java.util.ArrayList\");//并加载指定的类`\n2. 获取包名\n`String packageName = c.getPackage().getName();`\n3. 获取类的修饰符\n`int mod = c.getModifiers();`\n`String modifier = Modifier.toString(mod);`\n4. 类的全限定名\n`String className = c.getName();`\n5. 父类\n`Class superC = c.getSuperclass();`\n6. 实现的接口\n`Class interfaces = c.getInterfaces();`\n7. public变量/成员变量及操作\n`Field[] fields = c.getFields();`\n`Field[] fields = c.getDeclaredFields();`\n`Field field = c.getDeclaredField(\"变量名\");`\n`field.set(对象,\"变量值\")`\n8. 构造方法\n`Constructor[] constructors = c.getDeclaredConstructors();`\n9. public方法(包括父类)/自己的的成员方法\n`Method[] methods = c.getMethods();`\n`Method[] methods = c.getDeclaredMethods();`\n10. 通过类的类类型创建该类的对象实例\n`String str = (String)c1.newInstance();//需要有无参数的构造方法`\n\n# 2. 创建对象\n```\nClass c = Class.forName(\"java.util.ArrayList\");\nList list = (List)c.newInstance();\n```\n\n# 3. 方法反射\n`方法对象.invoke(类对象,参数表);`\n```\npublic class MethodDemo1 {\n\tpublic static void main(String[] args) {\n        /**目标：要获取print(int,int)方法\n         *获取一个方法就要获取类的信息\n         *1.获取类的信息首先要获取类的类类型\n         */\n\t\tA a1 = new A();\n\t\tClass c = a1.getClass();\n        try {\n            /*2.获取方法 名称和参数列表来决定  \n             * getMethod获取的是public的方法\n             * getDeclaredMethod自己声明的方法\n             */\n\t\t\tMethod m2 = c.getMethod(\"print\");\n            Method m = c.getDeclaredMethod(\"print\", int.class,int.class);\n\t    \t\n            /*3.进行方法的反射操作\n             *可用o接返回值\n             *没有返回值即null\n             *setAccessible(AccessibleObject[] array, boolean flag) \n             *使用单一安全性检查（为了提高效率）\n             *为一组对象设置accessible标志的便捷方法。\n             *setAccessible(boolean flag) \n             *将单个对象的accessible标志设置为指示的布尔值。\n             */\n            a1.setAccessible(true);\n            Object o = a1.print(10, 20);\n            Object o = m.invoke(a1,new Object[]{10,20});\n            Object o = m.invoke(a1, 10,20);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\nclass A{\n\tpublic void print(){\n\t\tSystem.out.println(\"helloworld\");\n\t}\n\tprivate void print(int a,int b){\n\t\tSystem.out.println(a+b);\n\t}\n\tpublic void print(String a,String b){\n\t\tSystem.out.println(a.toUpperCase()+\",\"+b.toLowerCase());\n\t}\n}\n```\n\n\n\n\n","slug":"2018-Java反射","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrjv000a2yku2xh8bss3","content":"<blockquote>\n<p>Spring中IOC的核心原理，将文本转换成jvm对象的方法。【本文有待修善】</p>\n</blockquote>\n<h1 id=\"1-获取类信息\"><a href=\"#1-获取类信息\" class=\"headerlink\" title=\"1. 获取类信息\"></a>1. 获取类信息</h1><a id=\"more\"></a>\n\n<ol>\n<li>获取指定类对应的Class对象<ol>\n<li><code>Class c = ArrayList.class;</code></li>\n<li><code>Class c = list.getClass();</code></li>\n<li><code>Class c = Class.forName(&quot;java.util.ArrayList&quot;);//并加载指定的类</code></li>\n</ol>\n</li>\n<li>获取包名<br><code>String packageName = c.getPackage().getName();</code></li>\n<li>获取类的修饰符<br><code>int mod = c.getModifiers();</code><br><code>String modifier = Modifier.toString(mod);</code></li>\n<li>类的全限定名<br><code>String className = c.getName();</code></li>\n<li>父类<br><code>Class superC = c.getSuperclass();</code></li>\n<li>实现的接口<br><code>Class interfaces = c.getInterfaces();</code></li>\n<li>public变量/成员变量及操作<br><code>Field[] fields = c.getFields();</code><br><code>Field[] fields = c.getDeclaredFields();</code><br><code>Field field = c.getDeclaredField(&quot;变量名&quot;);</code><br><code>field.set(对象,&quot;变量值&quot;)</code></li>\n<li>构造方法<br><code>Constructor[] constructors = c.getDeclaredConstructors();</code></li>\n<li>public方法(包括父类)/自己的的成员方法<br><code>Method[] methods = c.getMethods();</code><br><code>Method[] methods = c.getDeclaredMethods();</code></li>\n<li>通过类的类类型创建该类的对象实例<br><code>String str = (String)c1.newInstance();//需要有无参数的构造方法</code></li>\n</ol>\n<h1 id=\"2-创建对象\"><a href=\"#2-创建对象\" class=\"headerlink\" title=\"2. 创建对象\"></a>2. 创建对象</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c &#x3D; Class.forName(&quot;java.util.ArrayList&quot;);</span><br><span class=\"line\">List list &#x3D; (List)c.newInstance();</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-方法反射\"><a href=\"#3-方法反射\" class=\"headerlink\" title=\"3. 方法反射\"></a>3. 方法反射</h1><p><code>方法对象.invoke(类对象,参数表);</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MethodDemo1 &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">        &#x2F;**目标：要获取print(int,int)方法</span><br><span class=\"line\">         *获取一个方法就要获取类的信息</span><br><span class=\"line\">         *1.获取类的信息首先要获取类的类类型</span><br><span class=\"line\">         *&#x2F;</span><br><span class=\"line\">\t\tA a1 &#x3D; new A();</span><br><span class=\"line\">\t\tClass c &#x3D; a1.getClass();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            &#x2F;*2.获取方法 名称和参数列表来决定  </span><br><span class=\"line\">             * getMethod获取的是public的方法</span><br><span class=\"line\">             * getDeclaredMethod自己声明的方法</span><br><span class=\"line\">             *&#x2F;</span><br><span class=\"line\">\t\t\tMethod m2 &#x3D; c.getMethod(&quot;print&quot;);</span><br><span class=\"line\">            Method m &#x3D; c.getDeclaredMethod(&quot;print&quot;, int.class,int.class);</span><br><span class=\"line\">\t    \t</span><br><span class=\"line\">            &#x2F;*3.进行方法的反射操作</span><br><span class=\"line\">             *可用o接返回值</span><br><span class=\"line\">             *没有返回值即null</span><br><span class=\"line\">             *setAccessible(AccessibleObject[] array, boolean flag) </span><br><span class=\"line\">             *使用单一安全性检查（为了提高效率）</span><br><span class=\"line\">             *为一组对象设置accessible标志的便捷方法。</span><br><span class=\"line\">             *setAccessible(boolean flag) </span><br><span class=\"line\">             *将单个对象的accessible标志设置为指示的布尔值。</span><br><span class=\"line\">             *&#x2F;</span><br><span class=\"line\">            a1.setAccessible(true);</span><br><span class=\"line\">            Object o &#x3D; a1.print(10, 20);</span><br><span class=\"line\">            Object o &#x3D; m.invoke(a1,new Object[]&#123;10,20&#125;);</span><br><span class=\"line\">            Object o &#x3D; m.invoke(a1, 10,20);</span><br><span class=\"line\">\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class A&#123;</span><br><span class=\"line\">\tpublic void print()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;helloworld&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprivate void print(int a,int b)&#123;</span><br><span class=\"line\">\t\tSystem.out.println(a+b);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic void print(String a,String b)&#123;</span><br><span class=\"line\">\t\tSystem.out.println(a.toUpperCase()+&quot;,&quot;+b.toLowerCase());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Spring中IOC的核心原理，将文本转换成jvm对象的方法。【本文有待修善】</p>\n</blockquote>\n<h1 id=\"1-获取类信息\"><a href=\"#1-获取类信息\" class=\"headerlink\" title=\"1. 获取类信息\"></a>1. 获取类信息</h1>","more":"<ol>\n<li>获取指定类对应的Class对象<ol>\n<li><code>Class c = ArrayList.class;</code></li>\n<li><code>Class c = list.getClass();</code></li>\n<li><code>Class c = Class.forName(&quot;java.util.ArrayList&quot;);//并加载指定的类</code></li>\n</ol>\n</li>\n<li>获取包名<br><code>String packageName = c.getPackage().getName();</code></li>\n<li>获取类的修饰符<br><code>int mod = c.getModifiers();</code><br><code>String modifier = Modifier.toString(mod);</code></li>\n<li>类的全限定名<br><code>String className = c.getName();</code></li>\n<li>父类<br><code>Class superC = c.getSuperclass();</code></li>\n<li>实现的接口<br><code>Class interfaces = c.getInterfaces();</code></li>\n<li>public变量/成员变量及操作<br><code>Field[] fields = c.getFields();</code><br><code>Field[] fields = c.getDeclaredFields();</code><br><code>Field field = c.getDeclaredField(&quot;变量名&quot;);</code><br><code>field.set(对象,&quot;变量值&quot;)</code></li>\n<li>构造方法<br><code>Constructor[] constructors = c.getDeclaredConstructors();</code></li>\n<li>public方法(包括父类)/自己的的成员方法<br><code>Method[] methods = c.getMethods();</code><br><code>Method[] methods = c.getDeclaredMethods();</code></li>\n<li>通过类的类类型创建该类的对象实例<br><code>String str = (String)c1.newInstance();//需要有无参数的构造方法</code></li>\n</ol>\n<h1 id=\"2-创建对象\"><a href=\"#2-创建对象\" class=\"headerlink\" title=\"2. 创建对象\"></a>2. 创建对象</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c &#x3D; Class.forName(&quot;java.util.ArrayList&quot;);</span><br><span class=\"line\">List list &#x3D; (List)c.newInstance();</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-方法反射\"><a href=\"#3-方法反射\" class=\"headerlink\" title=\"3. 方法反射\"></a>3. 方法反射</h1><p><code>方法对象.invoke(类对象,参数表);</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MethodDemo1 &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">        &#x2F;**目标：要获取print(int,int)方法</span><br><span class=\"line\">         *获取一个方法就要获取类的信息</span><br><span class=\"line\">         *1.获取类的信息首先要获取类的类类型</span><br><span class=\"line\">         *&#x2F;</span><br><span class=\"line\">\t\tA a1 &#x3D; new A();</span><br><span class=\"line\">\t\tClass c &#x3D; a1.getClass();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            &#x2F;*2.获取方法 名称和参数列表来决定  </span><br><span class=\"line\">             * getMethod获取的是public的方法</span><br><span class=\"line\">             * getDeclaredMethod自己声明的方法</span><br><span class=\"line\">             *&#x2F;</span><br><span class=\"line\">\t\t\tMethod m2 &#x3D; c.getMethod(&quot;print&quot;);</span><br><span class=\"line\">            Method m &#x3D; c.getDeclaredMethod(&quot;print&quot;, int.class,int.class);</span><br><span class=\"line\">\t    \t</span><br><span class=\"line\">            &#x2F;*3.进行方法的反射操作</span><br><span class=\"line\">             *可用o接返回值</span><br><span class=\"line\">             *没有返回值即null</span><br><span class=\"line\">             *setAccessible(AccessibleObject[] array, boolean flag) </span><br><span class=\"line\">             *使用单一安全性检查（为了提高效率）</span><br><span class=\"line\">             *为一组对象设置accessible标志的便捷方法。</span><br><span class=\"line\">             *setAccessible(boolean flag) </span><br><span class=\"line\">             *将单个对象的accessible标志设置为指示的布尔值。</span><br><span class=\"line\">             *&#x2F;</span><br><span class=\"line\">            a1.setAccessible(true);</span><br><span class=\"line\">            Object o &#x3D; a1.print(10, 20);</span><br><span class=\"line\">            Object o &#x3D; m.invoke(a1,new Object[]&#123;10,20&#125;);</span><br><span class=\"line\">            Object o &#x3D; m.invoke(a1, 10,20);</span><br><span class=\"line\">\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class A&#123;</span><br><span class=\"line\">\tpublic void print()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;helloworld&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprivate void print(int a,int b)&#123;</span><br><span class=\"line\">\t\tSystem.out.println(a+b);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic void print(String a,String b)&#123;</span><br><span class=\"line\">\t\tSystem.out.println(a.toUpperCase()+&quot;,&quot;+b.toLowerCase());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Node.js入门笔记","date":"2018-07-19T01:27:00.000Z","updated":"2018-07-19T01:27:00.000Z","_content":"> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。\n> Node + React 开发真的好方便~\n\n<!-- more -->\n\n# 1. NPM\n- 安装：`npm install <Module Name>@可空版本号`\n- 使用：`var express = require('express');`\n- 本地安装 装在CLI当前目录 node_modules 下；全局安装 装在node下\n- 更新：`npm update express`\n- 淘宝镜像：`npm install -g cnpm --registry=https://registry.npm.taobao.org`\n    使用：`cnpm install [name]`\n\n# 2. Sundry\n- Node.js 基本上所有的事件机制都是用设计模式中**观察者模式**实现\n    当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新\n- Node.js 异步编程的直接体现就是回调，Node 所有 API 都支持回调函数。\n\n# 3. 创建服务器\n```\n//添加http依赖\nvar http = require(\"http\");\n\n//创建服务器（匿名形式写入回调）\nhttp.createServer(function(request, response) {\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(\"Hello World\");\n    response.end();\n}).listen(8888);\n```\n\n# 4. 文件操作file system\n1. 读写文件\n    ```\n    const fs = require('fs');\n    \n    //readFile(文件名,function(err,data))\n    fs.readFile('aaa.txt',function(err,data){\n        if(err){\n            console.log('读取失败');\n        }else{\n            console.log(data.toString());\n        }\n    });\n    \n    //writeFile(文件名,内容,function(err))\n    fs.writeFile('bbb.txt','123',function(err){\n        console.log(err);\n    });\n    ```\n2. 打开文件\n    > fs.open(path, flags[, mode], callback)\n    \n    - path - 文件的路径。\n    - flags - 文件打开的行为。具体值详见下文。\n    - mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。\n    - callback - 回调函数，带有两个参数如：callback(err, fd)。\n    ```\n    var fs = require(\"fs\");\n    \n    // 异步打开文件\n    console.log(\"准备打开文件！\");\n    fs.open('input.txt', 'r+', function(err, fd) {\n       if (err) {\n           return console.error(err);\n       }\n      console.log(\"文件打开成功！\");     \n    });\n    ```\n3. 获取文件信息\n    > fs.stat(path, callback)\n\n    ```\n    var fs = require('fs');\n    \n    fs.stat('/Users/liuht/code/itbilu/demo/fs.js', function (err, stats) {\n        console.log(stats.isFile());         //true\n    })\n    ```\n4. 关闭文件\n\n    ```\n    fs.close(fd, function(err){\n        if (err){\n            console.log(err);\n        }\n        console.log(\"文件关闭成功\");\n    });\n    ```\n\n# 5. http数据解析\n## 5.1 GET解析\n- querystring解析(亦用于POST)\n```\nconst querystring = require('querystring');\n\njson = querystring.parse('user=blue&pass=12345&age=18');\nconsole.log(json);\n>> { user: 'blue', pass: '12345', age: '18' }\n```\n- url解析\n```\nconst urlLib = require('url');\n//二参：是否把query进行query转换\nvar obj=urlLib.parse('http://www.zjn.com/index?a=123&b=654',true);\nconsole.log(obj);\n\n>>  Url {\n    protocol: 'http:',\n    slashes: true,\n    auth: null,\n    host: 'www.zjn.com',\n    port: null,\n    hostname: 'www.zjn.com',\n    hash: null,\n    search: '?a=123&b=654',\n    query: { a: '123', b: '654' },\n    pathname: '/index',\n    path: '/index?a=123&b=654',\n    href: 'http://www.zjn.com/index?a=123&b=654' }\n```\n\n## 5.2 POST\n```\nconst http = require('http');\nconst querystring = require('querystring');\n\nhttp.createServer(function(req,res){\n    //POST-req分段发送\n    var str='';\n    //data-有一段数据到达(多次)\n    var i=0;\n    req.on('data',function(data){\n        console.log(`第${i++}次收数据`)\n        str+=data;\n    });\n    //end-数据全部到达标记(一次)\n    req.on('end',function(){\n        var POST=querystring.parse(str);\n        console.log(POST);\n    });\n}).listen(8080);\n```\n\n# 6. 模块\n## 6.1 自定义模块\n```\n//mod.js\nvar a = 12;\nexports.b = 23;//输出的对象加前缀exports.\nmodule.exports={b,c=2,d=4};//批量输出\n//1.js\nconst mod1 = require('./mod');//模块在node_modules目录下时./可省\nconsole.log(mod1.a);\nconsole.log(mod1.b);\n\n//输出：\nundefined\n23\n```\n\n# 7. [事件][1]\n## 7.1 事件绑定\n> eventEmitter.on(event, listener)为事件绑定监听器,监听器为回调函数\n> .emit(event, [arg1],[arg2], [...])触发,参数为监听器参数\n> .once(event,listener)一次性监听器\n\n```\n// 引入 events 模块\nvar events = require('events');\n// 创建 事件触发器 对象\nvar eventEmitter = new events.EventEmitter();\n\n// 2.创建事件处理程序\nvar connectHandler = function connected() {\n    console.log('1.连接成功。');\n    // 3.触发 data_received 事件\n    eventEmitter.emit('data_received');\n}\n\n// 绑定 connection 事件处理程序\neventEmitter.on('connection', connectHandler);\n// 绑定 data_received 事件(使用匿名函数)\neventEmitter.on('data_received', function () {\n    console.log('2.数据接收成功。');\n});\n\n// 1.触发 connection 事件 \neventEmitter.emit('connection');\n\nconsole.log(\"3.程序执行完毕。\");\n```\n> 输出：\n> $ node main.js\n> 1.连接成功。\n> 2.数据接收成功。\n> 3.程序执行完毕。\n\n## 7.2 error 事件\n内置，一般要为会触发 error 事件的对象设置监听器，避免程序崩溃\n```\nreaderStream.on('error', function(err){\n   console.log(err.stack);\n});\n```\n\n# 8. Buffer\n1. 编码\n    ```\n    //用from创建buffer对象（安全）\n    const buf = Buffer.from('runoob', 'ascii');\n    \n    // 输出 72756e6f6f62\n    console.log(buf.toString('hex'));\n    \n    // 输出 cnVub29i\n    console.log(buf.toString('base64'));\n    ```\n2. 写入缓冲区\n    ```\n    buf.write(string[, offset[, length]][, encoding])\n    ```\n    \n    > string - 写入缓冲区的字符串。\n    > offset - 缓冲区开始写入的索引值，默认为 0 。\n    > length - 写入的字节数，默认为 buffer.length\n    > encoding - 使用的编码。默认为 'utf8' 。\n    > 返回实际写入的大小\n\n# 9. Stream\n- 所有的 Stream 对象都是 EventEmitter 的实例。\n## 9.1 从文件读入流\n```\nvar fs = require(\"fs\");\nvar data = '';\n\n// 创建可读流\nvar readerStream = fs.createReadStream('input.txt');\n\n// 设置编码为 utf8。\nreaderStream.setEncoding('UTF8');\n\n// 处理流事件 --> data, end, and error\nreaderStream.on('data', function(chunk) {\n   data += chunk;\n});\n\nreaderStream.on('end',function(){\n   console.log(data);\n});\n\nreaderStream.on('error', function(err){\n   console.log(err.stack);\n});\n\nconsole.log(\"程序执行完毕\");\n```\n> 程序执行完毕\n> &input.txt的内容\n\n## 9.2 写入流到文件\n```\nvar fs = require(\"fs\");\nvar data = '菜鸟教程官网地址：www.runoob.com';\n\n// 创建一个可以写入的流，写入到文件 output.txt 中\nvar writerStream = fs.createWriteStream('output.txt');\n\n// 使用 utf8 编码写入数据\nwriterStream.write(data,'UTF8');\n\n// 标记文件末尾\nwriterStream.end();\n\n// 处理流事件 --> data, end, and error\nwriterStream.on('finish', function() {\n    console.log(\"写入完成。\");\n});\n\nwriterStream.on('error', function(err){\n   console.log(err.stack);\n});\n```\n\n## 9.3 管道流\n- 从一个流中获取数据并将数据传递到另外一个流中。\n![此处输入图片的描述][2]\n```\nvar fs = require(\"fs\");\n\n// 创建一个可读流\nvar readerStream = fs.createReadStream('input.txt');\n\n// 创建一个可写流\nvar writerStream = fs.createWriteStream('output.txt');\n\n// 管道读写操作\n// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中\nreaderStream.pipe(writerStream);\n\nconsole.log(\"程序执行完毕\");\n```\n\n## 9.4 链式流\n: 创建多个流操作链，一般用于管道操作。\n- 压缩文件\n```\nvar fs = require(\"fs\");\nvar zlib = require('zlib');\n\n// 压缩 input.txt 文件为 input.txt.gz\nfs.createReadStream('input.txt')\n  .pipe(zlib.createGzip())\n  .pipe(fs.createWriteStream('input.txt.gz'));\n  \nconsole.log(\"文件压缩完成。\");\n```\n- 解压文件\n```\nvar fs = require(\"fs\");\nvar zlib = require('zlib');\n\n// 解压 input.txt.gz 文件为 input.txt\nfs.createReadStream('input.txt.gz')\n  .pipe(zlib.createGunzip())\n  .pipe(fs.createWriteStream('input.txt'));\n  \nconsole.log(\"文件解压完成。\");\n```\n\n# 10. express\n非侵入性：保留了原生的功能，添加了一些方法。\n只提供最简单的功能，使用中间件(插件)拓展功能。\n链式操作：多次用`server.use`对请求进行处理(7.3)\n\n- query方法解析get请求：\n```\n//1.添加依赖\nconst express = require('express');\n//2.创建服务\nvar server=express();\n//3.use添加响应，处理请求\nserver.get('/login',function(req,res){\n    //内置query方法\n    var user = req.query['user'];\n    res.send('欢迎'+user,200);//send比原生的write功能更强大，可以放各种类型参数\n    res.end();\n});\n//4.监听端口\nserver.listen(8080);\n```\n## 10.1 三种方法\n- .get() - 处理get请求\n- .post() - 处理post请求\n- .all() - 可处理所有请求\n\n## 10.2 静态资源\n- express-static\n```\nconst express = require('express');\n//1.添加依赖\nconst expressStatic = require('express-static');\n\nvar server = express();\nserver.listen(8080);\n\n//2.use使用插件\n//指定静态资源目录，可从url直接访问\nserver.use(expressStatic('./www'));\n```\n## 10.3 GET/POST解析\n- GET:exoress中req.query['user']直接解析\n- POST:\n    - 用body-parser\n    ```\n    const bosyParser=require('body-parser');\n    \n    //use函数无路径参数时，指接受所有请求\n    server.use(bodyParser.urlencoded({\n    extended:false,     //扩展模式：默认为true，不建议\n    limit:2*1024*1024   //2M\n    }));\n    srver.use('/',function(req,res){\n        console.log(req.body);//POST\n    });\n    ```\n    - 手动实现\n    ```\n    //server.js\n    const bodyParser2=require('./lib/my-body-paser');\n    server.use(bodyParser2);\n    srver.use('/',function(req,res){\n    console.log(reg.body);\n    });\n    \n    //my-body-parser.js\n    const querystring = require('querystring');\n    \n    module.exports=function(req,res,next){\n        var str = '';\n        req.on('data',function(data){\n            str+=data;\n        });\n        req.on('end',function(){\n            req.body=querystring.parse(str);\n            next();\n        });\n    }\n    ```\n\n## 10.4 链式操作\n```\nsrver.use('/',function(req,res,next){\n    console.log('a');\n    next();//让下一个处理者处理\n});\nsrver.use('/',function(req,res){\n    console.log('b');\n});\n```\n> a\nb\n\n# 11. Cookie & Seesion\n## 11.1 设置、删除Cookie\n```\nserver.use('/aaa/a.html', function (req, res) {\n    //path：在此目录下生效，maxAge：生存毫秒\n    res.cookie('user', 'blue', {path: '/aaa', maxAge: 30 * 24 * 3600 * 1000});\n    //删除\n    res.clearCookie('user');\n    \n    res.send('ok');\n});\n```\n\n## 11.2 读取Cookie\n```\n//依赖cookie-parser\nconst cookieParser = require('cookie-parser');\n\nserver.use(cookieParser());\n\nserver.use('/', function (req, res) {\n    console.log(req.cookies);\n    \n    res.send('ok');\n});\n```\n\n## 11.3 签名Cookie\n```\n//依赖cookie-parser\nconst cookieParser = require('cookie-parser');\n//签名\nserver.use(cookieParser('wesdfw4r34tf'));\n\nserver.use('/', function (req, res){\n    res.cookie('user', 'blue', {signed: true});\n    //读取\n    console.log('签名cookie：', req.signedCookies);\n    console.log('无签名cookie：', req.cookies);\n    \n    res.send('ok');\n});\n```\n\n## 11.4 Session\n- 加密是强制的\n```\nconst cookieParser = require('cookie-parser');\nconst cookieSession = require('cookie-session');\n//密钥\nvar arr=[];\nfor(var i=0;i<10000;i++){\n  arr.push('sig_'+Math.random());\n}\n//会生成(session id)一个sess Cookie和一个sess.sig Cookie\nserver.use(cookieParser());\nserver.use(cookieSession({\n    name: 'sess',\n    keys: arr,\n    maxAge: 2 * 3600 * 1000\n}));\n\nserver.use('/', function (req, res) {\n    //读取、修改\n    if (req.session['count'] == null) {\n        req.session['count'] = 1;\n    } else if(req.session['count'] == 100) {\n        //删除\n        delete req.session;\n    } else {\n        req.session['count']++;\n    }\n    console.log(req.session['count']);\n\n    res.send('ok');\n});\n```\n\n# 12. 文件上传\n- 文件名会被自动重命名防重名\n```\nconst express = require('express');\nconst multer = require('multer');\nconst fs = require('fs');\n//解析路径\nconst pathLib = require('path');\n\nvar server = express();\n//指定存放路径和文件限制\nserver.use(multer({dest: './www/upload/'}).any());\n\nserver.post('/', function (req, res) {\n    //新文件名\n    var newName = req.files[0].path +\n        pathLib.parse(req.files[0].originalname).ext;\n    //重命名\n    fs.rename(req.files[0].path, newName, function (err) {\n        if (err)\n            res.send('上传失败');\n        else\n            res.send('成功');\n    });\n});\n\nserver.listen(8080);\n```\n\n# 13. 数据库\nmysql库的connection连接之后不要断开，不然后面无法再使用。可用连接池。\n## 13.1 查\n```\nvar mysql  = require('mysql');  \n\nvar connection = mysql.createConnection({     \n    host     : 'localhost',       \n    user     : 'root',              \n    password : '123456',       \n    port: '3306',                   \n    database: 'test', \n}); \n//连\nconnection.connect();\n\nvar sql = 'SELECT * FROM websites';\n//查\nconnection.query(sql,function (err, result) {\n        if(err){\n          console.log('[SELECT ERROR] - ',err.message);\n          return;\n        }\n \n       console.log('-----------SELECT-----------');\n       console.log(result);\n       console.log('----------------------------\\n\\n');  \n});\n//断\nconnection.end();\n```\n\n## 13.2 增\n```\nvar addSql = 'INSERT INTO websites(Id,name,url,alexa,country) VALUES(0,?,?,?,?)';\nvar addSqlParams = ['菜鸟工具', 'https://c.runoob.com','23453', 'CN'];\n//增\nconnection.query(addSql,addSqlParams,function (err, result) {\n    if(err){\n        console.log('[INSERT ERROR] - ',err.message);\n        return;\n    }        \n    \n    console.log('-------------INSERT---------------');\n    //console.log('INSERT ID:',result.insertId);        \n    console.log('INSERT ID:',result);        \n    console.log('----------------------------------\\n\\n');  \n});\n```\n\n## 13.3 改\n```\nvar modSql = 'UPDATE websites SET name = ?,url = ? WHERE Id = ?';\nvar modSqlParams = ['菜鸟移动站', 'https://m.runoob.com',6];\n//改\nconnection.query(modSql,modSqlParams,function (err, result) {\n    if(err){\n        console.log('[UPDATE ERROR] - ',err.message);\n        return;\n    }        \n    console.log('-----------UPDATE-----------');\n    console.log('UPDATE affectedRows',result.affectedRows);\n    console.log('----------------------------\\n\\n');\n});\n```\n\n## 13.4 删\n```\nvar delSql = 'DELETE FROM websites where id=6';\n//删\nconnection.query(delSql,function (err, result) {\n    if(err){\n        console.log('[DELETE ERROR] - ',err.message);\n        return;\n    }        \n    \n    console.log('-------------DELETE-------------');\n    console.log('DELETE affectedRows',result.affectedRows);\n    console.log('--------------------------------\\n\\n');  \n});\n```\n\n## 13.5 连接池\n```\nvar mysql = require('mysql');\nvar pool  = mysql.createPool({\n    host: '',\n    user: '',\n    password: '',\n    port: '',\n    database: '',\n});\n\nexports.query = function(sql, cb){\n    pool.getConnection(function(err, connection) {\n        connection.query(sql, cb);\n        connection.release();\n    });\n}\n```\n\n  [1]: https://www.runoob.com/nodejs/nodejs-event.html\n  [2]: http://www.runoob.com/wp-content/uploads/2015/09/bVcla61","source":"_posts/2018/Node.js入门笔记.md","raw":"---\ntitle: Node.js入门笔记\ndate: 2018-07-19 09:27\nupdated: 2018-07-19 09:27\ntags: Node.js\n---\n> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。\n> Node + React 开发真的好方便~\n\n<!-- more -->\n\n# 1. NPM\n- 安装：`npm install <Module Name>@可空版本号`\n- 使用：`var express = require('express');`\n- 本地安装 装在CLI当前目录 node_modules 下；全局安装 装在node下\n- 更新：`npm update express`\n- 淘宝镜像：`npm install -g cnpm --registry=https://registry.npm.taobao.org`\n    使用：`cnpm install [name]`\n\n# 2. Sundry\n- Node.js 基本上所有的事件机制都是用设计模式中**观察者模式**实现\n    当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新\n- Node.js 异步编程的直接体现就是回调，Node 所有 API 都支持回调函数。\n\n# 3. 创建服务器\n```\n//添加http依赖\nvar http = require(\"http\");\n\n//创建服务器（匿名形式写入回调）\nhttp.createServer(function(request, response) {\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(\"Hello World\");\n    response.end();\n}).listen(8888);\n```\n\n# 4. 文件操作file system\n1. 读写文件\n    ```\n    const fs = require('fs');\n    \n    //readFile(文件名,function(err,data))\n    fs.readFile('aaa.txt',function(err,data){\n        if(err){\n            console.log('读取失败');\n        }else{\n            console.log(data.toString());\n        }\n    });\n    \n    //writeFile(文件名,内容,function(err))\n    fs.writeFile('bbb.txt','123',function(err){\n        console.log(err);\n    });\n    ```\n2. 打开文件\n    > fs.open(path, flags[, mode], callback)\n    \n    - path - 文件的路径。\n    - flags - 文件打开的行为。具体值详见下文。\n    - mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。\n    - callback - 回调函数，带有两个参数如：callback(err, fd)。\n    ```\n    var fs = require(\"fs\");\n    \n    // 异步打开文件\n    console.log(\"准备打开文件！\");\n    fs.open('input.txt', 'r+', function(err, fd) {\n       if (err) {\n           return console.error(err);\n       }\n      console.log(\"文件打开成功！\");     \n    });\n    ```\n3. 获取文件信息\n    > fs.stat(path, callback)\n\n    ```\n    var fs = require('fs');\n    \n    fs.stat('/Users/liuht/code/itbilu/demo/fs.js', function (err, stats) {\n        console.log(stats.isFile());         //true\n    })\n    ```\n4. 关闭文件\n\n    ```\n    fs.close(fd, function(err){\n        if (err){\n            console.log(err);\n        }\n        console.log(\"文件关闭成功\");\n    });\n    ```\n\n# 5. http数据解析\n## 5.1 GET解析\n- querystring解析(亦用于POST)\n```\nconst querystring = require('querystring');\n\njson = querystring.parse('user=blue&pass=12345&age=18');\nconsole.log(json);\n>> { user: 'blue', pass: '12345', age: '18' }\n```\n- url解析\n```\nconst urlLib = require('url');\n//二参：是否把query进行query转换\nvar obj=urlLib.parse('http://www.zjn.com/index?a=123&b=654',true);\nconsole.log(obj);\n\n>>  Url {\n    protocol: 'http:',\n    slashes: true,\n    auth: null,\n    host: 'www.zjn.com',\n    port: null,\n    hostname: 'www.zjn.com',\n    hash: null,\n    search: '?a=123&b=654',\n    query: { a: '123', b: '654' },\n    pathname: '/index',\n    path: '/index?a=123&b=654',\n    href: 'http://www.zjn.com/index?a=123&b=654' }\n```\n\n## 5.2 POST\n```\nconst http = require('http');\nconst querystring = require('querystring');\n\nhttp.createServer(function(req,res){\n    //POST-req分段发送\n    var str='';\n    //data-有一段数据到达(多次)\n    var i=0;\n    req.on('data',function(data){\n        console.log(`第${i++}次收数据`)\n        str+=data;\n    });\n    //end-数据全部到达标记(一次)\n    req.on('end',function(){\n        var POST=querystring.parse(str);\n        console.log(POST);\n    });\n}).listen(8080);\n```\n\n# 6. 模块\n## 6.1 自定义模块\n```\n//mod.js\nvar a = 12;\nexports.b = 23;//输出的对象加前缀exports.\nmodule.exports={b,c=2,d=4};//批量输出\n//1.js\nconst mod1 = require('./mod');//模块在node_modules目录下时./可省\nconsole.log(mod1.a);\nconsole.log(mod1.b);\n\n//输出：\nundefined\n23\n```\n\n# 7. [事件][1]\n## 7.1 事件绑定\n> eventEmitter.on(event, listener)为事件绑定监听器,监听器为回调函数\n> .emit(event, [arg1],[arg2], [...])触发,参数为监听器参数\n> .once(event,listener)一次性监听器\n\n```\n// 引入 events 模块\nvar events = require('events');\n// 创建 事件触发器 对象\nvar eventEmitter = new events.EventEmitter();\n\n// 2.创建事件处理程序\nvar connectHandler = function connected() {\n    console.log('1.连接成功。');\n    // 3.触发 data_received 事件\n    eventEmitter.emit('data_received');\n}\n\n// 绑定 connection 事件处理程序\neventEmitter.on('connection', connectHandler);\n// 绑定 data_received 事件(使用匿名函数)\neventEmitter.on('data_received', function () {\n    console.log('2.数据接收成功。');\n});\n\n// 1.触发 connection 事件 \neventEmitter.emit('connection');\n\nconsole.log(\"3.程序执行完毕。\");\n```\n> 输出：\n> $ node main.js\n> 1.连接成功。\n> 2.数据接收成功。\n> 3.程序执行完毕。\n\n## 7.2 error 事件\n内置，一般要为会触发 error 事件的对象设置监听器，避免程序崩溃\n```\nreaderStream.on('error', function(err){\n   console.log(err.stack);\n});\n```\n\n# 8. Buffer\n1. 编码\n    ```\n    //用from创建buffer对象（安全）\n    const buf = Buffer.from('runoob', 'ascii');\n    \n    // 输出 72756e6f6f62\n    console.log(buf.toString('hex'));\n    \n    // 输出 cnVub29i\n    console.log(buf.toString('base64'));\n    ```\n2. 写入缓冲区\n    ```\n    buf.write(string[, offset[, length]][, encoding])\n    ```\n    \n    > string - 写入缓冲区的字符串。\n    > offset - 缓冲区开始写入的索引值，默认为 0 。\n    > length - 写入的字节数，默认为 buffer.length\n    > encoding - 使用的编码。默认为 'utf8' 。\n    > 返回实际写入的大小\n\n# 9. Stream\n- 所有的 Stream 对象都是 EventEmitter 的实例。\n## 9.1 从文件读入流\n```\nvar fs = require(\"fs\");\nvar data = '';\n\n// 创建可读流\nvar readerStream = fs.createReadStream('input.txt');\n\n// 设置编码为 utf8。\nreaderStream.setEncoding('UTF8');\n\n// 处理流事件 --> data, end, and error\nreaderStream.on('data', function(chunk) {\n   data += chunk;\n});\n\nreaderStream.on('end',function(){\n   console.log(data);\n});\n\nreaderStream.on('error', function(err){\n   console.log(err.stack);\n});\n\nconsole.log(\"程序执行完毕\");\n```\n> 程序执行完毕\n> &input.txt的内容\n\n## 9.2 写入流到文件\n```\nvar fs = require(\"fs\");\nvar data = '菜鸟教程官网地址：www.runoob.com';\n\n// 创建一个可以写入的流，写入到文件 output.txt 中\nvar writerStream = fs.createWriteStream('output.txt');\n\n// 使用 utf8 编码写入数据\nwriterStream.write(data,'UTF8');\n\n// 标记文件末尾\nwriterStream.end();\n\n// 处理流事件 --> data, end, and error\nwriterStream.on('finish', function() {\n    console.log(\"写入完成。\");\n});\n\nwriterStream.on('error', function(err){\n   console.log(err.stack);\n});\n```\n\n## 9.3 管道流\n- 从一个流中获取数据并将数据传递到另外一个流中。\n![此处输入图片的描述][2]\n```\nvar fs = require(\"fs\");\n\n// 创建一个可读流\nvar readerStream = fs.createReadStream('input.txt');\n\n// 创建一个可写流\nvar writerStream = fs.createWriteStream('output.txt');\n\n// 管道读写操作\n// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中\nreaderStream.pipe(writerStream);\n\nconsole.log(\"程序执行完毕\");\n```\n\n## 9.4 链式流\n: 创建多个流操作链，一般用于管道操作。\n- 压缩文件\n```\nvar fs = require(\"fs\");\nvar zlib = require('zlib');\n\n// 压缩 input.txt 文件为 input.txt.gz\nfs.createReadStream('input.txt')\n  .pipe(zlib.createGzip())\n  .pipe(fs.createWriteStream('input.txt.gz'));\n  \nconsole.log(\"文件压缩完成。\");\n```\n- 解压文件\n```\nvar fs = require(\"fs\");\nvar zlib = require('zlib');\n\n// 解压 input.txt.gz 文件为 input.txt\nfs.createReadStream('input.txt.gz')\n  .pipe(zlib.createGunzip())\n  .pipe(fs.createWriteStream('input.txt'));\n  \nconsole.log(\"文件解压完成。\");\n```\n\n# 10. express\n非侵入性：保留了原生的功能，添加了一些方法。\n只提供最简单的功能，使用中间件(插件)拓展功能。\n链式操作：多次用`server.use`对请求进行处理(7.3)\n\n- query方法解析get请求：\n```\n//1.添加依赖\nconst express = require('express');\n//2.创建服务\nvar server=express();\n//3.use添加响应，处理请求\nserver.get('/login',function(req,res){\n    //内置query方法\n    var user = req.query['user'];\n    res.send('欢迎'+user,200);//send比原生的write功能更强大，可以放各种类型参数\n    res.end();\n});\n//4.监听端口\nserver.listen(8080);\n```\n## 10.1 三种方法\n- .get() - 处理get请求\n- .post() - 处理post请求\n- .all() - 可处理所有请求\n\n## 10.2 静态资源\n- express-static\n```\nconst express = require('express');\n//1.添加依赖\nconst expressStatic = require('express-static');\n\nvar server = express();\nserver.listen(8080);\n\n//2.use使用插件\n//指定静态资源目录，可从url直接访问\nserver.use(expressStatic('./www'));\n```\n## 10.3 GET/POST解析\n- GET:exoress中req.query['user']直接解析\n- POST:\n    - 用body-parser\n    ```\n    const bosyParser=require('body-parser');\n    \n    //use函数无路径参数时，指接受所有请求\n    server.use(bodyParser.urlencoded({\n    extended:false,     //扩展模式：默认为true，不建议\n    limit:2*1024*1024   //2M\n    }));\n    srver.use('/',function(req,res){\n        console.log(req.body);//POST\n    });\n    ```\n    - 手动实现\n    ```\n    //server.js\n    const bodyParser2=require('./lib/my-body-paser');\n    server.use(bodyParser2);\n    srver.use('/',function(req,res){\n    console.log(reg.body);\n    });\n    \n    //my-body-parser.js\n    const querystring = require('querystring');\n    \n    module.exports=function(req,res,next){\n        var str = '';\n        req.on('data',function(data){\n            str+=data;\n        });\n        req.on('end',function(){\n            req.body=querystring.parse(str);\n            next();\n        });\n    }\n    ```\n\n## 10.4 链式操作\n```\nsrver.use('/',function(req,res,next){\n    console.log('a');\n    next();//让下一个处理者处理\n});\nsrver.use('/',function(req,res){\n    console.log('b');\n});\n```\n> a\nb\n\n# 11. Cookie & Seesion\n## 11.1 设置、删除Cookie\n```\nserver.use('/aaa/a.html', function (req, res) {\n    //path：在此目录下生效，maxAge：生存毫秒\n    res.cookie('user', 'blue', {path: '/aaa', maxAge: 30 * 24 * 3600 * 1000});\n    //删除\n    res.clearCookie('user');\n    \n    res.send('ok');\n});\n```\n\n## 11.2 读取Cookie\n```\n//依赖cookie-parser\nconst cookieParser = require('cookie-parser');\n\nserver.use(cookieParser());\n\nserver.use('/', function (req, res) {\n    console.log(req.cookies);\n    \n    res.send('ok');\n});\n```\n\n## 11.3 签名Cookie\n```\n//依赖cookie-parser\nconst cookieParser = require('cookie-parser');\n//签名\nserver.use(cookieParser('wesdfw4r34tf'));\n\nserver.use('/', function (req, res){\n    res.cookie('user', 'blue', {signed: true});\n    //读取\n    console.log('签名cookie：', req.signedCookies);\n    console.log('无签名cookie：', req.cookies);\n    \n    res.send('ok');\n});\n```\n\n## 11.4 Session\n- 加密是强制的\n```\nconst cookieParser = require('cookie-parser');\nconst cookieSession = require('cookie-session');\n//密钥\nvar arr=[];\nfor(var i=0;i<10000;i++){\n  arr.push('sig_'+Math.random());\n}\n//会生成(session id)一个sess Cookie和一个sess.sig Cookie\nserver.use(cookieParser());\nserver.use(cookieSession({\n    name: 'sess',\n    keys: arr,\n    maxAge: 2 * 3600 * 1000\n}));\n\nserver.use('/', function (req, res) {\n    //读取、修改\n    if (req.session['count'] == null) {\n        req.session['count'] = 1;\n    } else if(req.session['count'] == 100) {\n        //删除\n        delete req.session;\n    } else {\n        req.session['count']++;\n    }\n    console.log(req.session['count']);\n\n    res.send('ok');\n});\n```\n\n# 12. 文件上传\n- 文件名会被自动重命名防重名\n```\nconst express = require('express');\nconst multer = require('multer');\nconst fs = require('fs');\n//解析路径\nconst pathLib = require('path');\n\nvar server = express();\n//指定存放路径和文件限制\nserver.use(multer({dest: './www/upload/'}).any());\n\nserver.post('/', function (req, res) {\n    //新文件名\n    var newName = req.files[0].path +\n        pathLib.parse(req.files[0].originalname).ext;\n    //重命名\n    fs.rename(req.files[0].path, newName, function (err) {\n        if (err)\n            res.send('上传失败');\n        else\n            res.send('成功');\n    });\n});\n\nserver.listen(8080);\n```\n\n# 13. 数据库\nmysql库的connection连接之后不要断开，不然后面无法再使用。可用连接池。\n## 13.1 查\n```\nvar mysql  = require('mysql');  \n\nvar connection = mysql.createConnection({     \n    host     : 'localhost',       \n    user     : 'root',              \n    password : '123456',       \n    port: '3306',                   \n    database: 'test', \n}); \n//连\nconnection.connect();\n\nvar sql = 'SELECT * FROM websites';\n//查\nconnection.query(sql,function (err, result) {\n        if(err){\n          console.log('[SELECT ERROR] - ',err.message);\n          return;\n        }\n \n       console.log('-----------SELECT-----------');\n       console.log(result);\n       console.log('----------------------------\\n\\n');  \n});\n//断\nconnection.end();\n```\n\n## 13.2 增\n```\nvar addSql = 'INSERT INTO websites(Id,name,url,alexa,country) VALUES(0,?,?,?,?)';\nvar addSqlParams = ['菜鸟工具', 'https://c.runoob.com','23453', 'CN'];\n//增\nconnection.query(addSql,addSqlParams,function (err, result) {\n    if(err){\n        console.log('[INSERT ERROR] - ',err.message);\n        return;\n    }        \n    \n    console.log('-------------INSERT---------------');\n    //console.log('INSERT ID:',result.insertId);        \n    console.log('INSERT ID:',result);        \n    console.log('----------------------------------\\n\\n');  \n});\n```\n\n## 13.3 改\n```\nvar modSql = 'UPDATE websites SET name = ?,url = ? WHERE Id = ?';\nvar modSqlParams = ['菜鸟移动站', 'https://m.runoob.com',6];\n//改\nconnection.query(modSql,modSqlParams,function (err, result) {\n    if(err){\n        console.log('[UPDATE ERROR] - ',err.message);\n        return;\n    }        \n    console.log('-----------UPDATE-----------');\n    console.log('UPDATE affectedRows',result.affectedRows);\n    console.log('----------------------------\\n\\n');\n});\n```\n\n## 13.4 删\n```\nvar delSql = 'DELETE FROM websites where id=6';\n//删\nconnection.query(delSql,function (err, result) {\n    if(err){\n        console.log('[DELETE ERROR] - ',err.message);\n        return;\n    }        \n    \n    console.log('-------------DELETE-------------');\n    console.log('DELETE affectedRows',result.affectedRows);\n    console.log('--------------------------------\\n\\n');  \n});\n```\n\n## 13.5 连接池\n```\nvar mysql = require('mysql');\nvar pool  = mysql.createPool({\n    host: '',\n    user: '',\n    password: '',\n    port: '',\n    database: '',\n});\n\nexports.query = function(sql, cb){\n    pool.getConnection(function(err, connection) {\n        connection.query(sql, cb);\n        connection.release();\n    });\n}\n```\n\n  [1]: https://www.runoob.com/nodejs/nodejs-event.html\n  [2]: http://www.runoob.com/wp-content/uploads/2015/09/bVcla61","slug":"2018-Node-js入门笔记","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrjw000d2ykudbu3cs7c","content":"<blockquote>\n<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>Node + React 开发真的好方便~</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h1 id=\"1-NPM\"><a href=\"#1-NPM\" class=\"headerlink\" title=\"1. NPM\"></a>1. NPM</h1><ul>\n<li>安装：<code>npm install &lt;Module Name&gt;@可空版本号</code></li>\n<li>使用：<code>var express = require(&#39;express&#39;);</code></li>\n<li>本地安装 装在CLI当前目录 node_modules 下；全局安装 装在node下</li>\n<li>更新：<code>npm update express</code></li>\n<li>淘宝镜像：<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code><br>  使用：<code>cnpm install [name]</code></li>\n</ul>\n<h1 id=\"2-Sundry\"><a href=\"#2-Sundry\" class=\"headerlink\" title=\"2. Sundry\"></a>2. Sundry</h1><ul>\n<li>Node.js 基本上所有的事件机制都是用设计模式中<strong>观察者模式</strong>实现<br>  当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</li>\n<li>Node.js 异步编程的直接体现就是回调，Node 所有 API 都支持回调函数。</li>\n</ul>\n<h1 id=\"3-创建服务器\"><a href=\"#3-创建服务器\" class=\"headerlink\" title=\"3. 创建服务器\"></a>3. 创建服务器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;添加http依赖</span><br><span class=\"line\">var http &#x3D; require(&quot;http&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;创建服务器（匿名形式写入回调）</span><br><span class=\"line\">http.createServer(function(request, response) &#123;</span><br><span class=\"line\">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text&#x2F;plain&quot;&#125;);</span><br><span class=\"line\">    response.write(&quot;Hello World&quot;);</span><br><span class=\"line\">    response.end();</span><br><span class=\"line\">&#125;).listen(8888);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-文件操作file-system\"><a href=\"#4-文件操作file-system\" class=\"headerlink\" title=\"4. 文件操作file system\"></a>4. 文件操作file system</h1><ol>\n<li><p>读写文件</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;readFile(文件名,function(err,data))</span><br><span class=\"line\">fs.readFile(&#39;aaa.txt&#39;,function(err,data)&#123;</span><br><span class=\"line\">    if(err)&#123;</span><br><span class=\"line\">        console.log(&#39;读取失败&#39;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        console.log(data.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;writeFile(文件名,内容,function(err))</span><br><span class=\"line\">fs.writeFile(&#39;bbb.txt&#39;,&#39;123&#39;,function(err)&#123;</span><br><span class=\"line\">    console.log(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li><p>打开文件</p>\n<blockquote>\n<p>fs.open(path, flags[, mode], callback)</p>\n</blockquote>\n<ul>\n<li>path - 文件的路径。</li>\n<li>flags - 文件打开的行为。具体值详见下文。</li>\n<li>mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。</li>\n<li>callback - 回调函数，带有两个参数如：callback(err, fd)。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 异步打开文件</span><br><span class=\"line\">console.log(&quot;准备打开文件！&quot;);</span><br><span class=\"line\">fs.open(&#39;input.txt&#39;, &#39;r+&#39;, function(err, fd) &#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  console.log(&quot;文件打开成功！&quot;);     </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>获取文件信息</p>\n<blockquote>\n<p>fs.stat(path, callback)</p>\n</blockquote>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.stat(&#39;&#x2F;Users&#x2F;liuht&#x2F;code&#x2F;itbilu&#x2F;demo&#x2F;fs.js&#39;, function (err, stats) &#123;</span><br><span class=\"line\">    console.log(stats.isFile());         &#x2F;&#x2F;true</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>关闭文件</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.close(fd, function(err)&#123;</span><br><span class=\"line\">    if (err)&#123;</span><br><span class=\"line\">        console.log(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(&quot;文件关闭成功&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h1 id=\"5-http数据解析\"><a href=\"#5-http数据解析\" class=\"headerlink\" title=\"5. http数据解析\"></a>5. http数据解析</h1><h2 id=\"5-1-GET解析\"><a href=\"#5-1-GET解析\" class=\"headerlink\" title=\"5.1 GET解析\"></a>5.1 GET解析</h2><ul>\n<li>querystring解析(亦用于POST)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const querystring &#x3D; require(&#39;querystring&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">json &#x3D; querystring.parse(&#39;user&#x3D;blue&amp;pass&#x3D;12345&amp;age&#x3D;18&#39;);</span><br><span class=\"line\">console.log(json);</span><br><span class=\"line\">&gt;&gt; &#123; user: &#39;blue&#39;, pass: &#39;12345&#39;, age: &#39;18&#39; &#125;</span><br></pre></td></tr></table></figure></li>\n<li>url解析<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const urlLib &#x3D; require(&#39;url&#39;);</span><br><span class=\"line\">&#x2F;&#x2F;二参：是否把query进行query转换</span><br><span class=\"line\">var obj&#x3D;urlLib.parse(&#39;http:&#x2F;&#x2F;www.zjn.com&#x2F;index?a&#x3D;123&amp;b&#x3D;654&#39;,true);</span><br><span class=\"line\">console.log(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;  Url &#123;</span><br><span class=\"line\">    protocol: &#39;http:&#39;,</span><br><span class=\"line\">    slashes: true,</span><br><span class=\"line\">    auth: null,</span><br><span class=\"line\">    host: &#39;www.zjn.com&#39;,</span><br><span class=\"line\">    port: null,</span><br><span class=\"line\">    hostname: &#39;www.zjn.com&#39;,</span><br><span class=\"line\">    hash: null,</span><br><span class=\"line\">    search: &#39;?a&#x3D;123&amp;b&#x3D;654&#39;,</span><br><span class=\"line\">    query: &#123; a: &#39;123&#39;, b: &#39;654&#39; &#125;,</span><br><span class=\"line\">    pathname: &#39;&#x2F;index&#39;,</span><br><span class=\"line\">    path: &#39;&#x2F;index?a&#x3D;123&amp;b&#x3D;654&#39;,</span><br><span class=\"line\">    href: &#39;http:&#x2F;&#x2F;www.zjn.com&#x2F;index?a&#x3D;123&amp;b&#x3D;654&#39; &#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"5-2-POST\"><a href=\"#5-2-POST\" class=\"headerlink\" title=\"5.2 POST\"></a>5.2 POST</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const http &#x3D; require(&#39;http&#39;);</span><br><span class=\"line\">const querystring &#x3D; require(&#39;querystring&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(function(req,res)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;POST-req分段发送</span><br><span class=\"line\">    var str&#x3D;&#39;&#39;;</span><br><span class=\"line\">    &#x2F;&#x2F;data-有一段数据到达(多次)</span><br><span class=\"line\">    var i&#x3D;0;</span><br><span class=\"line\">    req.on(&#39;data&#39;,function(data)&#123;</span><br><span class=\"line\">        console.log(&#96;第$&#123;i++&#125;次收数据&#96;)</span><br><span class=\"line\">        str+&#x3D;data;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &#x2F;&#x2F;end-数据全部到达标记(一次)</span><br><span class=\"line\">    req.on(&#39;end&#39;,function()&#123;</span><br><span class=\"line\">        var POST&#x3D;querystring.parse(str);</span><br><span class=\"line\">        console.log(POST);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;).listen(8080);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6-模块\"><a href=\"#6-模块\" class=\"headerlink\" title=\"6. 模块\"></a>6. 模块</h1><h2 id=\"6-1-自定义模块\"><a href=\"#6-1-自定义模块\" class=\"headerlink\" title=\"6.1 自定义模块\"></a>6.1 自定义模块</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;mod.js</span><br><span class=\"line\">var a &#x3D; 12;</span><br><span class=\"line\">exports.b &#x3D; 23;&#x2F;&#x2F;输出的对象加前缀exports.</span><br><span class=\"line\">module.exports&#x3D;&#123;b,c&#x3D;2,d&#x3D;4&#125;;&#x2F;&#x2F;批量输出</span><br><span class=\"line\">&#x2F;&#x2F;1.js</span><br><span class=\"line\">const mod1 &#x3D; require(&#39;.&#x2F;mod&#39;);&#x2F;&#x2F;模块在node_modules目录下时.&#x2F;可省</span><br><span class=\"line\">console.log(mod1.a);</span><br><span class=\"line\">console.log(mod1.b);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;输出：</span><br><span class=\"line\">undefined</span><br><span class=\"line\">23</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"7-事件\"><a href=\"#7-事件\" class=\"headerlink\" title=\"7. 事件\"></a>7. <a href=\"https://www.runoob.com/nodejs/nodejs-event.html\">事件</a></h1><h2 id=\"7-1-事件绑定\"><a href=\"#7-1-事件绑定\" class=\"headerlink\" title=\"7.1 事件绑定\"></a>7.1 事件绑定</h2><blockquote>\n<p>eventEmitter.on(event, listener)为事件绑定监听器,监听器为回调函数<br>.emit(event, [arg1],[arg2], […])触发,参数为监听器参数<br>.once(event,listener)一次性监听器</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 引入 events 模块</span><br><span class=\"line\">var events &#x3D; require(&#39;events&#39;);</span><br><span class=\"line\">&#x2F;&#x2F; 创建 事件触发器 对象</span><br><span class=\"line\">var eventEmitter &#x3D; new events.EventEmitter();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 2.创建事件处理程序</span><br><span class=\"line\">var connectHandler &#x3D; function connected() &#123;</span><br><span class=\"line\">    console.log(&#39;1.连接成功。&#39;);</span><br><span class=\"line\">    &#x2F;&#x2F; 3.触发 data_received 事件</span><br><span class=\"line\">    eventEmitter.emit(&#39;data_received&#39;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 绑定 connection 事件处理程序</span><br><span class=\"line\">eventEmitter.on(&#39;connection&#39;, connectHandler);</span><br><span class=\"line\">&#x2F;&#x2F; 绑定 data_received 事件(使用匿名函数)</span><br><span class=\"line\">eventEmitter.on(&#39;data_received&#39;, function () &#123;</span><br><span class=\"line\">    console.log(&#39;2.数据接收成功。&#39;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 1.触发 connection 事件 </span><br><span class=\"line\">eventEmitter.emit(&#39;connection&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;3.程序执行完毕。&quot;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出：<br>$ node main.js<br>1.连接成功。<br>2.数据接收成功。<br>3.程序执行完毕。</p>\n</blockquote>\n<h2 id=\"7-2-error-事件\"><a href=\"#7-2-error-事件\" class=\"headerlink\" title=\"7.2 error 事件\"></a>7.2 error 事件</h2><p>内置，一般要为会触发 error 事件的对象设置监听器，避免程序崩溃</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readerStream.on(&#39;error&#39;, function(err)&#123;</span><br><span class=\"line\">   console.log(err.stack);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"8-Buffer\"><a href=\"#8-Buffer\" class=\"headerlink\" title=\"8. Buffer\"></a>8. Buffer</h1><ol>\n<li><p>编码</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;用from创建buffer对象（安全）</span><br><span class=\"line\">const buf &#x3D; Buffer.from(&#39;runoob&#39;, &#39;ascii&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 输出 72756e6f6f62</span><br><span class=\"line\">console.log(buf.toString(&#39;hex&#39;));</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 输出 cnVub29i</span><br><span class=\"line\">console.log(buf.toString(&#39;base64&#39;));</span><br></pre></td></tr></table></figure></li>\n<li><p>写入缓冲区</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buf.write(string[, offset[, length]][, encoding])</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>string - 写入缓冲区的字符串。<br>offset - 缓冲区开始写入的索引值，默认为 0 。<br>length - 写入的字节数，默认为 buffer.length<br>encoding - 使用的编码。默认为 ‘utf8’ 。<br>返回实际写入的大小</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"9-Stream\"><a href=\"#9-Stream\" class=\"headerlink\" title=\"9. Stream\"></a>9. Stream</h1><ul>\n<li>所有的 Stream 对象都是 EventEmitter 的实例。<h2 id=\"9-1-从文件读入流\"><a href=\"#9-1-从文件读入流\" class=\"headerlink\" title=\"9.1 从文件读入流\"></a>9.1 从文件读入流</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class=\"line\">var data &#x3D; &#39;&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 创建可读流</span><br><span class=\"line\">var readerStream &#x3D; fs.createReadStream(&#39;input.txt&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 设置编码为 utf8。</span><br><span class=\"line\">readerStream.setEncoding(&#39;UTF8&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 处理流事件 --&gt; data, end, and error</span><br><span class=\"line\">readerStream.on(&#39;data&#39;, function(chunk) &#123;</span><br><span class=\"line\">   data +&#x3D; chunk;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">readerStream.on(&#39;end&#39;,function()&#123;</span><br><span class=\"line\">   console.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">readerStream.on(&#39;error&#39;, function(err)&#123;</span><br><span class=\"line\">   console.log(err.stack);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;程序执行完毕&quot;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>程序执行完毕<br>&amp;input.txt的内容</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"9-2-写入流到文件\"><a href=\"#9-2-写入流到文件\" class=\"headerlink\" title=\"9.2 写入流到文件\"></a>9.2 写入流到文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class=\"line\">var data &#x3D; &#39;菜鸟教程官网地址：www.runoob.com&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 创建一个可以写入的流，写入到文件 output.txt 中</span><br><span class=\"line\">var writerStream &#x3D; fs.createWriteStream(&#39;output.txt&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 使用 utf8 编码写入数据</span><br><span class=\"line\">writerStream.write(data,&#39;UTF8&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 标记文件末尾</span><br><span class=\"line\">writerStream.end();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 处理流事件 --&gt; data, end, and error</span><br><span class=\"line\">writerStream.on(&#39;finish&#39;, function() &#123;</span><br><span class=\"line\">    console.log(&quot;写入完成。&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">writerStream.on(&#39;error&#39;, function(err)&#123;</span><br><span class=\"line\">   console.log(err.stack);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-3-管道流\"><a href=\"#9-3-管道流\" class=\"headerlink\" title=\"9.3 管道流\"></a>9.3 管道流</h2><ul>\n<li>从一个流中获取数据并将数据传递到另外一个流中。<br><img src=\"http://www.runoob.com/wp-content/uploads/2015/09/bVcla61\" alt=\"此处输入图片的描述\"><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 创建一个可读流</span><br><span class=\"line\">var readerStream &#x3D; fs.createReadStream(&#39;input.txt&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 创建一个可写流</span><br><span class=\"line\">var writerStream &#x3D; fs.createWriteStream(&#39;output.txt&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 管道读写操作</span><br><span class=\"line\">&#x2F;&#x2F; 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中</span><br><span class=\"line\">readerStream.pipe(writerStream);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;程序执行完毕&quot;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"9-4-链式流\"><a href=\"#9-4-链式流\" class=\"headerlink\" title=\"9.4 链式流\"></a>9.4 链式流</h2><p>: 创建多个流操作链，一般用于管道操作。</p>\n<ul>\n<li>压缩文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class=\"line\">var zlib &#x3D; require(&#39;zlib&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 压缩 input.txt 文件为 input.txt.gz</span><br><span class=\"line\">fs.createReadStream(&#39;input.txt&#39;)</span><br><span class=\"line\">  .pipe(zlib.createGzip())</span><br><span class=\"line\">  .pipe(fs.createWriteStream(&#39;input.txt.gz&#39;));</span><br><span class=\"line\">  </span><br><span class=\"line\">console.log(&quot;文件压缩完成。&quot;);</span><br></pre></td></tr></table></figure></li>\n<li>解压文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class=\"line\">var zlib &#x3D; require(&#39;zlib&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 解压 input.txt.gz 文件为 input.txt</span><br><span class=\"line\">fs.createReadStream(&#39;input.txt.gz&#39;)</span><br><span class=\"line\">  .pipe(zlib.createGunzip())</span><br><span class=\"line\">  .pipe(fs.createWriteStream(&#39;input.txt&#39;));</span><br><span class=\"line\">  </span><br><span class=\"line\">console.log(&quot;文件解压完成。&quot;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"10-express\"><a href=\"#10-express\" class=\"headerlink\" title=\"10. express\"></a>10. express</h1><p>非侵入性：保留了原生的功能，添加了一些方法。<br>只提供最简单的功能，使用中间件(插件)拓展功能。<br>链式操作：多次用<code>server.use</code>对请求进行处理(7.3)</p>\n<ul>\n<li>query方法解析get请求：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;1.添加依赖</span><br><span class=\"line\">const express &#x3D; require(&#39;express&#39;);</span><br><span class=\"line\">&#x2F;&#x2F;2.创建服务</span><br><span class=\"line\">var server&#x3D;express();</span><br><span class=\"line\">&#x2F;&#x2F;3.use添加响应，处理请求</span><br><span class=\"line\">server.get(&#39;&#x2F;login&#39;,function(req,res)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;内置query方法</span><br><span class=\"line\">    var user &#x3D; req.query[&#39;user&#39;];</span><br><span class=\"line\">    res.send(&#39;欢迎&#39;+user,200);&#x2F;&#x2F;send比原生的write功能更强大，可以放各种类型参数</span><br><span class=\"line\">    res.end();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#x2F;&#x2F;4.监听端口</span><br><span class=\"line\">server.listen(8080);</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-1-三种方法\"><a href=\"#10-1-三种方法\" class=\"headerlink\" title=\"10.1 三种方法\"></a>10.1 三种方法</h2></li>\n<li>.get() - 处理get请求</li>\n<li>.post() - 处理post请求</li>\n<li>.all() - 可处理所有请求</li>\n</ul>\n<h2 id=\"10-2-静态资源\"><a href=\"#10-2-静态资源\" class=\"headerlink\" title=\"10.2 静态资源\"></a>10.2 静态资源</h2><ul>\n<li>express-static<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express &#x3D; require(&#39;express&#39;);</span><br><span class=\"line\">&#x2F;&#x2F;1.添加依赖</span><br><span class=\"line\">const expressStatic &#x3D; require(&#39;express-static&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">var server &#x3D; express();</span><br><span class=\"line\">server.listen(8080);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;2.use使用插件</span><br><span class=\"line\">&#x2F;&#x2F;指定静态资源目录，可从url直接访问</span><br><span class=\"line\">server.use(expressStatic(&#39;.&#x2F;www&#39;));</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-3-GET-POST解析\"><a href=\"#10-3-GET-POST解析\" class=\"headerlink\" title=\"10.3 GET/POST解析\"></a>10.3 GET/POST解析</h2></li>\n<li>GET:exoress中req.query[‘user’]直接解析</li>\n<li>POST:<ul>\n<li>用body-parser<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const bosyParser&#x3D;require(&#39;body-parser&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;use函数无路径参数时，指接受所有请求</span><br><span class=\"line\">server.use(bodyParser.urlencoded(&#123;</span><br><span class=\"line\">extended:false,     &#x2F;&#x2F;扩展模式：默认为true，不建议</span><br><span class=\"line\">limit:2*1024*1024   &#x2F;&#x2F;2M</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">srver.use(&#39;&#x2F;&#39;,function(req,res)&#123;</span><br><span class=\"line\">    console.log(req.body);&#x2F;&#x2F;POST</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>手动实现<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;server.js</span><br><span class=\"line\">const bodyParser2&#x3D;require(&#39;.&#x2F;lib&#x2F;my-body-paser&#39;);</span><br><span class=\"line\">server.use(bodyParser2);</span><br><span class=\"line\">srver.use(&#39;&#x2F;&#39;,function(req,res)&#123;</span><br><span class=\"line\">console.log(reg.body);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;my-body-parser.js</span><br><span class=\"line\">const querystring &#x3D; require(&#39;querystring&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports&#x3D;function(req,res,next)&#123;</span><br><span class=\"line\">    var str &#x3D; &#39;&#39;;</span><br><span class=\"line\">    req.on(&#39;data&#39;,function(data)&#123;</span><br><span class=\"line\">        str+&#x3D;data;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    req.on(&#39;end&#39;,function()&#123;</span><br><span class=\"line\">        req.body&#x3D;querystring.parse(str);</span><br><span class=\"line\">        next();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"10-4-链式操作\"><a href=\"#10-4-链式操作\" class=\"headerlink\" title=\"10.4 链式操作\"></a>10.4 链式操作</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">srver.use(&#39;&#x2F;&#39;,function(req,res,next)&#123;</span><br><span class=\"line\">    console.log(&#39;a&#39;);</span><br><span class=\"line\">    next();&#x2F;&#x2F;让下一个处理者处理</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">srver.use(&#39;&#x2F;&#39;,function(req,res)&#123;</span><br><span class=\"line\">    console.log(&#39;b&#39;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>a<br>b</p>\n</blockquote>\n<h1 id=\"11-Cookie-amp-Seesion\"><a href=\"#11-Cookie-amp-Seesion\" class=\"headerlink\" title=\"11. Cookie &amp; Seesion\"></a>11. Cookie &amp; Seesion</h1><h2 id=\"11-1-设置、删除Cookie\"><a href=\"#11-1-设置、删除Cookie\" class=\"headerlink\" title=\"11.1 设置、删除Cookie\"></a>11.1 设置、删除Cookie</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.use(&#39;&#x2F;aaa&#x2F;a.html&#39;, function (req, res) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;path：在此目录下生效，maxAge：生存毫秒</span><br><span class=\"line\">    res.cookie(&#39;user&#39;, &#39;blue&#39;, &#123;path: &#39;&#x2F;aaa&#39;, maxAge: 30 * 24 * 3600 * 1000&#125;);</span><br><span class=\"line\">    &#x2F;&#x2F;删除</span><br><span class=\"line\">    res.clearCookie(&#39;user&#39;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    res.send(&#39;ok&#39;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-2-读取Cookie\"><a href=\"#11-2-读取Cookie\" class=\"headerlink\" title=\"11.2 读取Cookie\"></a>11.2 读取Cookie</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;依赖cookie-parser</span><br><span class=\"line\">const cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.use(cookieParser());</span><br><span class=\"line\"></span><br><span class=\"line\">server.use(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class=\"line\">    console.log(req.cookies);</span><br><span class=\"line\">    </span><br><span class=\"line\">    res.send(&#39;ok&#39;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-3-签名Cookie\"><a href=\"#11-3-签名Cookie\" class=\"headerlink\" title=\"11.3 签名Cookie\"></a>11.3 签名Cookie</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;依赖cookie-parser</span><br><span class=\"line\">const cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class=\"line\">&#x2F;&#x2F;签名</span><br><span class=\"line\">server.use(cookieParser(&#39;wesdfw4r34tf&#39;));</span><br><span class=\"line\"></span><br><span class=\"line\">server.use(&#39;&#x2F;&#39;, function (req, res)&#123;</span><br><span class=\"line\">    res.cookie(&#39;user&#39;, &#39;blue&#39;, &#123;signed: true&#125;);</span><br><span class=\"line\">    &#x2F;&#x2F;读取</span><br><span class=\"line\">    console.log(&#39;签名cookie：&#39;, req.signedCookies);</span><br><span class=\"line\">    console.log(&#39;无签名cookie：&#39;, req.cookies);</span><br><span class=\"line\">    </span><br><span class=\"line\">    res.send(&#39;ok&#39;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-4-Session\"><a href=\"#11-4-Session\" class=\"headerlink\" title=\"11.4 Session\"></a>11.4 Session</h2><ul>\n<li>加密是强制的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class=\"line\">const cookieSession &#x3D; require(&#39;cookie-session&#39;);</span><br><span class=\"line\">&#x2F;&#x2F;密钥</span><br><span class=\"line\">var arr&#x3D;[];</span><br><span class=\"line\">for(var i&#x3D;0;i&lt;10000;i++)&#123;</span><br><span class=\"line\">  arr.push(&#39;sig_&#39;+Math.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;会生成(session id)一个sess Cookie和一个sess.sig Cookie</span><br><span class=\"line\">server.use(cookieParser());</span><br><span class=\"line\">server.use(cookieSession(&#123;</span><br><span class=\"line\">    name: &#39;sess&#39;,</span><br><span class=\"line\">    keys: arr,</span><br><span class=\"line\">    maxAge: 2 * 3600 * 1000</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">server.use(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;读取、修改</span><br><span class=\"line\">    if (req.session[&#39;count&#39;] &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">        req.session[&#39;count&#39;] &#x3D; 1;</span><br><span class=\"line\">    &#125; else if(req.session[&#39;count&#39;] &#x3D;&#x3D; 100) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;删除</span><br><span class=\"line\">        delete req.session;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        req.session[&#39;count&#39;]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(req.session[&#39;count&#39;]);</span><br><span class=\"line\"></span><br><span class=\"line\">    res.send(&#39;ok&#39;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"12-文件上传\"><a href=\"#12-文件上传\" class=\"headerlink\" title=\"12. 文件上传\"></a>12. 文件上传</h1><ul>\n<li>文件名会被自动重命名防重名<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express &#x3D; require(&#39;express&#39;);</span><br><span class=\"line\">const multer &#x3D; require(&#39;multer&#39;);</span><br><span class=\"line\">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class=\"line\">&#x2F;&#x2F;解析路径</span><br><span class=\"line\">const pathLib &#x3D; require(&#39;path&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">var server &#x3D; express();</span><br><span class=\"line\">&#x2F;&#x2F;指定存放路径和文件限制</span><br><span class=\"line\">server.use(multer(&#123;dest: &#39;.&#x2F;www&#x2F;upload&#x2F;&#39;&#125;).any());</span><br><span class=\"line\"></span><br><span class=\"line\">server.post(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;新文件名</span><br><span class=\"line\">    var newName &#x3D; req.files[0].path +</span><br><span class=\"line\">        pathLib.parse(req.files[0].originalname).ext;</span><br><span class=\"line\">    &#x2F;&#x2F;重命名</span><br><span class=\"line\">    fs.rename(req.files[0].path, newName, function (err) &#123;</span><br><span class=\"line\">        if (err)</span><br><span class=\"line\">            res.send(&#39;上传失败&#39;);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            res.send(&#39;成功&#39;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8080);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"13-数据库\"><a href=\"#13-数据库\" class=\"headerlink\" title=\"13. 数据库\"></a>13. 数据库</h1><p>mysql库的connection连接之后不要断开，不然后面无法再使用。可用连接池。</p>\n<h2 id=\"13-1-查\"><a href=\"#13-1-查\" class=\"headerlink\" title=\"13.1 查\"></a>13.1 查</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mysql  &#x3D; require(&#39;mysql&#39;);  </span><br><span class=\"line\"></span><br><span class=\"line\">var connection &#x3D; mysql.createConnection(&#123;     </span><br><span class=\"line\">    host     : &#39;localhost&#39;,       </span><br><span class=\"line\">    user     : &#39;root&#39;,              </span><br><span class=\"line\">    password : &#39;123456&#39;,       </span><br><span class=\"line\">    port: &#39;3306&#39;,                   </span><br><span class=\"line\">    database: &#39;test&#39;, </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">&#x2F;&#x2F;连</span><br><span class=\"line\">connection.connect();</span><br><span class=\"line\"></span><br><span class=\"line\">var sql &#x3D; &#39;SELECT * FROM websites&#39;;</span><br><span class=\"line\">&#x2F;&#x2F;查</span><br><span class=\"line\">connection.query(sql,function (err, result) &#123;</span><br><span class=\"line\">        if(err)&#123;</span><br><span class=\"line\">          console.log(&#39;[SELECT ERROR] - &#39;,err.message);</span><br><span class=\"line\">          return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">       console.log(&#39;-----------SELECT-----------&#39;);</span><br><span class=\"line\">       console.log(result);</span><br><span class=\"line\">       console.log(&#39;----------------------------\\n\\n&#39;);  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#x2F;&#x2F;断</span><br><span class=\"line\">connection.end();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-2-增\"><a href=\"#13-2-增\" class=\"headerlink\" title=\"13.2 增\"></a>13.2 增</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addSql &#x3D; &#39;INSERT INTO websites(Id,name,url,alexa,country) VALUES(0,?,?,?,?)&#39;;</span><br><span class=\"line\">var addSqlParams &#x3D; [&#39;菜鸟工具&#39;, &#39;https:&#x2F;&#x2F;c.runoob.com&#39;,&#39;23453&#39;, &#39;CN&#39;];</span><br><span class=\"line\">&#x2F;&#x2F;增</span><br><span class=\"line\">connection.query(addSql,addSqlParams,function (err, result) &#123;</span><br><span class=\"line\">    if(err)&#123;</span><br><span class=\"line\">        console.log(&#39;[INSERT ERROR] - &#39;,err.message);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">    </span><br><span class=\"line\">    console.log(&#39;-------------INSERT---------------&#39;);</span><br><span class=\"line\">    &#x2F;&#x2F;console.log(&#39;INSERT ID:&#39;,result.insertId);        </span><br><span class=\"line\">    console.log(&#39;INSERT ID:&#39;,result);        </span><br><span class=\"line\">    console.log(&#39;----------------------------------\\n\\n&#39;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-3-改\"><a href=\"#13-3-改\" class=\"headerlink\" title=\"13.3 改\"></a>13.3 改</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var modSql &#x3D; &#39;UPDATE websites SET name &#x3D; ?,url &#x3D; ? WHERE Id &#x3D; ?&#39;;</span><br><span class=\"line\">var modSqlParams &#x3D; [&#39;菜鸟移动站&#39;, &#39;https:&#x2F;&#x2F;m.runoob.com&#39;,6];</span><br><span class=\"line\">&#x2F;&#x2F;改</span><br><span class=\"line\">connection.query(modSql,modSqlParams,function (err, result) &#123;</span><br><span class=\"line\">    if(err)&#123;</span><br><span class=\"line\">        console.log(&#39;[UPDATE ERROR] - &#39;,err.message);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">    console.log(&#39;-----------UPDATE-----------&#39;);</span><br><span class=\"line\">    console.log(&#39;UPDATE affectedRows&#39;,result.affectedRows);</span><br><span class=\"line\">    console.log(&#39;----------------------------\\n\\n&#39;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-4-删\"><a href=\"#13-4-删\" class=\"headerlink\" title=\"13.4 删\"></a>13.4 删</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var delSql &#x3D; &#39;DELETE FROM websites where id&#x3D;6&#39;;</span><br><span class=\"line\">&#x2F;&#x2F;删</span><br><span class=\"line\">connection.query(delSql,function (err, result) &#123;</span><br><span class=\"line\">    if(err)&#123;</span><br><span class=\"line\">        console.log(&#39;[DELETE ERROR] - &#39;,err.message);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">    </span><br><span class=\"line\">    console.log(&#39;-------------DELETE-------------&#39;);</span><br><span class=\"line\">    console.log(&#39;DELETE affectedRows&#39;,result.affectedRows);</span><br><span class=\"line\">    console.log(&#39;--------------------------------\\n\\n&#39;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-5-连接池\"><a href=\"#13-5-连接池\" class=\"headerlink\" title=\"13.5 连接池\"></a>13.5 连接池</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mysql &#x3D; require(&#39;mysql&#39;);</span><br><span class=\"line\">var pool  &#x3D; mysql.createPool(&#123;</span><br><span class=\"line\">    host: &#39;&#39;,</span><br><span class=\"line\">    user: &#39;&#39;,</span><br><span class=\"line\">    password: &#39;&#39;,</span><br><span class=\"line\">    port: &#39;&#39;,</span><br><span class=\"line\">    database: &#39;&#39;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">exports.query &#x3D; function(sql, cb)&#123;</span><br><span class=\"line\">    pool.getConnection(function(err, connection) &#123;</span><br><span class=\"line\">        connection.query(sql, cb);</span><br><span class=\"line\">        connection.release();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>Node + React 开发真的好方便~</p>\n</blockquote>","more":"<h1 id=\"1-NPM\"><a href=\"#1-NPM\" class=\"headerlink\" title=\"1. NPM\"></a>1. NPM</h1><ul>\n<li>安装：<code>npm install &lt;Module Name&gt;@可空版本号</code></li>\n<li>使用：<code>var express = require(&#39;express&#39;);</code></li>\n<li>本地安装 装在CLI当前目录 node_modules 下；全局安装 装在node下</li>\n<li>更新：<code>npm update express</code></li>\n<li>淘宝镜像：<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code><br>  使用：<code>cnpm install [name]</code></li>\n</ul>\n<h1 id=\"2-Sundry\"><a href=\"#2-Sundry\" class=\"headerlink\" title=\"2. Sundry\"></a>2. Sundry</h1><ul>\n<li>Node.js 基本上所有的事件机制都是用设计模式中<strong>观察者模式</strong>实现<br>  当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</li>\n<li>Node.js 异步编程的直接体现就是回调，Node 所有 API 都支持回调函数。</li>\n</ul>\n<h1 id=\"3-创建服务器\"><a href=\"#3-创建服务器\" class=\"headerlink\" title=\"3. 创建服务器\"></a>3. 创建服务器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;添加http依赖</span><br><span class=\"line\">var http &#x3D; require(&quot;http&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;创建服务器（匿名形式写入回调）</span><br><span class=\"line\">http.createServer(function(request, response) &#123;</span><br><span class=\"line\">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text&#x2F;plain&quot;&#125;);</span><br><span class=\"line\">    response.write(&quot;Hello World&quot;);</span><br><span class=\"line\">    response.end();</span><br><span class=\"line\">&#125;).listen(8888);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-文件操作file-system\"><a href=\"#4-文件操作file-system\" class=\"headerlink\" title=\"4. 文件操作file system\"></a>4. 文件操作file system</h1><ol>\n<li><p>读写文件</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;readFile(文件名,function(err,data))</span><br><span class=\"line\">fs.readFile(&#39;aaa.txt&#39;,function(err,data)&#123;</span><br><span class=\"line\">    if(err)&#123;</span><br><span class=\"line\">        console.log(&#39;读取失败&#39;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        console.log(data.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;writeFile(文件名,内容,function(err))</span><br><span class=\"line\">fs.writeFile(&#39;bbb.txt&#39;,&#39;123&#39;,function(err)&#123;</span><br><span class=\"line\">    console.log(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li><p>打开文件</p>\n<blockquote>\n<p>fs.open(path, flags[, mode], callback)</p>\n</blockquote>\n<ul>\n<li>path - 文件的路径。</li>\n<li>flags - 文件打开的行为。具体值详见下文。</li>\n<li>mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。</li>\n<li>callback - 回调函数，带有两个参数如：callback(err, fd)。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 异步打开文件</span><br><span class=\"line\">console.log(&quot;准备打开文件！&quot;);</span><br><span class=\"line\">fs.open(&#39;input.txt&#39;, &#39;r+&#39;, function(err, fd) &#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  console.log(&quot;文件打开成功！&quot;);     </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>获取文件信息</p>\n<blockquote>\n<p>fs.stat(path, callback)</p>\n</blockquote>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.stat(&#39;&#x2F;Users&#x2F;liuht&#x2F;code&#x2F;itbilu&#x2F;demo&#x2F;fs.js&#39;, function (err, stats) &#123;</span><br><span class=\"line\">    console.log(stats.isFile());         &#x2F;&#x2F;true</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>关闭文件</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.close(fd, function(err)&#123;</span><br><span class=\"line\">    if (err)&#123;</span><br><span class=\"line\">        console.log(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(&quot;文件关闭成功&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h1 id=\"5-http数据解析\"><a href=\"#5-http数据解析\" class=\"headerlink\" title=\"5. http数据解析\"></a>5. http数据解析</h1><h2 id=\"5-1-GET解析\"><a href=\"#5-1-GET解析\" class=\"headerlink\" title=\"5.1 GET解析\"></a>5.1 GET解析</h2><ul>\n<li>querystring解析(亦用于POST)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const querystring &#x3D; require(&#39;querystring&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">json &#x3D; querystring.parse(&#39;user&#x3D;blue&amp;pass&#x3D;12345&amp;age&#x3D;18&#39;);</span><br><span class=\"line\">console.log(json);</span><br><span class=\"line\">&gt;&gt; &#123; user: &#39;blue&#39;, pass: &#39;12345&#39;, age: &#39;18&#39; &#125;</span><br></pre></td></tr></table></figure></li>\n<li>url解析<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const urlLib &#x3D; require(&#39;url&#39;);</span><br><span class=\"line\">&#x2F;&#x2F;二参：是否把query进行query转换</span><br><span class=\"line\">var obj&#x3D;urlLib.parse(&#39;http:&#x2F;&#x2F;www.zjn.com&#x2F;index?a&#x3D;123&amp;b&#x3D;654&#39;,true);</span><br><span class=\"line\">console.log(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;  Url &#123;</span><br><span class=\"line\">    protocol: &#39;http:&#39;,</span><br><span class=\"line\">    slashes: true,</span><br><span class=\"line\">    auth: null,</span><br><span class=\"line\">    host: &#39;www.zjn.com&#39;,</span><br><span class=\"line\">    port: null,</span><br><span class=\"line\">    hostname: &#39;www.zjn.com&#39;,</span><br><span class=\"line\">    hash: null,</span><br><span class=\"line\">    search: &#39;?a&#x3D;123&amp;b&#x3D;654&#39;,</span><br><span class=\"line\">    query: &#123; a: &#39;123&#39;, b: &#39;654&#39; &#125;,</span><br><span class=\"line\">    pathname: &#39;&#x2F;index&#39;,</span><br><span class=\"line\">    path: &#39;&#x2F;index?a&#x3D;123&amp;b&#x3D;654&#39;,</span><br><span class=\"line\">    href: &#39;http:&#x2F;&#x2F;www.zjn.com&#x2F;index?a&#x3D;123&amp;b&#x3D;654&#39; &#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"5-2-POST\"><a href=\"#5-2-POST\" class=\"headerlink\" title=\"5.2 POST\"></a>5.2 POST</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const http &#x3D; require(&#39;http&#39;);</span><br><span class=\"line\">const querystring &#x3D; require(&#39;querystring&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(function(req,res)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;POST-req分段发送</span><br><span class=\"line\">    var str&#x3D;&#39;&#39;;</span><br><span class=\"line\">    &#x2F;&#x2F;data-有一段数据到达(多次)</span><br><span class=\"line\">    var i&#x3D;0;</span><br><span class=\"line\">    req.on(&#39;data&#39;,function(data)&#123;</span><br><span class=\"line\">        console.log(&#96;第$&#123;i++&#125;次收数据&#96;)</span><br><span class=\"line\">        str+&#x3D;data;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &#x2F;&#x2F;end-数据全部到达标记(一次)</span><br><span class=\"line\">    req.on(&#39;end&#39;,function()&#123;</span><br><span class=\"line\">        var POST&#x3D;querystring.parse(str);</span><br><span class=\"line\">        console.log(POST);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;).listen(8080);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6-模块\"><a href=\"#6-模块\" class=\"headerlink\" title=\"6. 模块\"></a>6. 模块</h1><h2 id=\"6-1-自定义模块\"><a href=\"#6-1-自定义模块\" class=\"headerlink\" title=\"6.1 自定义模块\"></a>6.1 自定义模块</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;mod.js</span><br><span class=\"line\">var a &#x3D; 12;</span><br><span class=\"line\">exports.b &#x3D; 23;&#x2F;&#x2F;输出的对象加前缀exports.</span><br><span class=\"line\">module.exports&#x3D;&#123;b,c&#x3D;2,d&#x3D;4&#125;;&#x2F;&#x2F;批量输出</span><br><span class=\"line\">&#x2F;&#x2F;1.js</span><br><span class=\"line\">const mod1 &#x3D; require(&#39;.&#x2F;mod&#39;);&#x2F;&#x2F;模块在node_modules目录下时.&#x2F;可省</span><br><span class=\"line\">console.log(mod1.a);</span><br><span class=\"line\">console.log(mod1.b);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;输出：</span><br><span class=\"line\">undefined</span><br><span class=\"line\">23</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"7-事件\"><a href=\"#7-事件\" class=\"headerlink\" title=\"7. 事件\"></a>7. <a href=\"https://www.runoob.com/nodejs/nodejs-event.html\">事件</a></h1><h2 id=\"7-1-事件绑定\"><a href=\"#7-1-事件绑定\" class=\"headerlink\" title=\"7.1 事件绑定\"></a>7.1 事件绑定</h2><blockquote>\n<p>eventEmitter.on(event, listener)为事件绑定监听器,监听器为回调函数<br>.emit(event, [arg1],[arg2], […])触发,参数为监听器参数<br>.once(event,listener)一次性监听器</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 引入 events 模块</span><br><span class=\"line\">var events &#x3D; require(&#39;events&#39;);</span><br><span class=\"line\">&#x2F;&#x2F; 创建 事件触发器 对象</span><br><span class=\"line\">var eventEmitter &#x3D; new events.EventEmitter();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 2.创建事件处理程序</span><br><span class=\"line\">var connectHandler &#x3D; function connected() &#123;</span><br><span class=\"line\">    console.log(&#39;1.连接成功。&#39;);</span><br><span class=\"line\">    &#x2F;&#x2F; 3.触发 data_received 事件</span><br><span class=\"line\">    eventEmitter.emit(&#39;data_received&#39;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 绑定 connection 事件处理程序</span><br><span class=\"line\">eventEmitter.on(&#39;connection&#39;, connectHandler);</span><br><span class=\"line\">&#x2F;&#x2F; 绑定 data_received 事件(使用匿名函数)</span><br><span class=\"line\">eventEmitter.on(&#39;data_received&#39;, function () &#123;</span><br><span class=\"line\">    console.log(&#39;2.数据接收成功。&#39;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 1.触发 connection 事件 </span><br><span class=\"line\">eventEmitter.emit(&#39;connection&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;3.程序执行完毕。&quot;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出：<br>$ node main.js<br>1.连接成功。<br>2.数据接收成功。<br>3.程序执行完毕。</p>\n</blockquote>\n<h2 id=\"7-2-error-事件\"><a href=\"#7-2-error-事件\" class=\"headerlink\" title=\"7.2 error 事件\"></a>7.2 error 事件</h2><p>内置，一般要为会触发 error 事件的对象设置监听器，避免程序崩溃</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readerStream.on(&#39;error&#39;, function(err)&#123;</span><br><span class=\"line\">   console.log(err.stack);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"8-Buffer\"><a href=\"#8-Buffer\" class=\"headerlink\" title=\"8. Buffer\"></a>8. Buffer</h1><ol>\n<li><p>编码</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;用from创建buffer对象（安全）</span><br><span class=\"line\">const buf &#x3D; Buffer.from(&#39;runoob&#39;, &#39;ascii&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 输出 72756e6f6f62</span><br><span class=\"line\">console.log(buf.toString(&#39;hex&#39;));</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 输出 cnVub29i</span><br><span class=\"line\">console.log(buf.toString(&#39;base64&#39;));</span><br></pre></td></tr></table></figure></li>\n<li><p>写入缓冲区</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buf.write(string[, offset[, length]][, encoding])</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>string - 写入缓冲区的字符串。<br>offset - 缓冲区开始写入的索引值，默认为 0 。<br>length - 写入的字节数，默认为 buffer.length<br>encoding - 使用的编码。默认为 ‘utf8’ 。<br>返回实际写入的大小</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"9-Stream\"><a href=\"#9-Stream\" class=\"headerlink\" title=\"9. Stream\"></a>9. Stream</h1><ul>\n<li>所有的 Stream 对象都是 EventEmitter 的实例。<h2 id=\"9-1-从文件读入流\"><a href=\"#9-1-从文件读入流\" class=\"headerlink\" title=\"9.1 从文件读入流\"></a>9.1 从文件读入流</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class=\"line\">var data &#x3D; &#39;&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 创建可读流</span><br><span class=\"line\">var readerStream &#x3D; fs.createReadStream(&#39;input.txt&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 设置编码为 utf8。</span><br><span class=\"line\">readerStream.setEncoding(&#39;UTF8&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 处理流事件 --&gt; data, end, and error</span><br><span class=\"line\">readerStream.on(&#39;data&#39;, function(chunk) &#123;</span><br><span class=\"line\">   data +&#x3D; chunk;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">readerStream.on(&#39;end&#39;,function()&#123;</span><br><span class=\"line\">   console.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">readerStream.on(&#39;error&#39;, function(err)&#123;</span><br><span class=\"line\">   console.log(err.stack);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;程序执行完毕&quot;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>程序执行完毕<br>&amp;input.txt的内容</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"9-2-写入流到文件\"><a href=\"#9-2-写入流到文件\" class=\"headerlink\" title=\"9.2 写入流到文件\"></a>9.2 写入流到文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class=\"line\">var data &#x3D; &#39;菜鸟教程官网地址：www.runoob.com&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 创建一个可以写入的流，写入到文件 output.txt 中</span><br><span class=\"line\">var writerStream &#x3D; fs.createWriteStream(&#39;output.txt&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 使用 utf8 编码写入数据</span><br><span class=\"line\">writerStream.write(data,&#39;UTF8&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 标记文件末尾</span><br><span class=\"line\">writerStream.end();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 处理流事件 --&gt; data, end, and error</span><br><span class=\"line\">writerStream.on(&#39;finish&#39;, function() &#123;</span><br><span class=\"line\">    console.log(&quot;写入完成。&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">writerStream.on(&#39;error&#39;, function(err)&#123;</span><br><span class=\"line\">   console.log(err.stack);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-3-管道流\"><a href=\"#9-3-管道流\" class=\"headerlink\" title=\"9.3 管道流\"></a>9.3 管道流</h2><ul>\n<li>从一个流中获取数据并将数据传递到另外一个流中。<br><img src=\"http://www.runoob.com/wp-content/uploads/2015/09/bVcla61\" alt=\"此处输入图片的描述\"><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 创建一个可读流</span><br><span class=\"line\">var readerStream &#x3D; fs.createReadStream(&#39;input.txt&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 创建一个可写流</span><br><span class=\"line\">var writerStream &#x3D; fs.createWriteStream(&#39;output.txt&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 管道读写操作</span><br><span class=\"line\">&#x2F;&#x2F; 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中</span><br><span class=\"line\">readerStream.pipe(writerStream);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;程序执行完毕&quot;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"9-4-链式流\"><a href=\"#9-4-链式流\" class=\"headerlink\" title=\"9.4 链式流\"></a>9.4 链式流</h2><p>: 创建多个流操作链，一般用于管道操作。</p>\n<ul>\n<li>压缩文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class=\"line\">var zlib &#x3D; require(&#39;zlib&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 压缩 input.txt 文件为 input.txt.gz</span><br><span class=\"line\">fs.createReadStream(&#39;input.txt&#39;)</span><br><span class=\"line\">  .pipe(zlib.createGzip())</span><br><span class=\"line\">  .pipe(fs.createWriteStream(&#39;input.txt.gz&#39;));</span><br><span class=\"line\">  </span><br><span class=\"line\">console.log(&quot;文件压缩完成。&quot;);</span><br></pre></td></tr></table></figure></li>\n<li>解压文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class=\"line\">var zlib &#x3D; require(&#39;zlib&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 解压 input.txt.gz 文件为 input.txt</span><br><span class=\"line\">fs.createReadStream(&#39;input.txt.gz&#39;)</span><br><span class=\"line\">  .pipe(zlib.createGunzip())</span><br><span class=\"line\">  .pipe(fs.createWriteStream(&#39;input.txt&#39;));</span><br><span class=\"line\">  </span><br><span class=\"line\">console.log(&quot;文件解压完成。&quot;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"10-express\"><a href=\"#10-express\" class=\"headerlink\" title=\"10. express\"></a>10. express</h1><p>非侵入性：保留了原生的功能，添加了一些方法。<br>只提供最简单的功能，使用中间件(插件)拓展功能。<br>链式操作：多次用<code>server.use</code>对请求进行处理(7.3)</p>\n<ul>\n<li>query方法解析get请求：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;1.添加依赖</span><br><span class=\"line\">const express &#x3D; require(&#39;express&#39;);</span><br><span class=\"line\">&#x2F;&#x2F;2.创建服务</span><br><span class=\"line\">var server&#x3D;express();</span><br><span class=\"line\">&#x2F;&#x2F;3.use添加响应，处理请求</span><br><span class=\"line\">server.get(&#39;&#x2F;login&#39;,function(req,res)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;内置query方法</span><br><span class=\"line\">    var user &#x3D; req.query[&#39;user&#39;];</span><br><span class=\"line\">    res.send(&#39;欢迎&#39;+user,200);&#x2F;&#x2F;send比原生的write功能更强大，可以放各种类型参数</span><br><span class=\"line\">    res.end();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#x2F;&#x2F;4.监听端口</span><br><span class=\"line\">server.listen(8080);</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-1-三种方法\"><a href=\"#10-1-三种方法\" class=\"headerlink\" title=\"10.1 三种方法\"></a>10.1 三种方法</h2></li>\n<li>.get() - 处理get请求</li>\n<li>.post() - 处理post请求</li>\n<li>.all() - 可处理所有请求</li>\n</ul>\n<h2 id=\"10-2-静态资源\"><a href=\"#10-2-静态资源\" class=\"headerlink\" title=\"10.2 静态资源\"></a>10.2 静态资源</h2><ul>\n<li>express-static<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express &#x3D; require(&#39;express&#39;);</span><br><span class=\"line\">&#x2F;&#x2F;1.添加依赖</span><br><span class=\"line\">const expressStatic &#x3D; require(&#39;express-static&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">var server &#x3D; express();</span><br><span class=\"line\">server.listen(8080);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;2.use使用插件</span><br><span class=\"line\">&#x2F;&#x2F;指定静态资源目录，可从url直接访问</span><br><span class=\"line\">server.use(expressStatic(&#39;.&#x2F;www&#39;));</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-3-GET-POST解析\"><a href=\"#10-3-GET-POST解析\" class=\"headerlink\" title=\"10.3 GET/POST解析\"></a>10.3 GET/POST解析</h2></li>\n<li>GET:exoress中req.query[‘user’]直接解析</li>\n<li>POST:<ul>\n<li>用body-parser<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const bosyParser&#x3D;require(&#39;body-parser&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;use函数无路径参数时，指接受所有请求</span><br><span class=\"line\">server.use(bodyParser.urlencoded(&#123;</span><br><span class=\"line\">extended:false,     &#x2F;&#x2F;扩展模式：默认为true，不建议</span><br><span class=\"line\">limit:2*1024*1024   &#x2F;&#x2F;2M</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">srver.use(&#39;&#x2F;&#39;,function(req,res)&#123;</span><br><span class=\"line\">    console.log(req.body);&#x2F;&#x2F;POST</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>手动实现<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;server.js</span><br><span class=\"line\">const bodyParser2&#x3D;require(&#39;.&#x2F;lib&#x2F;my-body-paser&#39;);</span><br><span class=\"line\">server.use(bodyParser2);</span><br><span class=\"line\">srver.use(&#39;&#x2F;&#39;,function(req,res)&#123;</span><br><span class=\"line\">console.log(reg.body);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;my-body-parser.js</span><br><span class=\"line\">const querystring &#x3D; require(&#39;querystring&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports&#x3D;function(req,res,next)&#123;</span><br><span class=\"line\">    var str &#x3D; &#39;&#39;;</span><br><span class=\"line\">    req.on(&#39;data&#39;,function(data)&#123;</span><br><span class=\"line\">        str+&#x3D;data;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    req.on(&#39;end&#39;,function()&#123;</span><br><span class=\"line\">        req.body&#x3D;querystring.parse(str);</span><br><span class=\"line\">        next();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"10-4-链式操作\"><a href=\"#10-4-链式操作\" class=\"headerlink\" title=\"10.4 链式操作\"></a>10.4 链式操作</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">srver.use(&#39;&#x2F;&#39;,function(req,res,next)&#123;</span><br><span class=\"line\">    console.log(&#39;a&#39;);</span><br><span class=\"line\">    next();&#x2F;&#x2F;让下一个处理者处理</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">srver.use(&#39;&#x2F;&#39;,function(req,res)&#123;</span><br><span class=\"line\">    console.log(&#39;b&#39;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>a<br>b</p>\n</blockquote>\n<h1 id=\"11-Cookie-amp-Seesion\"><a href=\"#11-Cookie-amp-Seesion\" class=\"headerlink\" title=\"11. Cookie &amp; Seesion\"></a>11. Cookie &amp; Seesion</h1><h2 id=\"11-1-设置、删除Cookie\"><a href=\"#11-1-设置、删除Cookie\" class=\"headerlink\" title=\"11.1 设置、删除Cookie\"></a>11.1 设置、删除Cookie</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.use(&#39;&#x2F;aaa&#x2F;a.html&#39;, function (req, res) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;path：在此目录下生效，maxAge：生存毫秒</span><br><span class=\"line\">    res.cookie(&#39;user&#39;, &#39;blue&#39;, &#123;path: &#39;&#x2F;aaa&#39;, maxAge: 30 * 24 * 3600 * 1000&#125;);</span><br><span class=\"line\">    &#x2F;&#x2F;删除</span><br><span class=\"line\">    res.clearCookie(&#39;user&#39;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    res.send(&#39;ok&#39;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-2-读取Cookie\"><a href=\"#11-2-读取Cookie\" class=\"headerlink\" title=\"11.2 读取Cookie\"></a>11.2 读取Cookie</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;依赖cookie-parser</span><br><span class=\"line\">const cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.use(cookieParser());</span><br><span class=\"line\"></span><br><span class=\"line\">server.use(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class=\"line\">    console.log(req.cookies);</span><br><span class=\"line\">    </span><br><span class=\"line\">    res.send(&#39;ok&#39;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-3-签名Cookie\"><a href=\"#11-3-签名Cookie\" class=\"headerlink\" title=\"11.3 签名Cookie\"></a>11.3 签名Cookie</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;依赖cookie-parser</span><br><span class=\"line\">const cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class=\"line\">&#x2F;&#x2F;签名</span><br><span class=\"line\">server.use(cookieParser(&#39;wesdfw4r34tf&#39;));</span><br><span class=\"line\"></span><br><span class=\"line\">server.use(&#39;&#x2F;&#39;, function (req, res)&#123;</span><br><span class=\"line\">    res.cookie(&#39;user&#39;, &#39;blue&#39;, &#123;signed: true&#125;);</span><br><span class=\"line\">    &#x2F;&#x2F;读取</span><br><span class=\"line\">    console.log(&#39;签名cookie：&#39;, req.signedCookies);</span><br><span class=\"line\">    console.log(&#39;无签名cookie：&#39;, req.cookies);</span><br><span class=\"line\">    </span><br><span class=\"line\">    res.send(&#39;ok&#39;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-4-Session\"><a href=\"#11-4-Session\" class=\"headerlink\" title=\"11.4 Session\"></a>11.4 Session</h2><ul>\n<li>加密是强制的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class=\"line\">const cookieSession &#x3D; require(&#39;cookie-session&#39;);</span><br><span class=\"line\">&#x2F;&#x2F;密钥</span><br><span class=\"line\">var arr&#x3D;[];</span><br><span class=\"line\">for(var i&#x3D;0;i&lt;10000;i++)&#123;</span><br><span class=\"line\">  arr.push(&#39;sig_&#39;+Math.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;会生成(session id)一个sess Cookie和一个sess.sig Cookie</span><br><span class=\"line\">server.use(cookieParser());</span><br><span class=\"line\">server.use(cookieSession(&#123;</span><br><span class=\"line\">    name: &#39;sess&#39;,</span><br><span class=\"line\">    keys: arr,</span><br><span class=\"line\">    maxAge: 2 * 3600 * 1000</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">server.use(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;读取、修改</span><br><span class=\"line\">    if (req.session[&#39;count&#39;] &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">        req.session[&#39;count&#39;] &#x3D; 1;</span><br><span class=\"line\">    &#125; else if(req.session[&#39;count&#39;] &#x3D;&#x3D; 100) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;删除</span><br><span class=\"line\">        delete req.session;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        req.session[&#39;count&#39;]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(req.session[&#39;count&#39;]);</span><br><span class=\"line\"></span><br><span class=\"line\">    res.send(&#39;ok&#39;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"12-文件上传\"><a href=\"#12-文件上传\" class=\"headerlink\" title=\"12. 文件上传\"></a>12. 文件上传</h1><ul>\n<li>文件名会被自动重命名防重名<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express &#x3D; require(&#39;express&#39;);</span><br><span class=\"line\">const multer &#x3D; require(&#39;multer&#39;);</span><br><span class=\"line\">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class=\"line\">&#x2F;&#x2F;解析路径</span><br><span class=\"line\">const pathLib &#x3D; require(&#39;path&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">var server &#x3D; express();</span><br><span class=\"line\">&#x2F;&#x2F;指定存放路径和文件限制</span><br><span class=\"line\">server.use(multer(&#123;dest: &#39;.&#x2F;www&#x2F;upload&#x2F;&#39;&#125;).any());</span><br><span class=\"line\"></span><br><span class=\"line\">server.post(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;新文件名</span><br><span class=\"line\">    var newName &#x3D; req.files[0].path +</span><br><span class=\"line\">        pathLib.parse(req.files[0].originalname).ext;</span><br><span class=\"line\">    &#x2F;&#x2F;重命名</span><br><span class=\"line\">    fs.rename(req.files[0].path, newName, function (err) &#123;</span><br><span class=\"line\">        if (err)</span><br><span class=\"line\">            res.send(&#39;上传失败&#39;);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            res.send(&#39;成功&#39;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8080);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"13-数据库\"><a href=\"#13-数据库\" class=\"headerlink\" title=\"13. 数据库\"></a>13. 数据库</h1><p>mysql库的connection连接之后不要断开，不然后面无法再使用。可用连接池。</p>\n<h2 id=\"13-1-查\"><a href=\"#13-1-查\" class=\"headerlink\" title=\"13.1 查\"></a>13.1 查</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mysql  &#x3D; require(&#39;mysql&#39;);  </span><br><span class=\"line\"></span><br><span class=\"line\">var connection &#x3D; mysql.createConnection(&#123;     </span><br><span class=\"line\">    host     : &#39;localhost&#39;,       </span><br><span class=\"line\">    user     : &#39;root&#39;,              </span><br><span class=\"line\">    password : &#39;123456&#39;,       </span><br><span class=\"line\">    port: &#39;3306&#39;,                   </span><br><span class=\"line\">    database: &#39;test&#39;, </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">&#x2F;&#x2F;连</span><br><span class=\"line\">connection.connect();</span><br><span class=\"line\"></span><br><span class=\"line\">var sql &#x3D; &#39;SELECT * FROM websites&#39;;</span><br><span class=\"line\">&#x2F;&#x2F;查</span><br><span class=\"line\">connection.query(sql,function (err, result) &#123;</span><br><span class=\"line\">        if(err)&#123;</span><br><span class=\"line\">          console.log(&#39;[SELECT ERROR] - &#39;,err.message);</span><br><span class=\"line\">          return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">       console.log(&#39;-----------SELECT-----------&#39;);</span><br><span class=\"line\">       console.log(result);</span><br><span class=\"line\">       console.log(&#39;----------------------------\\n\\n&#39;);  </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#x2F;&#x2F;断</span><br><span class=\"line\">connection.end();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-2-增\"><a href=\"#13-2-增\" class=\"headerlink\" title=\"13.2 增\"></a>13.2 增</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addSql &#x3D; &#39;INSERT INTO websites(Id,name,url,alexa,country) VALUES(0,?,?,?,?)&#39;;</span><br><span class=\"line\">var addSqlParams &#x3D; [&#39;菜鸟工具&#39;, &#39;https:&#x2F;&#x2F;c.runoob.com&#39;,&#39;23453&#39;, &#39;CN&#39;];</span><br><span class=\"line\">&#x2F;&#x2F;增</span><br><span class=\"line\">connection.query(addSql,addSqlParams,function (err, result) &#123;</span><br><span class=\"line\">    if(err)&#123;</span><br><span class=\"line\">        console.log(&#39;[INSERT ERROR] - &#39;,err.message);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">    </span><br><span class=\"line\">    console.log(&#39;-------------INSERT---------------&#39;);</span><br><span class=\"line\">    &#x2F;&#x2F;console.log(&#39;INSERT ID:&#39;,result.insertId);        </span><br><span class=\"line\">    console.log(&#39;INSERT ID:&#39;,result);        </span><br><span class=\"line\">    console.log(&#39;----------------------------------\\n\\n&#39;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-3-改\"><a href=\"#13-3-改\" class=\"headerlink\" title=\"13.3 改\"></a>13.3 改</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var modSql &#x3D; &#39;UPDATE websites SET name &#x3D; ?,url &#x3D; ? WHERE Id &#x3D; ?&#39;;</span><br><span class=\"line\">var modSqlParams &#x3D; [&#39;菜鸟移动站&#39;, &#39;https:&#x2F;&#x2F;m.runoob.com&#39;,6];</span><br><span class=\"line\">&#x2F;&#x2F;改</span><br><span class=\"line\">connection.query(modSql,modSqlParams,function (err, result) &#123;</span><br><span class=\"line\">    if(err)&#123;</span><br><span class=\"line\">        console.log(&#39;[UPDATE ERROR] - &#39;,err.message);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">    console.log(&#39;-----------UPDATE-----------&#39;);</span><br><span class=\"line\">    console.log(&#39;UPDATE affectedRows&#39;,result.affectedRows);</span><br><span class=\"line\">    console.log(&#39;----------------------------\\n\\n&#39;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-4-删\"><a href=\"#13-4-删\" class=\"headerlink\" title=\"13.4 删\"></a>13.4 删</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var delSql &#x3D; &#39;DELETE FROM websites where id&#x3D;6&#39;;</span><br><span class=\"line\">&#x2F;&#x2F;删</span><br><span class=\"line\">connection.query(delSql,function (err, result) &#123;</span><br><span class=\"line\">    if(err)&#123;</span><br><span class=\"line\">        console.log(&#39;[DELETE ERROR] - &#39;,err.message);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">    </span><br><span class=\"line\">    console.log(&#39;-------------DELETE-------------&#39;);</span><br><span class=\"line\">    console.log(&#39;DELETE affectedRows&#39;,result.affectedRows);</span><br><span class=\"line\">    console.log(&#39;--------------------------------\\n\\n&#39;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-5-连接池\"><a href=\"#13-5-连接池\" class=\"headerlink\" title=\"13.5 连接池\"></a>13.5 连接池</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mysql &#x3D; require(&#39;mysql&#39;);</span><br><span class=\"line\">var pool  &#x3D; mysql.createPool(&#123;</span><br><span class=\"line\">    host: &#39;&#39;,</span><br><span class=\"line\">    user: &#39;&#39;,</span><br><span class=\"line\">    password: &#39;&#39;,</span><br><span class=\"line\">    port: &#39;&#39;,</span><br><span class=\"line\">    database: &#39;&#39;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">exports.query &#x3D; function(sql, cb)&#123;</span><br><span class=\"line\">    pool.getConnection(function(err, connection) &#123;</span><br><span class=\"line\">        connection.query(sql, cb);</span><br><span class=\"line\">        connection.release();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"React","date":"2018-08-08T06:25:00.000Z","updated":"2018-08-08T06:25:00.000Z","_content":"> 用于构建用户界面的 JavaScript 库，真的很好用！\n\n<!-- more -->\n\n# 1. 基础\n## 1.1 库\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      // ** Our code goes here! **\n    </script>\n  </body>\n</html>\n```\n上面代码一共用了三个库： `react.js` 、`react-dom.js` 和 `Browser.js`，它们必须首先加载。其中，`react.js` 是 React 的核心库，`react-dom.js` 是提供与 DOM 相关的功能，`Browser.js` 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。\n\n> babel src --out-dir build\n\n上面命令可以将 src 子目录的 js 文件进行语法转换，转码后的文件全部放在 build 子目录。\n## 1.2 ReactDOM.render\nReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。\n```\nReactDOM.render(\n  <h1>Hello, world!</h1>,\n  document.getElementById('example')\n);\n```\n上面代码将一个 h1 标题，插入 example 节点。\n\n# 2. JSX\nJSX 的基本语法规则：遇到 HTML 标签（以 < 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析\n```\nvar names = ['Alice', 'Emily', 'Kate'];\n\nReactDOM.render(\n  <div>\n  {\n    names.map(function (name) {\n      return <div>Hello, {name}!</div>\n    })\n  }\n  </div>,\n  document.getElementById('example')\n);\n```\n![][1]\n\narr变量是一个数组，结果 JSX 会把它的所有成员，添加到模板\n```\nvar arr = [\n  <h1>Hello world!</h1>,\n  <h2>React is awesome</h2>,\n];\nReactDOM.render(\n  <div>{arr}</div>,\n  document.getElementById('example')\n);\n```\n\n# 3. 组件\n- React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。\n\n- React.createClass 方法就用于生成一个组件类。\n```\nvar HelloMessage = React.createClass({\n  render: function() {\n    return <h1>Hello {this.props.name}</h1>;\n  }\n});\n\nReactDOM.render(\n  <HelloMessage name=\"John\" />,\n  document.getElementById('example')\n);\n```\n- 上面代码中，变量 `HelloMessage` 就是一个组件类。模板插入 `<HelloMessage />` 时，会自动生成 `HelloMessage` 的一个实例（下文的\"组件\"都指组件类的实例）。所有组件类都必须有自己的 `render` 方法，用于输出组件。\n\n- 注意，**组件类**的**第一个字母必须大写**，否则会报错，比如`HelloMessage`不能写成`helloMessage`。另外，组件类只能包含一个顶层标签，否则也会报错。\n\n- 组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 `<HelloMessage name=\"John\">` ，就是 `HelloMessage` 组件加入一个 `name` 属性，值为 `John`。\n\n- 组件的属性可以在组件类的 `this.props` 对象上获取，比如 `name` 属性就可以通过 `this.props.name` 读取\n\n- 添加组件属性， `class` 属性需要写成 `className` ，`for` 属性需要写成 `htmlFor`，因为是关键字\n\n# 4. this.props.children\n`this.props` 对象的属性与组件的属性一一对应，但是有一个例外，就是 `this.props.children` 属性。它表示组件的所有子节点。\n```\nvar NotesList = React.createClass({\n  render: function() {\n    return (\n      <ol>\n      {\n        React.Children.map(this.props.children, function (child) {\n          return <li>{child}</li>;\n        })\n      }\n      </ol>\n    );\n  }\n});\n\nReactDOM.render(\n  <NotesList>\n    <span>hello</span>\n    <span>world</span>\n  </NotesList>,\n  document.body\n);\n```\n上面代码的 `NoteList` 组件有两个 `span` 子节点，它们都可以通过 `this.props.children` 读取，运行结果如下。\n![][2]\n\n- 这里需要注意， `this.props.children`的值有三种可能：\n  - 如果当前组件没有子节点，它就是 `undefined`;\n  - 如果有一个子节点，数据类型是 `object`；\n  - 如果有多个子节点，数据类型就是 `array` 。所以，处理 this.props.children 的时候要小心。\n  - React 提供一个工具方法 [`React.Children`][3] 来处理`this.props.children` 。我们可以用 `React.Children.map` 来遍历子节点，而不用担心 `this.props.children` 的数据类型是 `undefined` 还是 `object`。\n\n# 5. PropTypes\n组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，**验证**别人使用组件时，**提供的参数是否符合要求**。\n\n组件类的`PropTypes`属性，就是用来验证组件实例的属性是否符合要求\n```\nvar data = 123;\n\nvar MyTitle = React.createClass({\n  propTypes: {\n    title: React.PropTypes.string.isRequired,\n  },\n  render: function() {\n     return <h1> {this.props.title} </h1>;\n   }\n});\n\nReactDOM.render(\n  <MyTitle title={data} />,\n  document.body\n);\n```\n上面的`Mytitle`组件有一个`title`属性。`PropTypes` 告诉 React，这个 `title` 属性是必须的，而且它的值必须是字符串。现在，我们设置 `title` 属性的值是一个数值。\n这样一来，`title`属性就通不过验证了。控制台会显示一行错误信息。\n> Warning: Failed propType: Invalid prop `title` of type `number` supplied to `MyTitle`, expected `string`.\n\n## 5.2 设置默认参数\n`getDefaultProps` 方法可以用来设置组件属性的默认值。\n```\nvar MyTitle = React.createClass({\n  getDefaultProps : function () {\n    return {\n      title : 'Hello World'\n    };\n  },\n\n  render: function() {\n     return <h1> {this.props.title} </h1>;\n   }\n});\n\nReactDOM.render(\n  <MyTitle />,\n  document.body\n);\n```\n> 上面代码会输出\"Hello World\"。\n\n# 6. 获取真实的DOM节点\n有时需要从组件获取真实 DOM 的节点，这时就要用到 `ref` 属性\n```\nvar MyComponent = React.createClass({\n  handleClick: function() {\n    this.refs.myTextInput.focus();\n  },\n  render: function() {\n    return (\n      <div>\n        <input type=\"text\" ref=\"myTextInput\" />\n        <input type=\"button\" value=\"Focus the text input\" onClick={this.handleClick} />\n      </div>\n    );\n  }\n});\n\nReactDOM.render(\n  <MyComponent />,\n  document.getElementById('example')\n);\n```\n上面代码中，组件 `MyComponent` 的子节点有一个文本输入框， 用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 `ref` 属性，然后 `this.refs.[refName]` 就会返回这个真实的 DOM 节点。\n需要注意的是，由于 `this.refs.[refName]` 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 上面代码中，通过为组件指定 `Click` 事件的回调函数，确保了只有等到真实 DOM 发生 `Click` 事件之后，才会读取 `this.refs.[refName]` 属性。\n\nReact 组件支持很多事件，除了 `Click` 事件以外，还有 `KeyDown` 、`Copy`、`Scroll` 等，完整的事件清单请查看[官方文档][4]。\n\n# 7. this.state\n组件免不了要与用户互动，React的一大创新，就是将组件看成是一个状态机，一开始有一个**初始状态**，然后用户互动，导致状态变化，从而触发重新渲染 UI\n## 7.1 LikeButton\n```\nvar LikeButton = React.createClass({\n  getInitialState: function() {\n    return {liked: false};\n  },\n  handleClick: function(event) {\n    this.setState({liked: !this.state.liked});\n  },\n  render: function() {\n    var text = this.state.liked ? 'like' : 'haven\\'t liked';\n    return (\n      <p onClick={this.handleClick}>\n        You {text} this. Click to toggle.\n      </p>\n    );\n  }\n});\n\nReactDOM.render(\n  <LikeButton />,\n  document.getElementById('example')\n);\n```\n上面代码是一个 `LikeButton` 组件，它的 `getInitialState` 方法用于定义初始状态，也就是一个对象，这个对象可以通过 `this.state` 属性读取。当用户点击组件，导致状态变化，`this.setState` 方法就修改状态值，每次修改以后，自动调用 `this.render` 方法，再次渲染组件。\n\n由于 `this.props` 和 `this.state` 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，`this.props` 表示那些一旦定义，就不再改变的特性，而 `this.state` 是会随着用户互动而产生变化的特性。\n\n## 7.2 表单\n```\nvar Input = React.createClass({\n  getInitialState: function() {\n    return {value: 'Hello!'};\n  },\n  handleChange: function(event) {\n    this.setState({value: event.target.value});\n  },\n  render: function () {\n    var value = this.state.value;\n    return (\n      <div>\n        <input type=\"text\" value={value} onChange={this.handleChange} />\n        <p>{value}</p>\n      </div>\n    );\n  }\n});\n\nReactDOM.render(<Input/>, document.body);\n```\n上面代码中，文本输入框的值，不能用 `this.props.value` 读取，而要定义一个 `onChange` 事件的回调函数，通过 `event.target.value` 读取用户输入的值。\n`textarea` 元素、`select`元素、`radio`元素都属于这种情况，更多介绍请参考官方文档。\n\n# 8. 组件的生命周期\n组件的生命周期分成三个状态：\n>- Mounting：已插入真实 DOM\n- Updating：正在被重新渲染\n- Unmounting：已移出真实 DOM\n\nReact 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。\n\n> - componentWillMount()\n- componentDidMount()\n- componentWillUpdate(object nextProps, object nextState)\n- componentDidUpdate(object prevProps, object prevState)\n- componentWillUnmount()\n\n此外，React 还提供两种特殊状态的处理函数。\n> - componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用\n- shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用\n\n```\nvar Hello = React.createClass({\n  getInitialState: function () {\n    return {\n      opacity: 1.0\n    };\n  },\n\n  componentDidMount: function () {\n    this.timer = setInterval(function () {\n      var opacity = this.state.opacity;\n      opacity -= .05;\n      if (opacity < 0.1) {\n        opacity = 1.0;\n      }\n      this.setState({\n        opacity: opacity\n      });\n    }.bind(this), 100);\n  },\n\n  render: function () {\n    return (\n      <div style={{opacity: this.state.opacity}}>\n        Hello {this.props.name}\n      </div>\n    );\n  }\n});\n\nReactDOM.render(\n  <Hello name=\"world\"/>,\n  document.body\n);\n```\n上面代码在`Hello`组件加载以后，通过 `componentDidMount` 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。\n另外，组件的style属性的设置方式也值得注意 `style={ {opacity: this.state.opacity} } `\nReact 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。\n\n# 9. Ajax\n组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 `componentDidMount` 方法设置 Ajax 请求，等到请求成功，再用 `this.setState` 方法重新渲染 UI\n\n```\nvar UserGist = React.createClass({\n  getInitialState: function() {\n    return {\n      username: '',\n      lastGistUrl: ''\n    };\n  },\n\n  componentDidMount: function() {\n    $.get(this.props.source, function(result) {\n      var lastGist = result[0];\n      if (this.isMounted()) {\n        this.setState({\n          username: lastGist.owner.login,\n          lastGistUrl: lastGist.html_url\n        });\n      }\n    }.bind(this));\n  },\n\n  render: function() {\n    return (\n      <div>\n        {this.state.username}'s last gist is\n        <a href={this.state.lastGistUrl}>here</a>.\n      </div>\n    );\n  }\n});\n\nReactDOM.render(\n  <UserGist source=\"https://api.github.com/users/octocat/gists\" />,\n  document.body\n);\n```\n\n\n\n\n\n  [1]: http://www.ruanyifeng.com/blogimg/asset/2015/bg2015033106.png\n  [2]: http://www.ruanyifeng.com/blogimg/asset/2015/bg2015033110.png\n  [3]: https://facebook.github.io/react/docs/top-level-api.html#react.children\n  [4]: http://facebook.github.io/react/docs/events.html#supported-events","source":"_posts/2018/React.md","raw":"---\ntitle: React\ndate: 2018-08-08 14:25\nupdated: 2018-08-08 14:25\ntags: Node.js\n---\n> 用于构建用户界面的 JavaScript 库，真的很好用！\n\n<!-- more -->\n\n# 1. 基础\n## 1.1 库\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      // ** Our code goes here! **\n    </script>\n  </body>\n</html>\n```\n上面代码一共用了三个库： `react.js` 、`react-dom.js` 和 `Browser.js`，它们必须首先加载。其中，`react.js` 是 React 的核心库，`react-dom.js` 是提供与 DOM 相关的功能，`Browser.js` 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。\n\n> babel src --out-dir build\n\n上面命令可以将 src 子目录的 js 文件进行语法转换，转码后的文件全部放在 build 子目录。\n## 1.2 ReactDOM.render\nReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。\n```\nReactDOM.render(\n  <h1>Hello, world!</h1>,\n  document.getElementById('example')\n);\n```\n上面代码将一个 h1 标题，插入 example 节点。\n\n# 2. JSX\nJSX 的基本语法规则：遇到 HTML 标签（以 < 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析\n```\nvar names = ['Alice', 'Emily', 'Kate'];\n\nReactDOM.render(\n  <div>\n  {\n    names.map(function (name) {\n      return <div>Hello, {name}!</div>\n    })\n  }\n  </div>,\n  document.getElementById('example')\n);\n```\n![][1]\n\narr变量是一个数组，结果 JSX 会把它的所有成员，添加到模板\n```\nvar arr = [\n  <h1>Hello world!</h1>,\n  <h2>React is awesome</h2>,\n];\nReactDOM.render(\n  <div>{arr}</div>,\n  document.getElementById('example')\n);\n```\n\n# 3. 组件\n- React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。\n\n- React.createClass 方法就用于生成一个组件类。\n```\nvar HelloMessage = React.createClass({\n  render: function() {\n    return <h1>Hello {this.props.name}</h1>;\n  }\n});\n\nReactDOM.render(\n  <HelloMessage name=\"John\" />,\n  document.getElementById('example')\n);\n```\n- 上面代码中，变量 `HelloMessage` 就是一个组件类。模板插入 `<HelloMessage />` 时，会自动生成 `HelloMessage` 的一个实例（下文的\"组件\"都指组件类的实例）。所有组件类都必须有自己的 `render` 方法，用于输出组件。\n\n- 注意，**组件类**的**第一个字母必须大写**，否则会报错，比如`HelloMessage`不能写成`helloMessage`。另外，组件类只能包含一个顶层标签，否则也会报错。\n\n- 组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 `<HelloMessage name=\"John\">` ，就是 `HelloMessage` 组件加入一个 `name` 属性，值为 `John`。\n\n- 组件的属性可以在组件类的 `this.props` 对象上获取，比如 `name` 属性就可以通过 `this.props.name` 读取\n\n- 添加组件属性， `class` 属性需要写成 `className` ，`for` 属性需要写成 `htmlFor`，因为是关键字\n\n# 4. this.props.children\n`this.props` 对象的属性与组件的属性一一对应，但是有一个例外，就是 `this.props.children` 属性。它表示组件的所有子节点。\n```\nvar NotesList = React.createClass({\n  render: function() {\n    return (\n      <ol>\n      {\n        React.Children.map(this.props.children, function (child) {\n          return <li>{child}</li>;\n        })\n      }\n      </ol>\n    );\n  }\n});\n\nReactDOM.render(\n  <NotesList>\n    <span>hello</span>\n    <span>world</span>\n  </NotesList>,\n  document.body\n);\n```\n上面代码的 `NoteList` 组件有两个 `span` 子节点，它们都可以通过 `this.props.children` 读取，运行结果如下。\n![][2]\n\n- 这里需要注意， `this.props.children`的值有三种可能：\n  - 如果当前组件没有子节点，它就是 `undefined`;\n  - 如果有一个子节点，数据类型是 `object`；\n  - 如果有多个子节点，数据类型就是 `array` 。所以，处理 this.props.children 的时候要小心。\n  - React 提供一个工具方法 [`React.Children`][3] 来处理`this.props.children` 。我们可以用 `React.Children.map` 来遍历子节点，而不用担心 `this.props.children` 的数据类型是 `undefined` 还是 `object`。\n\n# 5. PropTypes\n组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，**验证**别人使用组件时，**提供的参数是否符合要求**。\n\n组件类的`PropTypes`属性，就是用来验证组件实例的属性是否符合要求\n```\nvar data = 123;\n\nvar MyTitle = React.createClass({\n  propTypes: {\n    title: React.PropTypes.string.isRequired,\n  },\n  render: function() {\n     return <h1> {this.props.title} </h1>;\n   }\n});\n\nReactDOM.render(\n  <MyTitle title={data} />,\n  document.body\n);\n```\n上面的`Mytitle`组件有一个`title`属性。`PropTypes` 告诉 React，这个 `title` 属性是必须的，而且它的值必须是字符串。现在，我们设置 `title` 属性的值是一个数值。\n这样一来，`title`属性就通不过验证了。控制台会显示一行错误信息。\n> Warning: Failed propType: Invalid prop `title` of type `number` supplied to `MyTitle`, expected `string`.\n\n## 5.2 设置默认参数\n`getDefaultProps` 方法可以用来设置组件属性的默认值。\n```\nvar MyTitle = React.createClass({\n  getDefaultProps : function () {\n    return {\n      title : 'Hello World'\n    };\n  },\n\n  render: function() {\n     return <h1> {this.props.title} </h1>;\n   }\n});\n\nReactDOM.render(\n  <MyTitle />,\n  document.body\n);\n```\n> 上面代码会输出\"Hello World\"。\n\n# 6. 获取真实的DOM节点\n有时需要从组件获取真实 DOM 的节点，这时就要用到 `ref` 属性\n```\nvar MyComponent = React.createClass({\n  handleClick: function() {\n    this.refs.myTextInput.focus();\n  },\n  render: function() {\n    return (\n      <div>\n        <input type=\"text\" ref=\"myTextInput\" />\n        <input type=\"button\" value=\"Focus the text input\" onClick={this.handleClick} />\n      </div>\n    );\n  }\n});\n\nReactDOM.render(\n  <MyComponent />,\n  document.getElementById('example')\n);\n```\n上面代码中，组件 `MyComponent` 的子节点有一个文本输入框， 用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 `ref` 属性，然后 `this.refs.[refName]` 就会返回这个真实的 DOM 节点。\n需要注意的是，由于 `this.refs.[refName]` 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 上面代码中，通过为组件指定 `Click` 事件的回调函数，确保了只有等到真实 DOM 发生 `Click` 事件之后，才会读取 `this.refs.[refName]` 属性。\n\nReact 组件支持很多事件，除了 `Click` 事件以外，还有 `KeyDown` 、`Copy`、`Scroll` 等，完整的事件清单请查看[官方文档][4]。\n\n# 7. this.state\n组件免不了要与用户互动，React的一大创新，就是将组件看成是一个状态机，一开始有一个**初始状态**，然后用户互动，导致状态变化，从而触发重新渲染 UI\n## 7.1 LikeButton\n```\nvar LikeButton = React.createClass({\n  getInitialState: function() {\n    return {liked: false};\n  },\n  handleClick: function(event) {\n    this.setState({liked: !this.state.liked});\n  },\n  render: function() {\n    var text = this.state.liked ? 'like' : 'haven\\'t liked';\n    return (\n      <p onClick={this.handleClick}>\n        You {text} this. Click to toggle.\n      </p>\n    );\n  }\n});\n\nReactDOM.render(\n  <LikeButton />,\n  document.getElementById('example')\n);\n```\n上面代码是一个 `LikeButton` 组件，它的 `getInitialState` 方法用于定义初始状态，也就是一个对象，这个对象可以通过 `this.state` 属性读取。当用户点击组件，导致状态变化，`this.setState` 方法就修改状态值，每次修改以后，自动调用 `this.render` 方法，再次渲染组件。\n\n由于 `this.props` 和 `this.state` 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，`this.props` 表示那些一旦定义，就不再改变的特性，而 `this.state` 是会随着用户互动而产生变化的特性。\n\n## 7.2 表单\n```\nvar Input = React.createClass({\n  getInitialState: function() {\n    return {value: 'Hello!'};\n  },\n  handleChange: function(event) {\n    this.setState({value: event.target.value});\n  },\n  render: function () {\n    var value = this.state.value;\n    return (\n      <div>\n        <input type=\"text\" value={value} onChange={this.handleChange} />\n        <p>{value}</p>\n      </div>\n    );\n  }\n});\n\nReactDOM.render(<Input/>, document.body);\n```\n上面代码中，文本输入框的值，不能用 `this.props.value` 读取，而要定义一个 `onChange` 事件的回调函数，通过 `event.target.value` 读取用户输入的值。\n`textarea` 元素、`select`元素、`radio`元素都属于这种情况，更多介绍请参考官方文档。\n\n# 8. 组件的生命周期\n组件的生命周期分成三个状态：\n>- Mounting：已插入真实 DOM\n- Updating：正在被重新渲染\n- Unmounting：已移出真实 DOM\n\nReact 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。\n\n> - componentWillMount()\n- componentDidMount()\n- componentWillUpdate(object nextProps, object nextState)\n- componentDidUpdate(object prevProps, object prevState)\n- componentWillUnmount()\n\n此外，React 还提供两种特殊状态的处理函数。\n> - componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用\n- shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用\n\n```\nvar Hello = React.createClass({\n  getInitialState: function () {\n    return {\n      opacity: 1.0\n    };\n  },\n\n  componentDidMount: function () {\n    this.timer = setInterval(function () {\n      var opacity = this.state.opacity;\n      opacity -= .05;\n      if (opacity < 0.1) {\n        opacity = 1.0;\n      }\n      this.setState({\n        opacity: opacity\n      });\n    }.bind(this), 100);\n  },\n\n  render: function () {\n    return (\n      <div style={{opacity: this.state.opacity}}>\n        Hello {this.props.name}\n      </div>\n    );\n  }\n});\n\nReactDOM.render(\n  <Hello name=\"world\"/>,\n  document.body\n);\n```\n上面代码在`Hello`组件加载以后，通过 `componentDidMount` 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。\n另外，组件的style属性的设置方式也值得注意 `style={ {opacity: this.state.opacity} } `\nReact 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。\n\n# 9. Ajax\n组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 `componentDidMount` 方法设置 Ajax 请求，等到请求成功，再用 `this.setState` 方法重新渲染 UI\n\n```\nvar UserGist = React.createClass({\n  getInitialState: function() {\n    return {\n      username: '',\n      lastGistUrl: ''\n    };\n  },\n\n  componentDidMount: function() {\n    $.get(this.props.source, function(result) {\n      var lastGist = result[0];\n      if (this.isMounted()) {\n        this.setState({\n          username: lastGist.owner.login,\n          lastGistUrl: lastGist.html_url\n        });\n      }\n    }.bind(this));\n  },\n\n  render: function() {\n    return (\n      <div>\n        {this.state.username}'s last gist is\n        <a href={this.state.lastGistUrl}>here</a>.\n      </div>\n    );\n  }\n});\n\nReactDOM.render(\n  <UserGist source=\"https://api.github.com/users/octocat/gists\" />,\n  document.body\n);\n```\n\n\n\n\n\n  [1]: http://www.ruanyifeng.com/blogimg/asset/2015/bg2015033106.png\n  [2]: http://www.ruanyifeng.com/blogimg/asset/2015/bg2015033110.png\n  [3]: https://facebook.github.io/react/docs/top-level-api.html#react.children\n  [4]: http://facebook.github.io/react/docs/events.html#supported-events","slug":"2018-React","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrjx000e2yku9jaf85yj","content":"<blockquote>\n<p>用于构建用户界面的 JavaScript 库，真的很好用！</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h1 id=\"1-基础\"><a href=\"#1-基础\" class=\"headerlink\" title=\"1. 基础\"></a>1. 基础</h1><h2 id=\"1-1-库\"><a href=\"#1-1-库\" class=\"headerlink\" title=\"1.1 库\"></a>1.1 库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;script src&#x3D;&quot;..&#x2F;build&#x2F;react.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">    &lt;script src&#x3D;&quot;..&#x2F;build&#x2F;react-dom.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">    &lt;script src&#x3D;&quot;..&#x2F;build&#x2F;browser.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">  &lt;&#x2F;head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;div id&#x3D;&quot;example&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;script type&#x3D;&quot;text&#x2F;babel&quot;&gt;</span><br><span class=\"line\">      &#x2F;&#x2F; ** Our code goes here! **</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">  &lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n<p>上面代码一共用了三个库： <code>react.js</code> 、<code>react-dom.js</code> 和 <code>Browser.js</code>，它们必须首先加载。其中，<code>react.js</code> 是 React 的核心库，<code>react-dom.js</code> 是提供与 DOM 相关的功能，<code>Browser.js</code> 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。</p>\n<blockquote>\n<p>babel src –out-dir build</p>\n</blockquote>\n<p>上面命令可以将 src 子目录的 js 文件进行语法转换，转码后的文件全部放在 build 子目录。</p>\n<h2 id=\"1-2-ReactDOM-render\"><a href=\"#1-2-ReactDOM-render\" class=\"headerlink\" title=\"1.2 ReactDOM.render\"></a>1.2 ReactDOM.render</h2><p>ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt;,</span><br><span class=\"line\">  document.getElementById(&#39;example&#39;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>上面代码将一个 h1 标题，插入 example 节点。</p>\n<h1 id=\"2-JSX\"><a href=\"#2-JSX\" class=\"headerlink\" title=\"2. JSX\"></a>2. JSX</h1><p>JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var names &#x3D; [&#39;Alice&#39;, &#39;Emily&#39;, &#39;Kate&#39;];</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    names.map(function (name) &#123;</span><br><span class=\"line\">      return &lt;div&gt;Hello, &#123;name&#125;!&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;,</span><br><span class=\"line\">  document.getElementById(&#39;example&#39;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015033106.png\"></p>\n<p>arr变量是一个数组，结果 JSX 会把它的所有成员，添加到模板</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr &#x3D; [</span><br><span class=\"line\">  &lt;h1&gt;Hello world!&lt;&#x2F;h1&gt;,</span><br><span class=\"line\">  &lt;h2&gt;React is awesome&lt;&#x2F;h2&gt;,</span><br><span class=\"line\">];</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;div&gt;&#123;arr&#125;&lt;&#x2F;div&gt;,</span><br><span class=\"line\">  document.getElementById(&#39;example&#39;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-组件\"><a href=\"#3-组件\" class=\"headerlink\" title=\"3. 组件\"></a>3. 组件</h1><ul>\n<li><p>React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。</p>\n</li>\n<li><p>React.createClass 方法就用于生成一个组件类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var HelloMessage &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">    return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;HelloMessage name&#x3D;&quot;John&quot; &#x2F;&gt;,</span><br><span class=\"line\">  document.getElementById(&#39;example&#39;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li>\n<li><p>上面代码中，变量 <code>HelloMessage</code> 就是一个组件类。模板插入 <code>&lt;HelloMessage /&gt;</code> 时，会自动生成 <code>HelloMessage</code> 的一个实例（下文的”组件”都指组件类的实例）。所有组件类都必须有自己的 <code>render</code> 方法，用于输出组件。</p>\n</li>\n<li><p>注意，<strong>组件类</strong>的<strong>第一个字母必须大写</strong>，否则会报错，比如<code>HelloMessage</code>不能写成<code>helloMessage</code>。另外，组件类只能包含一个顶层标签，否则也会报错。</p>\n</li>\n<li><p>组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 <code>&lt;HelloMessage name=&quot;John&quot;&gt;</code> ，就是 <code>HelloMessage</code> 组件加入一个 <code>name</code> 属性，值为 <code>John</code>。</p>\n</li>\n<li><p>组件的属性可以在组件类的 <code>this.props</code> 对象上获取，比如 <code>name</code> 属性就可以通过 <code>this.props.name</code> 读取</p>\n</li>\n<li><p>添加组件属性， <code>class</code> 属性需要写成 <code>className</code> ，<code>for</code> 属性需要写成 <code>htmlFor</code>，因为是关键字</p>\n</li>\n</ul>\n<h1 id=\"4-this-props-children\"><a href=\"#4-this-props-children\" class=\"headerlink\" title=\"4. this.props.children\"></a>4. this.props.children</h1><p><code>this.props</code> 对象的属性与组件的属性一一对应，但是有一个例外，就是 <code>this.props.children</code> 属性。它表示组件的所有子节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var NotesList &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;ol&gt;</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        React.Children.map(this.props.children, function (child) &#123;</span><br><span class=\"line\">          return &lt;li&gt;&#123;child&#125;&lt;&#x2F;li&gt;;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      &lt;&#x2F;ol&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;NotesList&gt;</span><br><span class=\"line\">    &lt;span&gt;hello&lt;&#x2F;span&gt;</span><br><span class=\"line\">    &lt;span&gt;world&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;&#x2F;NotesList&gt;,</span><br><span class=\"line\">  document.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>上面代码的 <code>NoteList</code> 组件有两个 <code>span</code> 子节点，它们都可以通过 <code>this.props.children</code> 读取，运行结果如下。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015033110.png\"></p>\n<ul>\n<li>这里需要注意， <code>this.props.children</code>的值有三种可能：<ul>\n<li>如果当前组件没有子节点，它就是 <code>undefined</code>;</li>\n<li>如果有一个子节点，数据类型是 <code>object</code>；</li>\n<li>如果有多个子节点，数据类型就是 <code>array</code> 。所以，处理 this.props.children 的时候要小心。</li>\n<li>React 提供一个工具方法 <a href=\"https://facebook.github.io/react/docs/top-level-api.html#react.children\"><code>React.Children</code></a> 来处理<code>this.props.children</code> 。我们可以用 <code>React.Children.map</code> 来遍历子节点，而不用担心 <code>this.props.children</code> 的数据类型是 <code>undefined</code> 还是 <code>object</code>。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"5-PropTypes\"><a href=\"#5-PropTypes\" class=\"headerlink\" title=\"5. PropTypes\"></a>5. PropTypes</h1><p>组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，<strong>验证</strong>别人使用组件时，<strong>提供的参数是否符合要求</strong>。</p>\n<p>组件类的<code>PropTypes</code>属性，就是用来验证组件实例的属性是否符合要求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data &#x3D; 123;</span><br><span class=\"line\"></span><br><span class=\"line\">var MyTitle &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  propTypes: &#123;</span><br><span class=\"line\">    title: React.PropTypes.string.isRequired,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">     return &lt;h1&gt; &#123;this.props.title&#125; &lt;&#x2F;h1&gt;;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;MyTitle title&#x3D;&#123;data&#125; &#x2F;&gt;,</span><br><span class=\"line\">  document.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>上面的<code>Mytitle</code>组件有一个<code>title</code>属性。<code>PropTypes</code> 告诉 React，这个 <code>title</code> 属性是必须的，而且它的值必须是字符串。现在，我们设置 <code>title</code> 属性的值是一个数值。<br>这样一来，<code>title</code>属性就通不过验证了。控制台会显示一行错误信息。</p>\n<blockquote>\n<p>Warning: Failed propType: Invalid prop <code>title</code> of type <code>number</code> supplied to <code>MyTitle</code>, expected <code>string</code>.</p>\n</blockquote>\n<h2 id=\"5-2-设置默认参数\"><a href=\"#5-2-设置默认参数\" class=\"headerlink\" title=\"5.2 设置默认参数\"></a>5.2 设置默认参数</h2><p><code>getDefaultProps</code> 方法可以用来设置组件属性的默认值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var MyTitle &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  getDefaultProps : function () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      title : &#39;Hello World&#39;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">     return &lt;h1&gt; &#123;this.props.title&#125; &lt;&#x2F;h1&gt;;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;MyTitle &#x2F;&gt;,</span><br><span class=\"line\">  document.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面代码会输出”Hello World”。</p>\n</blockquote>\n<h1 id=\"6-获取真实的DOM节点\"><a href=\"#6-获取真实的DOM节点\" class=\"headerlink\" title=\"6. 获取真实的DOM节点\"></a>6. 获取真实的DOM节点</h1><p>有时需要从组件获取真实 DOM 的节点，这时就要用到 <code>ref</code> 属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var MyComponent &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  handleClick: function() &#123;</span><br><span class=\"line\">    this.refs.myTextInput.focus();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&quot;myTextInput&quot; &#x2F;&gt;</span><br><span class=\"line\">        &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;Focus the text input&quot; onClick&#x3D;&#123;this.handleClick&#125; &#x2F;&gt;</span><br><span class=\"line\">      &lt;&#x2F;div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;MyComponent &#x2F;&gt;,</span><br><span class=\"line\">  document.getElementById(&#39;example&#39;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，组件 <code>MyComponent</code> 的子节点有一个文本输入框， 用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 <code>ref</code> 属性，然后 <code>this.refs.[refName]</code> 就会返回这个真实的 DOM 节点。<br>需要注意的是，由于 <code>this.refs.[refName]</code> 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 上面代码中，通过为组件指定 <code>Click</code> 事件的回调函数，确保了只有等到真实 DOM 发生 <code>Click</code> 事件之后，才会读取 <code>this.refs.[refName]</code> 属性。</p>\n<p>React 组件支持很多事件，除了 <code>Click</code> 事件以外，还有 <code>KeyDown</code> 、<code>Copy</code>、<code>Scroll</code> 等，完整的事件清单请查看<a href=\"http://facebook.github.io/react/docs/events.html#supported-events\">官方文档</a>。</p>\n<h1 id=\"7-this-state\"><a href=\"#7-this-state\" class=\"headerlink\" title=\"7. this.state\"></a>7. this.state</h1><p>组件免不了要与用户互动，React的一大创新，就是将组件看成是一个状态机，一开始有一个<strong>初始状态</strong>，然后用户互动，导致状态变化，从而触发重新渲染 UI</p>\n<h2 id=\"7-1-LikeButton\"><a href=\"#7-1-LikeButton\" class=\"headerlink\" title=\"7.1 LikeButton\"></a>7.1 LikeButton</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var LikeButton &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: function() &#123;</span><br><span class=\"line\">    return &#123;liked: false&#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  handleClick: function(event) &#123;</span><br><span class=\"line\">    this.setState(&#123;liked: !this.state.liked&#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">    var text &#x3D; this.state.liked ? &#39;like&#39; : &#39;haven\\&#39;t liked&#39;;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;p onClick&#x3D;&#123;this.handleClick&#125;&gt;</span><br><span class=\"line\">        You &#123;text&#125; this. Click to toggle.</span><br><span class=\"line\">      &lt;&#x2F;p&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;LikeButton &#x2F;&gt;,</span><br><span class=\"line\">  document.getElementById(&#39;example&#39;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>上面代码是一个 <code>LikeButton</code> 组件，它的 <code>getInitialState</code> 方法用于定义初始状态，也就是一个对象，这个对象可以通过 <code>this.state</code> 属性读取。当用户点击组件，导致状态变化，<code>this.setState</code> 方法就修改状态值，每次修改以后，自动调用 <code>this.render</code> 方法，再次渲染组件。</p>\n<p>由于 <code>this.props</code> 和 <code>this.state</code> 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，<code>this.props</code> 表示那些一旦定义，就不再改变的特性，而 <code>this.state</code> 是会随着用户互动而产生变化的特性。</p>\n<h2 id=\"7-2-表单\"><a href=\"#7-2-表单\" class=\"headerlink\" title=\"7.2 表单\"></a>7.2 表单</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Input &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: function() &#123;</span><br><span class=\"line\">    return &#123;value: &#39;Hello!&#39;&#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  handleChange: function(event) &#123;</span><br><span class=\"line\">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: function () &#123;</span><br><span class=\"line\">    var value &#x3D; this.state.value;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;value&#125; onChange&#x3D;&#123;this.handleChange&#125; &#x2F;&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;value&#125;&lt;&#x2F;p&gt;</span><br><span class=\"line\">      &lt;&#x2F;div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(&lt;Input&#x2F;&gt;, document.body);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，文本输入框的值，不能用 <code>this.props.value</code> 读取，而要定义一个 <code>onChange</code> 事件的回调函数，通过 <code>event.target.value</code> 读取用户输入的值。<br><code>textarea</code> 元素、<code>select</code>元素、<code>radio</code>元素都属于这种情况，更多介绍请参考官方文档。</p>\n<h1 id=\"8-组件的生命周期\"><a href=\"#8-组件的生命周期\" class=\"headerlink\" title=\"8. 组件的生命周期\"></a>8. 组件的生命周期</h1><p>组件的生命周期分成三个状态：</p>\n<blockquote>\n<ul>\n<li>Mounting：已插入真实 DOM</li>\n</ul>\n</blockquote>\n<ul>\n<li>Updating：正在被重新渲染</li>\n<li>Unmounting：已移出真实 DOM</li>\n</ul>\n<p>React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。</p>\n<blockquote>\n<ul>\n<li>componentWillMount()</li>\n</ul>\n</blockquote>\n<ul>\n<li>componentDidMount()</li>\n<li>componentWillUpdate(object nextProps, object nextState)</li>\n<li>componentDidUpdate(object prevProps, object prevState)</li>\n<li>componentWillUnmount()</li>\n</ul>\n<p>此外，React 还提供两种特殊状态的处理函数。</p>\n<blockquote>\n<ul>\n<li>componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用</li>\n</ul>\n</blockquote>\n<ul>\n<li>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Hello &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: function () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      opacity: 1.0</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount: function () &#123;</span><br><span class=\"line\">    this.timer &#x3D; setInterval(function () &#123;</span><br><span class=\"line\">      var opacity &#x3D; this.state.opacity;</span><br><span class=\"line\">      opacity -&#x3D; .05;</span><br><span class=\"line\">      if (opacity &lt; 0.1) &#123;</span><br><span class=\"line\">        opacity &#x3D; 1.0;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.setState(&#123;</span><br><span class=\"line\">        opacity: opacity</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;.bind(this), 100);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  render: function () &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div style&#x3D;&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt;</span><br><span class=\"line\">        Hello &#123;this.props.name&#125;</span><br><span class=\"line\">      &lt;&#x2F;div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Hello name&#x3D;&quot;world&quot;&#x2F;&gt;,</span><br><span class=\"line\">  document.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>上面代码在<code>Hello</code>组件加载以后，通过 <code>componentDidMount</code> 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。<br>另外，组件的style属性的设置方式也值得注意 <code>style=&#123; &#123;opacity: this.state.opacity&#125; &#125; </code><br>React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。</p>\n<h1 id=\"9-Ajax\"><a href=\"#9-Ajax\" class=\"headerlink\" title=\"9. Ajax\"></a>9. Ajax</h1><p>组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 <code>componentDidMount</code> 方法设置 Ajax 请求，等到请求成功，再用 <code>this.setState</code> 方法重新渲染 UI</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var UserGist &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: function() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      username: &#39;&#39;,</span><br><span class=\"line\">      lastGistUrl: &#39;&#39;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount: function() &#123;</span><br><span class=\"line\">    $.get(this.props.source, function(result) &#123;</span><br><span class=\"line\">      var lastGist &#x3D; result[0];</span><br><span class=\"line\">      if (this.isMounted()) &#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">          username: lastGist.owner.login,</span><br><span class=\"line\">          lastGistUrl: lastGist.html_url</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;.bind(this));</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;this.state.username&#125;&#39;s last gist is</span><br><span class=\"line\">        &lt;a href&#x3D;&#123;this.state.lastGistUrl&#125;&gt;here&lt;&#x2F;a&gt;.</span><br><span class=\"line\">      &lt;&#x2F;div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;UserGist source&#x3D;&quot;https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;octocat&#x2F;gists&quot; &#x2F;&gt;,</span><br><span class=\"line\">  document.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>用于构建用户界面的 JavaScript 库，真的很好用！</p>\n</blockquote>","more":"<h1 id=\"1-基础\"><a href=\"#1-基础\" class=\"headerlink\" title=\"1. 基础\"></a>1. 基础</h1><h2 id=\"1-1-库\"><a href=\"#1-1-库\" class=\"headerlink\" title=\"1.1 库\"></a>1.1 库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;script src&#x3D;&quot;..&#x2F;build&#x2F;react.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">    &lt;script src&#x3D;&quot;..&#x2F;build&#x2F;react-dom.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">    &lt;script src&#x3D;&quot;..&#x2F;build&#x2F;browser.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">  &lt;&#x2F;head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;div id&#x3D;&quot;example&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;script type&#x3D;&quot;text&#x2F;babel&quot;&gt;</span><br><span class=\"line\">      &#x2F;&#x2F; ** Our code goes here! **</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">  &lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n<p>上面代码一共用了三个库： <code>react.js</code> 、<code>react-dom.js</code> 和 <code>Browser.js</code>，它们必须首先加载。其中，<code>react.js</code> 是 React 的核心库，<code>react-dom.js</code> 是提供与 DOM 相关的功能，<code>Browser.js</code> 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。</p>\n<blockquote>\n<p>babel src –out-dir build</p>\n</blockquote>\n<p>上面命令可以将 src 子目录的 js 文件进行语法转换，转码后的文件全部放在 build 子目录。</p>\n<h2 id=\"1-2-ReactDOM-render\"><a href=\"#1-2-ReactDOM-render\" class=\"headerlink\" title=\"1.2 ReactDOM.render\"></a>1.2 ReactDOM.render</h2><p>ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt;,</span><br><span class=\"line\">  document.getElementById(&#39;example&#39;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>上面代码将一个 h1 标题，插入 example 节点。</p>\n<h1 id=\"2-JSX\"><a href=\"#2-JSX\" class=\"headerlink\" title=\"2. JSX\"></a>2. JSX</h1><p>JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var names &#x3D; [&#39;Alice&#39;, &#39;Emily&#39;, &#39;Kate&#39;];</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    names.map(function (name) &#123;</span><br><span class=\"line\">      return &lt;div&gt;Hello, &#123;name&#125;!&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;,</span><br><span class=\"line\">  document.getElementById(&#39;example&#39;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015033106.png\"></p>\n<p>arr变量是一个数组，结果 JSX 会把它的所有成员，添加到模板</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr &#x3D; [</span><br><span class=\"line\">  &lt;h1&gt;Hello world!&lt;&#x2F;h1&gt;,</span><br><span class=\"line\">  &lt;h2&gt;React is awesome&lt;&#x2F;h2&gt;,</span><br><span class=\"line\">];</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;div&gt;&#123;arr&#125;&lt;&#x2F;div&gt;,</span><br><span class=\"line\">  document.getElementById(&#39;example&#39;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-组件\"><a href=\"#3-组件\" class=\"headerlink\" title=\"3. 组件\"></a>3. 组件</h1><ul>\n<li><p>React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。</p>\n</li>\n<li><p>React.createClass 方法就用于生成一个组件类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var HelloMessage &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">    return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;HelloMessage name&#x3D;&quot;John&quot; &#x2F;&gt;,</span><br><span class=\"line\">  document.getElementById(&#39;example&#39;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li>\n<li><p>上面代码中，变量 <code>HelloMessage</code> 就是一个组件类。模板插入 <code>&lt;HelloMessage /&gt;</code> 时，会自动生成 <code>HelloMessage</code> 的一个实例（下文的”组件”都指组件类的实例）。所有组件类都必须有自己的 <code>render</code> 方法，用于输出组件。</p>\n</li>\n<li><p>注意，<strong>组件类</strong>的<strong>第一个字母必须大写</strong>，否则会报错，比如<code>HelloMessage</code>不能写成<code>helloMessage</code>。另外，组件类只能包含一个顶层标签，否则也会报错。</p>\n</li>\n<li><p>组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 <code>&lt;HelloMessage name=&quot;John&quot;&gt;</code> ，就是 <code>HelloMessage</code> 组件加入一个 <code>name</code> 属性，值为 <code>John</code>。</p>\n</li>\n<li><p>组件的属性可以在组件类的 <code>this.props</code> 对象上获取，比如 <code>name</code> 属性就可以通过 <code>this.props.name</code> 读取</p>\n</li>\n<li><p>添加组件属性， <code>class</code> 属性需要写成 <code>className</code> ，<code>for</code> 属性需要写成 <code>htmlFor</code>，因为是关键字</p>\n</li>\n</ul>\n<h1 id=\"4-this-props-children\"><a href=\"#4-this-props-children\" class=\"headerlink\" title=\"4. this.props.children\"></a>4. this.props.children</h1><p><code>this.props</code> 对象的属性与组件的属性一一对应，但是有一个例外，就是 <code>this.props.children</code> 属性。它表示组件的所有子节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var NotesList &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;ol&gt;</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        React.Children.map(this.props.children, function (child) &#123;</span><br><span class=\"line\">          return &lt;li&gt;&#123;child&#125;&lt;&#x2F;li&gt;;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      &lt;&#x2F;ol&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;NotesList&gt;</span><br><span class=\"line\">    &lt;span&gt;hello&lt;&#x2F;span&gt;</span><br><span class=\"line\">    &lt;span&gt;world&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;&#x2F;NotesList&gt;,</span><br><span class=\"line\">  document.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>上面代码的 <code>NoteList</code> 组件有两个 <code>span</code> 子节点，它们都可以通过 <code>this.props.children</code> 读取，运行结果如下。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015033110.png\"></p>\n<ul>\n<li>这里需要注意， <code>this.props.children</code>的值有三种可能：<ul>\n<li>如果当前组件没有子节点，它就是 <code>undefined</code>;</li>\n<li>如果有一个子节点，数据类型是 <code>object</code>；</li>\n<li>如果有多个子节点，数据类型就是 <code>array</code> 。所以，处理 this.props.children 的时候要小心。</li>\n<li>React 提供一个工具方法 <a href=\"https://facebook.github.io/react/docs/top-level-api.html#react.children\"><code>React.Children</code></a> 来处理<code>this.props.children</code> 。我们可以用 <code>React.Children.map</code> 来遍历子节点，而不用担心 <code>this.props.children</code> 的数据类型是 <code>undefined</code> 还是 <code>object</code>。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"5-PropTypes\"><a href=\"#5-PropTypes\" class=\"headerlink\" title=\"5. PropTypes\"></a>5. PropTypes</h1><p>组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，<strong>验证</strong>别人使用组件时，<strong>提供的参数是否符合要求</strong>。</p>\n<p>组件类的<code>PropTypes</code>属性，就是用来验证组件实例的属性是否符合要求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data &#x3D; 123;</span><br><span class=\"line\"></span><br><span class=\"line\">var MyTitle &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  propTypes: &#123;</span><br><span class=\"line\">    title: React.PropTypes.string.isRequired,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">     return &lt;h1&gt; &#123;this.props.title&#125; &lt;&#x2F;h1&gt;;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;MyTitle title&#x3D;&#123;data&#125; &#x2F;&gt;,</span><br><span class=\"line\">  document.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>上面的<code>Mytitle</code>组件有一个<code>title</code>属性。<code>PropTypes</code> 告诉 React，这个 <code>title</code> 属性是必须的，而且它的值必须是字符串。现在，我们设置 <code>title</code> 属性的值是一个数值。<br>这样一来，<code>title</code>属性就通不过验证了。控制台会显示一行错误信息。</p>\n<blockquote>\n<p>Warning: Failed propType: Invalid prop <code>title</code> of type <code>number</code> supplied to <code>MyTitle</code>, expected <code>string</code>.</p>\n</blockquote>\n<h2 id=\"5-2-设置默认参数\"><a href=\"#5-2-设置默认参数\" class=\"headerlink\" title=\"5.2 设置默认参数\"></a>5.2 设置默认参数</h2><p><code>getDefaultProps</code> 方法可以用来设置组件属性的默认值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var MyTitle &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  getDefaultProps : function () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      title : &#39;Hello World&#39;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">     return &lt;h1&gt; &#123;this.props.title&#125; &lt;&#x2F;h1&gt;;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;MyTitle &#x2F;&gt;,</span><br><span class=\"line\">  document.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面代码会输出”Hello World”。</p>\n</blockquote>\n<h1 id=\"6-获取真实的DOM节点\"><a href=\"#6-获取真实的DOM节点\" class=\"headerlink\" title=\"6. 获取真实的DOM节点\"></a>6. 获取真实的DOM节点</h1><p>有时需要从组件获取真实 DOM 的节点，这时就要用到 <code>ref</code> 属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var MyComponent &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  handleClick: function() &#123;</span><br><span class=\"line\">    this.refs.myTextInput.focus();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&quot;myTextInput&quot; &#x2F;&gt;</span><br><span class=\"line\">        &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;Focus the text input&quot; onClick&#x3D;&#123;this.handleClick&#125; &#x2F;&gt;</span><br><span class=\"line\">      &lt;&#x2F;div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;MyComponent &#x2F;&gt;,</span><br><span class=\"line\">  document.getElementById(&#39;example&#39;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，组件 <code>MyComponent</code> 的子节点有一个文本输入框， 用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 <code>ref</code> 属性，然后 <code>this.refs.[refName]</code> 就会返回这个真实的 DOM 节点。<br>需要注意的是，由于 <code>this.refs.[refName]</code> 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 上面代码中，通过为组件指定 <code>Click</code> 事件的回调函数，确保了只有等到真实 DOM 发生 <code>Click</code> 事件之后，才会读取 <code>this.refs.[refName]</code> 属性。</p>\n<p>React 组件支持很多事件，除了 <code>Click</code> 事件以外，还有 <code>KeyDown</code> 、<code>Copy</code>、<code>Scroll</code> 等，完整的事件清单请查看<a href=\"http://facebook.github.io/react/docs/events.html#supported-events\">官方文档</a>。</p>\n<h1 id=\"7-this-state\"><a href=\"#7-this-state\" class=\"headerlink\" title=\"7. this.state\"></a>7. this.state</h1><p>组件免不了要与用户互动，React的一大创新，就是将组件看成是一个状态机，一开始有一个<strong>初始状态</strong>，然后用户互动，导致状态变化，从而触发重新渲染 UI</p>\n<h2 id=\"7-1-LikeButton\"><a href=\"#7-1-LikeButton\" class=\"headerlink\" title=\"7.1 LikeButton\"></a>7.1 LikeButton</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var LikeButton &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: function() &#123;</span><br><span class=\"line\">    return &#123;liked: false&#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  handleClick: function(event) &#123;</span><br><span class=\"line\">    this.setState(&#123;liked: !this.state.liked&#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">    var text &#x3D; this.state.liked ? &#39;like&#39; : &#39;haven\\&#39;t liked&#39;;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;p onClick&#x3D;&#123;this.handleClick&#125;&gt;</span><br><span class=\"line\">        You &#123;text&#125; this. Click to toggle.</span><br><span class=\"line\">      &lt;&#x2F;p&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;LikeButton &#x2F;&gt;,</span><br><span class=\"line\">  document.getElementById(&#39;example&#39;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>上面代码是一个 <code>LikeButton</code> 组件，它的 <code>getInitialState</code> 方法用于定义初始状态，也就是一个对象，这个对象可以通过 <code>this.state</code> 属性读取。当用户点击组件，导致状态变化，<code>this.setState</code> 方法就修改状态值，每次修改以后，自动调用 <code>this.render</code> 方法，再次渲染组件。</p>\n<p>由于 <code>this.props</code> 和 <code>this.state</code> 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，<code>this.props</code> 表示那些一旦定义，就不再改变的特性，而 <code>this.state</code> 是会随着用户互动而产生变化的特性。</p>\n<h2 id=\"7-2-表单\"><a href=\"#7-2-表单\" class=\"headerlink\" title=\"7.2 表单\"></a>7.2 表单</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Input &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: function() &#123;</span><br><span class=\"line\">    return &#123;value: &#39;Hello!&#39;&#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  handleChange: function(event) &#123;</span><br><span class=\"line\">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: function () &#123;</span><br><span class=\"line\">    var value &#x3D; this.state.value;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;value&#125; onChange&#x3D;&#123;this.handleChange&#125; &#x2F;&gt;</span><br><span class=\"line\">        &lt;p&gt;&#123;value&#125;&lt;&#x2F;p&gt;</span><br><span class=\"line\">      &lt;&#x2F;div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(&lt;Input&#x2F;&gt;, document.body);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，文本输入框的值，不能用 <code>this.props.value</code> 读取，而要定义一个 <code>onChange</code> 事件的回调函数，通过 <code>event.target.value</code> 读取用户输入的值。<br><code>textarea</code> 元素、<code>select</code>元素、<code>radio</code>元素都属于这种情况，更多介绍请参考官方文档。</p>\n<h1 id=\"8-组件的生命周期\"><a href=\"#8-组件的生命周期\" class=\"headerlink\" title=\"8. 组件的生命周期\"></a>8. 组件的生命周期</h1><p>组件的生命周期分成三个状态：</p>\n<blockquote>\n<ul>\n<li>Mounting：已插入真实 DOM</li>\n</ul>\n</blockquote>\n<ul>\n<li>Updating：正在被重新渲染</li>\n<li>Unmounting：已移出真实 DOM</li>\n</ul>\n<p>React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。</p>\n<blockquote>\n<ul>\n<li>componentWillMount()</li>\n</ul>\n</blockquote>\n<ul>\n<li>componentDidMount()</li>\n<li>componentWillUpdate(object nextProps, object nextState)</li>\n<li>componentDidUpdate(object prevProps, object prevState)</li>\n<li>componentWillUnmount()</li>\n</ul>\n<p>此外，React 还提供两种特殊状态的处理函数。</p>\n<blockquote>\n<ul>\n<li>componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用</li>\n</ul>\n</blockquote>\n<ul>\n<li>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Hello &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: function () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      opacity: 1.0</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount: function () &#123;</span><br><span class=\"line\">    this.timer &#x3D; setInterval(function () &#123;</span><br><span class=\"line\">      var opacity &#x3D; this.state.opacity;</span><br><span class=\"line\">      opacity -&#x3D; .05;</span><br><span class=\"line\">      if (opacity &lt; 0.1) &#123;</span><br><span class=\"line\">        opacity &#x3D; 1.0;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.setState(&#123;</span><br><span class=\"line\">        opacity: opacity</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;.bind(this), 100);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  render: function () &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div style&#x3D;&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt;</span><br><span class=\"line\">        Hello &#123;this.props.name&#125;</span><br><span class=\"line\">      &lt;&#x2F;div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Hello name&#x3D;&quot;world&quot;&#x2F;&gt;,</span><br><span class=\"line\">  document.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>上面代码在<code>Hello</code>组件加载以后，通过 <code>componentDidMount</code> 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。<br>另外，组件的style属性的设置方式也值得注意 <code>style=&#123; &#123;opacity: this.state.opacity&#125; &#125; </code><br>React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。</p>\n<h1 id=\"9-Ajax\"><a href=\"#9-Ajax\" class=\"headerlink\" title=\"9. Ajax\"></a>9. Ajax</h1><p>组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 <code>componentDidMount</code> 方法设置 Ajax 请求，等到请求成功，再用 <code>this.setState</code> 方法重新渲染 UI</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var UserGist &#x3D; React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: function() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      username: &#39;&#39;,</span><br><span class=\"line\">      lastGistUrl: &#39;&#39;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount: function() &#123;</span><br><span class=\"line\">    $.get(this.props.source, function(result) &#123;</span><br><span class=\"line\">      var lastGist &#x3D; result[0];</span><br><span class=\"line\">      if (this.isMounted()) &#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">          username: lastGist.owner.login,</span><br><span class=\"line\">          lastGistUrl: lastGist.html_url</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;.bind(this));</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;this.state.username&#125;&#39;s last gist is</span><br><span class=\"line\">        &lt;a href&#x3D;&#123;this.state.lastGistUrl&#125;&gt;here&lt;&#x2F;a&gt;.</span><br><span class=\"line\">      &lt;&#x2F;div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;UserGist source&#x3D;&quot;https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;octocat&#x2F;gists&quot; &#x2F;&gt;,</span><br><span class=\"line\">  document.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>"},{"title":"Git笔记","date":"2019-06-04T07:53:00.000Z","updated":"2020-05-15T16:00:00.000Z","_content":"\n# 1. 修改commit\n\n<!-- more -->\n\n当commit遇到这两种需求：\n1. 修改上次commit的Message\n2. 当前add合并到上次的commit\ngit commit --amend\n\n# 2. 常用git别名设置：\n\n```\ngit config --global alias.co checkout\ngit config --global alias.a add\ngit config --global alias.s 'status -s'\ngit config --global alias.ps push\ngit config --global alias.pl pull\ngit config --global alias.pr 'pull --rebase'\ngit config --global alias.cm 'commit -m'\ngit config --global alias.ca 'commit --amend'\ngit config --global alias.rh 'reset HEAD'\ngit config --global alias.si 'submodule init'\ngit config --global alias.su 'submodule update --remote'\ngit config --global alias.br 'branch'\ngit config --global alias.spm 'stash push -m'\ngit config --global alias.sl 'stash list'\ngit config --global alias.sa 'stash apply'\ngit config --global alias.sd 'stash drop'\ngit config --global alias.sc 'stash clear'\ngit config --global alias.comd '!git checkout master && git merge develop && git push && git checkout develop'\n```\n\n显示：\n\n```\ngit config --global -l\n```\n\n删除：\n\n```\ngit config --global --unset alias.\n```\n\n# 3. rebase\n\ngit pull时可以加上--rebase参数，使之不产生Merge点，保证了代码的整洁:\n`git pull --rebase`\n把它设置为默认操作：\ngit config --global pull.rebase true\n\n如果在rebase的过程中有冲突，这时Git会停止rebase并让用户去解决冲突。解决完冲突后，用`git add`命令去更新这些内容，然后不用执行`git -commit`，直接执行`git rebase --continue`，这样git会继续apply余下的补丁。\n\ngit rebase --abort 会回到rebase操作之前的状态，之前的提交的不会丢弃；\n\ngit rebase --skip 则会将引起冲突的commits丢弃掉；\n\n# 4. 换行符\n\n文本文件所使用的换行符，在不同的系统平台上是不一样的。UNIX/Linux 使用的是 `0x0A(LF)`，早期的 Mac OS 使用的是 `0x0D(CR)`，后来的 OS X 在更换内核后与 UNIX 保持一致了。但 DOS/Windows 一直使用 `0x0D0A(CRLF)` 作为换行符。\n\n跨平台协作开发是常有的，不统一的换行符确实对跨平台的文件交换带来了麻烦。最大的问题是，在不同平台上，换行符发生改变时，Git 会认为整个文件被修改，这就造成我们没法 diff，不能正确反映本次的修改。还好 Git 在设计时就考虑了这一点，其提供了一个 autocrlf 的配置项，用于在提交和检出时自动转换换行符，该配置有三个可选项：\n\n- true: 提交时转换为 LF，检出时转换为 CRLF\n- false: 提交检出均不转换\n- input: 提交时转换为LF，检出时不转换\n\n用如下命令即可完成配置：\n```\n# 提交时转换为LF，检出时转换为CRLF\ngit config --global core.autocrlf true\n\n# 提交时转换为LF，检出时不转换\ngit config --global core.autocrlf input\n\n# 提交检出均不转换\ngit config --global core.autocrlf false\n```\n如果把 `autocrlf` 设置为 false 时，那另一个配置项 `safecrlf` 最好设置为 ture。该选项用于检查文件是否包含混合换行符，其有三个可选项：\n\n- true: 拒绝提交包含混合换行符的文件\n- false: 允许提交包含混合换行符的文件\n- warn: 提交包含混合换行符的文件时给出警告\n\n配置方法：\n```\n# 拒绝提交包含混合换行符的文件\ngit config --global core.safecrlf true\n\n# 允许提交包含混合换行符的文件\ngit config --global core.safecrlf false\n\n# 提交包含混合换行符的文件时给出警告\ngit config --global core.safecrlf warn\n```\n\n# 5. Git add 参数解析：\n\ngit add -A  提交所有变化，不限于当前目录\ngit add -u  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)\ngit add .   提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件，仅限当前目录\n\n# 6. 拉取远程分支到本地并切换到此分支：\n\n老（可以本地自定义名字）：\n\n```\ngit checkout -b dev origin/develop\n```\n\n新（简化）：\n\n````\ngit checkout --track origin/develop\n````\n\n再简化：\n\n````\ngit checkout -t origin/develop\n````\n","source":"_posts/2019/Git笔记.md","raw":"---\ntitle: Git笔记\ndate: 2019-06-04 15:53\nupdated: 2020-05-16\ntags: 版本控制\n---\n\n# 1. 修改commit\n\n<!-- more -->\n\n当commit遇到这两种需求：\n1. 修改上次commit的Message\n2. 当前add合并到上次的commit\ngit commit --amend\n\n# 2. 常用git别名设置：\n\n```\ngit config --global alias.co checkout\ngit config --global alias.a add\ngit config --global alias.s 'status -s'\ngit config --global alias.ps push\ngit config --global alias.pl pull\ngit config --global alias.pr 'pull --rebase'\ngit config --global alias.cm 'commit -m'\ngit config --global alias.ca 'commit --amend'\ngit config --global alias.rh 'reset HEAD'\ngit config --global alias.si 'submodule init'\ngit config --global alias.su 'submodule update --remote'\ngit config --global alias.br 'branch'\ngit config --global alias.spm 'stash push -m'\ngit config --global alias.sl 'stash list'\ngit config --global alias.sa 'stash apply'\ngit config --global alias.sd 'stash drop'\ngit config --global alias.sc 'stash clear'\ngit config --global alias.comd '!git checkout master && git merge develop && git push && git checkout develop'\n```\n\n显示：\n\n```\ngit config --global -l\n```\n\n删除：\n\n```\ngit config --global --unset alias.\n```\n\n# 3. rebase\n\ngit pull时可以加上--rebase参数，使之不产生Merge点，保证了代码的整洁:\n`git pull --rebase`\n把它设置为默认操作：\ngit config --global pull.rebase true\n\n如果在rebase的过程中有冲突，这时Git会停止rebase并让用户去解决冲突。解决完冲突后，用`git add`命令去更新这些内容，然后不用执行`git -commit`，直接执行`git rebase --continue`，这样git会继续apply余下的补丁。\n\ngit rebase --abort 会回到rebase操作之前的状态，之前的提交的不会丢弃；\n\ngit rebase --skip 则会将引起冲突的commits丢弃掉；\n\n# 4. 换行符\n\n文本文件所使用的换行符，在不同的系统平台上是不一样的。UNIX/Linux 使用的是 `0x0A(LF)`，早期的 Mac OS 使用的是 `0x0D(CR)`，后来的 OS X 在更换内核后与 UNIX 保持一致了。但 DOS/Windows 一直使用 `0x0D0A(CRLF)` 作为换行符。\n\n跨平台协作开发是常有的，不统一的换行符确实对跨平台的文件交换带来了麻烦。最大的问题是，在不同平台上，换行符发生改变时，Git 会认为整个文件被修改，这就造成我们没法 diff，不能正确反映本次的修改。还好 Git 在设计时就考虑了这一点，其提供了一个 autocrlf 的配置项，用于在提交和检出时自动转换换行符，该配置有三个可选项：\n\n- true: 提交时转换为 LF，检出时转换为 CRLF\n- false: 提交检出均不转换\n- input: 提交时转换为LF，检出时不转换\n\n用如下命令即可完成配置：\n```\n# 提交时转换为LF，检出时转换为CRLF\ngit config --global core.autocrlf true\n\n# 提交时转换为LF，检出时不转换\ngit config --global core.autocrlf input\n\n# 提交检出均不转换\ngit config --global core.autocrlf false\n```\n如果把 `autocrlf` 设置为 false 时，那另一个配置项 `safecrlf` 最好设置为 ture。该选项用于检查文件是否包含混合换行符，其有三个可选项：\n\n- true: 拒绝提交包含混合换行符的文件\n- false: 允许提交包含混合换行符的文件\n- warn: 提交包含混合换行符的文件时给出警告\n\n配置方法：\n```\n# 拒绝提交包含混合换行符的文件\ngit config --global core.safecrlf true\n\n# 允许提交包含混合换行符的文件\ngit config --global core.safecrlf false\n\n# 提交包含混合换行符的文件时给出警告\ngit config --global core.safecrlf warn\n```\n\n# 5. Git add 参数解析：\n\ngit add -A  提交所有变化，不限于当前目录\ngit add -u  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)\ngit add .   提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件，仅限当前目录\n\n# 6. 拉取远程分支到本地并切换到此分支：\n\n老（可以本地自定义名字）：\n\n```\ngit checkout -b dev origin/develop\n```\n\n新（简化）：\n\n````\ngit checkout --track origin/develop\n````\n\n再简化：\n\n````\ngit checkout -t origin/develop\n````\n","slug":"2019-Git笔记","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrjy000g2ykua1ii8i1g","content":"<h1 id=\"1-修改commit\"><a href=\"#1-修改commit\" class=\"headerlink\" title=\"1. 修改commit\"></a>1. 修改commit</h1><a id=\"more\"></a>\n\n<p>当commit遇到这两种需求：</p>\n<ol>\n<li>修改上次commit的Message</li>\n<li>当前add合并到上次的commit<br>git commit –amend</li>\n</ol>\n<h1 id=\"2-常用git别名设置：\"><a href=\"#2-常用git别名设置：\" class=\"headerlink\" title=\"2. 常用git别名设置：\"></a>2. 常用git别名设置：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global alias.co checkout</span><br><span class=\"line\">git config --global alias.a add</span><br><span class=\"line\">git config --global alias.s &#39;status -s&#39;</span><br><span class=\"line\">git config --global alias.ps push</span><br><span class=\"line\">git config --global alias.pl pull</span><br><span class=\"line\">git config --global alias.pr &#39;pull --rebase&#39;</span><br><span class=\"line\">git config --global alias.cm &#39;commit -m&#39;</span><br><span class=\"line\">git config --global alias.ca &#39;commit --amend&#39;</span><br><span class=\"line\">git config --global alias.rh &#39;reset HEAD&#39;</span><br><span class=\"line\">git config --global alias.si &#39;submodule init&#39;</span><br><span class=\"line\">git config --global alias.su &#39;submodule update --remote&#39;</span><br><span class=\"line\">git config --global alias.br &#39;branch&#39;</span><br><span class=\"line\">git config --global alias.spm &#39;stash push -m&#39;</span><br><span class=\"line\">git config --global alias.sl &#39;stash list&#39;</span><br><span class=\"line\">git config --global alias.sa &#39;stash apply&#39;</span><br><span class=\"line\">git config --global alias.sd &#39;stash drop&#39;</span><br><span class=\"line\">git config --global alias.sc &#39;stash clear&#39;</span><br><span class=\"line\">git config --global alias.comd &#39;!git checkout master &amp;&amp; git merge develop &amp;&amp; git push &amp;&amp; git checkout develop&#39;</span><br></pre></td></tr></table></figure>\n\n<p>显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global -l</span><br></pre></td></tr></table></figure>\n\n<p>删除：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset alias.</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-rebase\"><a href=\"#3-rebase\" class=\"headerlink\" title=\"3. rebase\"></a>3. rebase</h1><p>git pull时可以加上–rebase参数，使之不产生Merge点，保证了代码的整洁:<br><code>git pull --rebase</code><br>把它设置为默认操作：<br>git config –global pull.rebase true</p>\n<p>如果在rebase的过程中有冲突，这时Git会停止rebase并让用户去解决冲突。解决完冲突后，用<code>git add</code>命令去更新这些内容，然后不用执行<code>git -commit</code>，直接执行<code>git rebase --continue</code>，这样git会继续apply余下的补丁。</p>\n<p>git rebase –abort 会回到rebase操作之前的状态，之前的提交的不会丢弃；</p>\n<p>git rebase –skip 则会将引起冲突的commits丢弃掉；</p>\n<h1 id=\"4-换行符\"><a href=\"#4-换行符\" class=\"headerlink\" title=\"4. 换行符\"></a>4. 换行符</h1><p>文本文件所使用的换行符，在不同的系统平台上是不一样的。UNIX/Linux 使用的是 <code>0x0A(LF)</code>，早期的 Mac OS 使用的是 <code>0x0D(CR)</code>，后来的 OS X 在更换内核后与 UNIX 保持一致了。但 DOS/Windows 一直使用 <code>0x0D0A(CRLF)</code> 作为换行符。</p>\n<p>跨平台协作开发是常有的，不统一的换行符确实对跨平台的文件交换带来了麻烦。最大的问题是，在不同平台上，换行符发生改变时，Git 会认为整个文件被修改，这就造成我们没法 diff，不能正确反映本次的修改。还好 Git 在设计时就考虑了这一点，其提供了一个 autocrlf 的配置项，用于在提交和检出时自动转换换行符，该配置有三个可选项：</p>\n<ul>\n<li>true: 提交时转换为 LF，检出时转换为 CRLF</li>\n<li>false: 提交检出均不转换</li>\n<li>input: 提交时转换为LF，检出时不转换</li>\n</ul>\n<p>用如下命令即可完成配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 提交时转换为LF，检出时转换为CRLF</span><br><span class=\"line\">git config --global core.autocrlf true</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交时转换为LF，检出时不转换</span><br><span class=\"line\">git config --global core.autocrlf input</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交检出均不转换</span><br><span class=\"line\">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>\n<p>如果把 <code>autocrlf</code> 设置为 false 时，那另一个配置项 <code>safecrlf</code> 最好设置为 ture。该选项用于检查文件是否包含混合换行符，其有三个可选项：</p>\n<ul>\n<li>true: 拒绝提交包含混合换行符的文件</li>\n<li>false: 允许提交包含混合换行符的文件</li>\n<li>warn: 提交包含混合换行符的文件时给出警告</li>\n</ul>\n<p>配置方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 拒绝提交包含混合换行符的文件</span><br><span class=\"line\">git config --global core.safecrlf true</span><br><span class=\"line\"></span><br><span class=\"line\"># 允许提交包含混合换行符的文件</span><br><span class=\"line\">git config --global core.safecrlf false</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交包含混合换行符的文件时给出警告</span><br><span class=\"line\">git config --global core.safecrlf warn</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-Git-add-参数解析：\"><a href=\"#5-Git-add-参数解析：\" class=\"headerlink\" title=\"5. Git add 参数解析：\"></a>5. Git add 参数解析：</h1><p>git add -A  提交所有变化，不限于当前目录<br>git add -u  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)<br>git add .   提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件，仅限当前目录</p>\n<h1 id=\"6-拉取远程分支到本地并切换到此分支：\"><a href=\"#6-拉取远程分支到本地并切换到此分支：\" class=\"headerlink\" title=\"6. 拉取远程分支到本地并切换到此分支：\"></a>6. 拉取远程分支到本地并切换到此分支：</h1><p>老（可以本地自定义名字）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b dev origin&#x2F;develop</span><br></pre></td></tr></table></figure>\n\n<p>新（简化）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout --track origin&#x2F;develop</span><br></pre></td></tr></table></figure>\n\n<p>再简化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -t origin&#x2F;develop</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-修改commit\"><a href=\"#1-修改commit\" class=\"headerlink\" title=\"1. 修改commit\"></a>1. 修改commit</h1>","more":"<p>当commit遇到这两种需求：</p>\n<ol>\n<li>修改上次commit的Message</li>\n<li>当前add合并到上次的commit<br>git commit –amend</li>\n</ol>\n<h1 id=\"2-常用git别名设置：\"><a href=\"#2-常用git别名设置：\" class=\"headerlink\" title=\"2. 常用git别名设置：\"></a>2. 常用git别名设置：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global alias.co checkout</span><br><span class=\"line\">git config --global alias.a add</span><br><span class=\"line\">git config --global alias.s &#39;status -s&#39;</span><br><span class=\"line\">git config --global alias.ps push</span><br><span class=\"line\">git config --global alias.pl pull</span><br><span class=\"line\">git config --global alias.pr &#39;pull --rebase&#39;</span><br><span class=\"line\">git config --global alias.cm &#39;commit -m&#39;</span><br><span class=\"line\">git config --global alias.ca &#39;commit --amend&#39;</span><br><span class=\"line\">git config --global alias.rh &#39;reset HEAD&#39;</span><br><span class=\"line\">git config --global alias.si &#39;submodule init&#39;</span><br><span class=\"line\">git config --global alias.su &#39;submodule update --remote&#39;</span><br><span class=\"line\">git config --global alias.br &#39;branch&#39;</span><br><span class=\"line\">git config --global alias.spm &#39;stash push -m&#39;</span><br><span class=\"line\">git config --global alias.sl &#39;stash list&#39;</span><br><span class=\"line\">git config --global alias.sa &#39;stash apply&#39;</span><br><span class=\"line\">git config --global alias.sd &#39;stash drop&#39;</span><br><span class=\"line\">git config --global alias.sc &#39;stash clear&#39;</span><br><span class=\"line\">git config --global alias.comd &#39;!git checkout master &amp;&amp; git merge develop &amp;&amp; git push &amp;&amp; git checkout develop&#39;</span><br></pre></td></tr></table></figure>\n\n<p>显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global -l</span><br></pre></td></tr></table></figure>\n\n<p>删除：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset alias.</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-rebase\"><a href=\"#3-rebase\" class=\"headerlink\" title=\"3. rebase\"></a>3. rebase</h1><p>git pull时可以加上–rebase参数，使之不产生Merge点，保证了代码的整洁:<br><code>git pull --rebase</code><br>把它设置为默认操作：<br>git config –global pull.rebase true</p>\n<p>如果在rebase的过程中有冲突，这时Git会停止rebase并让用户去解决冲突。解决完冲突后，用<code>git add</code>命令去更新这些内容，然后不用执行<code>git -commit</code>，直接执行<code>git rebase --continue</code>，这样git会继续apply余下的补丁。</p>\n<p>git rebase –abort 会回到rebase操作之前的状态，之前的提交的不会丢弃；</p>\n<p>git rebase –skip 则会将引起冲突的commits丢弃掉；</p>\n<h1 id=\"4-换行符\"><a href=\"#4-换行符\" class=\"headerlink\" title=\"4. 换行符\"></a>4. 换行符</h1><p>文本文件所使用的换行符，在不同的系统平台上是不一样的。UNIX/Linux 使用的是 <code>0x0A(LF)</code>，早期的 Mac OS 使用的是 <code>0x0D(CR)</code>，后来的 OS X 在更换内核后与 UNIX 保持一致了。但 DOS/Windows 一直使用 <code>0x0D0A(CRLF)</code> 作为换行符。</p>\n<p>跨平台协作开发是常有的，不统一的换行符确实对跨平台的文件交换带来了麻烦。最大的问题是，在不同平台上，换行符发生改变时，Git 会认为整个文件被修改，这就造成我们没法 diff，不能正确反映本次的修改。还好 Git 在设计时就考虑了这一点，其提供了一个 autocrlf 的配置项，用于在提交和检出时自动转换换行符，该配置有三个可选项：</p>\n<ul>\n<li>true: 提交时转换为 LF，检出时转换为 CRLF</li>\n<li>false: 提交检出均不转换</li>\n<li>input: 提交时转换为LF，检出时不转换</li>\n</ul>\n<p>用如下命令即可完成配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 提交时转换为LF，检出时转换为CRLF</span><br><span class=\"line\">git config --global core.autocrlf true</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交时转换为LF，检出时不转换</span><br><span class=\"line\">git config --global core.autocrlf input</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交检出均不转换</span><br><span class=\"line\">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>\n<p>如果把 <code>autocrlf</code> 设置为 false 时，那另一个配置项 <code>safecrlf</code> 最好设置为 ture。该选项用于检查文件是否包含混合换行符，其有三个可选项：</p>\n<ul>\n<li>true: 拒绝提交包含混合换行符的文件</li>\n<li>false: 允许提交包含混合换行符的文件</li>\n<li>warn: 提交包含混合换行符的文件时给出警告</li>\n</ul>\n<p>配置方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 拒绝提交包含混合换行符的文件</span><br><span class=\"line\">git config --global core.safecrlf true</span><br><span class=\"line\"></span><br><span class=\"line\"># 允许提交包含混合换行符的文件</span><br><span class=\"line\">git config --global core.safecrlf false</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交包含混合换行符的文件时给出警告</span><br><span class=\"line\">git config --global core.safecrlf warn</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-Git-add-参数解析：\"><a href=\"#5-Git-add-参数解析：\" class=\"headerlink\" title=\"5. Git add 参数解析：\"></a>5. Git add 参数解析：</h1><p>git add -A  提交所有变化，不限于当前目录<br>git add -u  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)<br>git add .   提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件，仅限当前目录</p>\n<h1 id=\"6-拉取远程分支到本地并切换到此分支：\"><a href=\"#6-拉取远程分支到本地并切换到此分支：\" class=\"headerlink\" title=\"6. 拉取远程分支到本地并切换到此分支：\"></a>6. 拉取远程分支到本地并切换到此分支：</h1><p>老（可以本地自定义名字）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b dev origin&#x2F;develop</span><br></pre></td></tr></table></figure>\n\n<p>新（简化）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout --track origin&#x2F;develop</span><br></pre></td></tr></table></figure>\n\n<p>再简化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -t origin&#x2F;develop</span><br></pre></td></tr></table></figure>"},{"title":"IDEA使用技巧","date":"2019-03-27T15:29:06.000Z","updated":"2019-03-26T16:00:00.000Z","_content":"\n<script>\n  var head = document.getElementsByTagName('head')[0];\n  var css = \"<style>.article img{width: 100%;}</style>\";\n  head.innerHTML+=css;\n\n</script>\n# 一、后缀补全\n<!-- more -->\n\n这个功能可以使用代码补全来模板式地补全语句，如遍历循环语句（for、foreach）、使用 String.format() 包裹一个字符串、使用类型转化包裹一个表达式、根据判（非）空或者其它判别语句生成 if 语句、用 instanceOf 生成分支判断语句等。\n\n使用的方式也很简单，就是在一个表达式后按下点号 . ，然后输入一些提示或者在列表中选择一个候选项，常见的候选项下面会给出 GIF 演示。\n\n### 1、var 声明\n{% asset_img 1.gif %}\n\n### 2、null 判空\n{% asset_img 2.gif %}\n### 3、notnull 判非空\n{% asset_img 3.gif %}\n### 4、nn 判非空\n{% asset_img 4.gif %}\n### 5、for 遍历\n{% asset_img 5.gif %}\n### 6、fori 带索引的遍历\n{% asset_img 6.gif %}\n### 7、not 取反\n{% asset_img 7.gif %}\n### 8、if 条件判断\n{% asset_img 8.gif %}\n### 9、cast 强转\n{% asset_img 9.gif %}\n### 10、return 返回值\n{% asset_img 10.gif %}\n","source":"_posts/2019/IDEA使用技巧.md","raw":"---\ntitle: IDEA使用技巧\ndate: 2019-03-27 23:29:06\nupdated: 2019-03-27\ntags: IDE\n---\n\n<script>\n  var head = document.getElementsByTagName('head')[0];\n  var css = \"<style>.article img{width: 100%;}</style>\";\n  head.innerHTML+=css;\n\n</script>\n# 一、后缀补全\n<!-- more -->\n\n这个功能可以使用代码补全来模板式地补全语句，如遍历循环语句（for、foreach）、使用 String.format() 包裹一个字符串、使用类型转化包裹一个表达式、根据判（非）空或者其它判别语句生成 if 语句、用 instanceOf 生成分支判断语句等。\n\n使用的方式也很简单，就是在一个表达式后按下点号 . ，然后输入一些提示或者在列表中选择一个候选项，常见的候选项下面会给出 GIF 演示。\n\n### 1、var 声明\n{% asset_img 1.gif %}\n\n### 2、null 判空\n{% asset_img 2.gif %}\n### 3、notnull 判非空\n{% asset_img 3.gif %}\n### 4、nn 判非空\n{% asset_img 4.gif %}\n### 5、for 遍历\n{% asset_img 5.gif %}\n### 6、fori 带索引的遍历\n{% asset_img 6.gif %}\n### 7、not 取反\n{% asset_img 7.gif %}\n### 8、if 条件判断\n{% asset_img 8.gif %}\n### 9、cast 强转\n{% asset_img 9.gif %}\n### 10、return 返回值\n{% asset_img 10.gif %}\n","slug":"2019-IDEA使用技巧","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrjz000i2ykuaa5w7hnr","content":"<script>\n  var head = document.getElementsByTagName('head')[0];\n  var css = \"<style>.article img{width: 100%;}</style>\";\n  head.innerHTML+=css;\n\n</script>\n<h1 id=\"一、后缀补全\"><a href=\"#一、后缀补全\" class=\"headerlink\" title=\"一、后缀补全\"></a>一、后缀补全</h1><a id=\"more\"></a>\n\n<p>这个功能可以使用代码补全来模板式地补全语句，如遍历循环语句（for、foreach）、使用 String.format() 包裹一个字符串、使用类型转化包裹一个表达式、根据判（非）空或者其它判别语句生成 if 语句、用 instanceOf 生成分支判断语句等。</p>\n<p>使用的方式也很简单，就是在一个表达式后按下点号 . ，然后输入一些提示或者在列表中选择一个候选项，常见的候选项下面会给出 GIF 演示。</p>\n<h3 id=\"1、var-声明\"><a href=\"#1、var-声明\" class=\"headerlink\" title=\"1、var 声明\"></a>1、var 声明</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1.gif\" class=\"\">\n\n<h3 id=\"2、null-判空\"><a href=\"#2、null-判空\" class=\"headerlink\" title=\"2、null 判空\"></a>2、null 判空</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2.gif\" class=\"\">\n<h3 id=\"3、notnull-判非空\"><a href=\"#3、notnull-判非空\" class=\"headerlink\" title=\"3、notnull 判非空\"></a>3、notnull 判非空</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/3.gif\" class=\"\">\n<h3 id=\"4、nn-判非空\"><a href=\"#4、nn-判非空\" class=\"headerlink\" title=\"4、nn 判非空\"></a>4、nn 判非空</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/4.gif\" class=\"\">\n<h3 id=\"5、for-遍历\"><a href=\"#5、for-遍历\" class=\"headerlink\" title=\"5、for 遍历\"></a>5、for 遍历</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/5.gif\" class=\"\">\n<h3 id=\"6、fori-带索引的遍历\"><a href=\"#6、fori-带索引的遍历\" class=\"headerlink\" title=\"6、fori 带索引的遍历\"></a>6、fori 带索引的遍历</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/6.gif\" class=\"\">\n<h3 id=\"7、not-取反\"><a href=\"#7、not-取反\" class=\"headerlink\" title=\"7、not 取反\"></a>7、not 取反</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/7.gif\" class=\"\">\n<h3 id=\"8、if-条件判断\"><a href=\"#8、if-条件判断\" class=\"headerlink\" title=\"8、if 条件判断\"></a>8、if 条件判断</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/8.gif\" class=\"\">\n<h3 id=\"9、cast-强转\"><a href=\"#9、cast-强转\" class=\"headerlink\" title=\"9、cast 强转\"></a>9、cast 强转</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/9.gif\" class=\"\">\n<h3 id=\"10、return-返回值\"><a href=\"#10、return-返回值\" class=\"headerlink\" title=\"10、return 返回值\"></a>10、return 返回值</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/10.gif\" class=\"\">\n","site":{"data":{}},"excerpt":"<script>\n  var head = document.getElementsByTagName('head')[0];\n  var css = \"<style>.article img{width: 100%;}</style>\";\n  head.innerHTML+=css;\n\n</script>\n<h1 id=\"一、后缀补全\"><a href=\"#一、后缀补全\" class=\"headerlink\" title=\"一、后缀补全\"></a>一、后缀补全</h1>","more":"<p>这个功能可以使用代码补全来模板式地补全语句，如遍历循环语句（for、foreach）、使用 String.format() 包裹一个字符串、使用类型转化包裹一个表达式、根据判（非）空或者其它判别语句生成 if 语句、用 instanceOf 生成分支判断语句等。</p>\n<p>使用的方式也很简单，就是在一个表达式后按下点号 . ，然后输入一些提示或者在列表中选择一个候选项，常见的候选项下面会给出 GIF 演示。</p>\n<h3 id=\"1、var-声明\"><a href=\"#1、var-声明\" class=\"headerlink\" title=\"1、var 声明\"></a>1、var 声明</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1.gif\" class=\"\">\n\n<h3 id=\"2、null-判空\"><a href=\"#2、null-判空\" class=\"headerlink\" title=\"2、null 判空\"></a>2、null 判空</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2.gif\" class=\"\">\n<h3 id=\"3、notnull-判非空\"><a href=\"#3、notnull-判非空\" class=\"headerlink\" title=\"3、notnull 判非空\"></a>3、notnull 判非空</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/3.gif\" class=\"\">\n<h3 id=\"4、nn-判非空\"><a href=\"#4、nn-判非空\" class=\"headerlink\" title=\"4、nn 判非空\"></a>4、nn 判非空</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/4.gif\" class=\"\">\n<h3 id=\"5、for-遍历\"><a href=\"#5、for-遍历\" class=\"headerlink\" title=\"5、for 遍历\"></a>5、for 遍历</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/5.gif\" class=\"\">\n<h3 id=\"6、fori-带索引的遍历\"><a href=\"#6、fori-带索引的遍历\" class=\"headerlink\" title=\"6、fori 带索引的遍历\"></a>6、fori 带索引的遍历</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/6.gif\" class=\"\">\n<h3 id=\"7、not-取反\"><a href=\"#7、not-取反\" class=\"headerlink\" title=\"7、not 取反\"></a>7、not 取反</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/7.gif\" class=\"\">\n<h3 id=\"8、if-条件判断\"><a href=\"#8、if-条件判断\" class=\"headerlink\" title=\"8、if 条件判断\"></a>8、if 条件判断</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/8.gif\" class=\"\">\n<h3 id=\"9、cast-强转\"><a href=\"#9、cast-强转\" class=\"headerlink\" title=\"9、cast 强转\"></a>9、cast 强转</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/9.gif\" class=\"\">\n<h3 id=\"10、return-返回值\"><a href=\"#10、return-返回值\" class=\"headerlink\" title=\"10、return 返回值\"></a>10、return 返回值</h3><img src=\"/2019/03/27/2019-IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/10.gif\" class=\"\">"},{"title":"MySQL知识点","date":"2019-04-13T17:31:54.000Z","updated":"2019-04-13T17:31:54.000Z","_content":"# 1. MySQL中主要的存储引擎\n\nMyISAM是MySQL官方提供的存储引擎，其特点是支持全文索引，查询效率比较高，缺点是不支持事务、使用表级锁。InnoDB在5.5版本后成为了Mysql的默认存储引擎，特点是支持ACID事务、支持外键、支持行级锁提高了并发效率。TokuDB是第三方开发的开源存储引擎，有非常快的写速度，支持数据的压缩存储、可以在线添加索引而不影响读写操作。但是因为压缩的原因，TokuDB非常适合访问频率不高的数据或历史数据归档，不适合大量读取的场景。\n\n<!-- more -->\n\n# 2. MySQL中的锁\n表锁、行锁、共享锁、排它锁。\n\nMyIASAM使用表级锁，InnoDB使用行级锁。表锁开销小，加锁快，不会出现死锁；但是锁的粒度大，发生锁冲突的概率高，并发访问效率比较低。行级锁开销大，加锁慢，有可能会出现死锁，不过因为锁定粒度最小，发生锁冲突的概率低，并发访问效率比较高。\n\n共享锁也就是读锁，其他事务可以读，但不能写。MySQL可以通过Lock In Share Mode语句显示使用共享锁。\n\n排他锁就是写锁，其他事务不能读取，也不能写。对于Update、Delete和INSERT语句，InnoDB会自动给涉及的数据集加排他锁，或者使用select for update显示使用排他锁。\n\n# 3. 索引\n索引可以大幅增加数据库的查询的性能，在实际业务场景中，或多或少都会使用到。\n\n**但是索引是有如下2个代价的:**\na.需要额外的磁盘空间来保存索引\nb.对于插入、更新、删除等操作由于更新索引会增加额外的开销\n\n因此索引比较适合用在读多写少的场景。\n\n## 3.1 MySQL索引类型\n\n共分为5类：\n\n- **唯一索引：**就是索引列中的值必须是唯一的，但是允许出现空值。这种索引一般用来保证数据的唯一性，比如保存账户信息的表，每个账户的id必须保证唯一，如果重复插入相同的账户id时会MySQL返回异常。\n- **主键索引：**是一种特殊的唯一索引，但是它不允许出现空值。\n- **普通索引：**与唯一索引不同，它允许索引列中存在相同的值。例如学生的成绩表，各个学科的分数是允许重复的，就可以使用普通索引。\n- **联合索引：**就是由多个列共同组成的索引。一个表中含有多个单列的索引并不是联合索引，联合索引是对多个列字段按顺序共同组成一个索引。应用联合索引时需要注意最左原则，就是Where查询条件中的字段必须与索引字段从左到右进行匹配。比如，一个用户信息表，用姓名和年龄组成了联合索引，如果查询条件是姓名等于张三，那么满足最左原则；如果查询条件是年龄大于20，由于索引中最左的字段是姓名不是年龄，所以不能使用这个索引。\n- **全文索引：**前面提到了，MyISAM引擎中实现了这个索引，在5.6版本后InnoDB引擎也支持了全文索引，并且在5.7.6版本后支持了中文索引。全文索引只能在CHAR,VARCHAR,TEXT类型字段上使用，底层使用倒排索引实现。要注意对于大数据量的表，生成全文索引会非常消耗时间也非常消耗磁盘空间。\n\n## 3.2 索引实现\n\n索引实现共分4种形式：\n\n- **B+树实现：**b+树比较适合用作'>'或'<'这样的范围查询，是MySQL中最常使用的一种索引实现。\n- **R-tree：**是一种用于处理多维数据的数据结构，可以对地理数据进行空间索引。不过实际业务场景中使用的比较少。\n- **Hash：**是使用散列表来对数据进行索引，Hash方式不像Btree那样需要多次查询才能定位到记录，因此Hash索引的效率高于B-tree，但是不支持范围查找和排序等功能.实际使用的也比较少。\n- **FullText：**就是我们前面提到的全文索引，是一种记录关键字与对应文档关系的倒排索引。\n\n# 4. MySQL的存储过程与函数\n\n存储过程和函数都可以避免开发人员重复编写相同的SQL语句，并且存储过程和函数都是在MySQL服务器中执行的，可以减少客户端和服务器端的数据传输。\n\n存储过程能够实现更复杂的功能，而函数一般用来实现针对性比较强的功能，例如特殊策略求和等。存储过程可以执行包括修改表等一系列数据库操作，而用户定义函数不能用于执行修改全局数据库状态的操作。\n\n存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用。SQL语句中不能使用存储过程，但可以使用函数。\n\n不过存储过程一般与数据库实现绑定，使用存储过程会降低程序的可移植性，应谨慎使用。\n\n# 5. 新特性\n\n可以了解MySQL8.0的一些新特性，例如默认字符集格式改为了UTF8；增加了隐藏索引的功能，隐藏后的索引不会被查询优化器使用，可以使用这个特性用于性能调试；支持了通用表表达式，使复杂查询中的嵌入表语句更加清晰；新增了窗口函数的概念，它可以用来实现新的查询方式。窗口函数与 SUM、COUNT等集合函数类似，但不会将多行查询结果合并，而是将结果放在多行中。即窗口函数不需要GROUP BY。\n\n# 6. MySQL调优\n\n一般MySQL调优有4个纬度：\n\n- 针对数据库设计、表结构设计以及索引设置纬度进行的优化；\n- 对业务中使用的SQL语句进行优化，例如调整Where查询条件；\n- 对mysql服务的配置进行优化，例如对链接数的管理，对索引缓存、查询缓存、排序缓存等各种缓存大小进行优化;\n- 对硬件设备和操作系统设置进行优化，例如调整操作系统参数、禁用Swap、增加内存、升级固态硬盘等等。\n\n这四个纬度从优化的成本角度来讲，从上到下优化成本逐渐升高；从优化效果角度来看，从下到上优化的效果更高。\n\n对于研发人员来说，前两个纬度与业务息息相关，因此需要重点掌握，后两个纬度更适合DBA进行深入学习，简单了解就好。下面介绍前两个纬度。\n\n## 6.1 表结构和索引的优化\n\n应该掌握如下6个原则：\n\n- **第1个原则：**要在设计表结构时，考虑数据库的水平与垂直扩展能力，提前规划好未来1年的数据量、读写量的增长，规划好分库分表方案。比如设计用户信息表，预计1年后用户数据10亿条，写QPS约5000，读QPS30000，可以设计按UID纬度进行散列，分为4个库每个库32张表，单表数据量控制在KW级别；\n- **第2个原则：**要为字段选择合适的数据类型，在保留扩展能力的前提下，优先选用较小的数据结构。例如保存年龄的字段，要使用TINYINT而不要使用INT；\n- **第3个原则：**可以将字段多的表分解成多个表，必要时增加中间表进行关联。假如一张表有4、50个字段显然不是一个好的设计；\n- **第4个原则：**是设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度；\n- **第5个原则：**要擅用索引，比如为经常作为查询条件的字段创建索引、创建联合索引时要根据最左原则考虑索引的复用能力，不要重复创建索引；要为保证数据不能重复的字段创建唯一索引等等。不过要注意索引对插入、更新等写操作是有代价的，不要滥用索引。比如像性别这样唯一很差的字段就不适合建立索引；\n- **第6个原则：**列字段尽量设置为Not Null，MySQL难以对使用Null的列进行查询优化，允许Null会使索引、索引统计和值更加复杂。允许Null值的列需要更多的存储空间，还需要MySQL内部进行特殊处理。\n\n## 6.2 SQL语句进行优化的原则\n\n共分5个原则：\n\n- **第1个原则：**要找的最需要优化的SQL语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询MySQL的慢查询日志来发现需要进行优化的SQL语句；\n- **第2个原则：**要学会利用MySQL提供的分析工具。例如使用Explain来分析语句的执行计划，看看是否使用了索引，使用了哪个索引，扫描了多少记录，是否使用文件排序等等。或者利用Profile命令来分析某个语句执行过程中各个分步的耗时；\n- **第3个原则：**要注意使用查询语句是要避免使用Select *，而是应该指定具体需要获取的字段。原因一是可以避免查询出不需要使用的字段，二是可以避免查询列字段的元信息；\n- **第4个原则：**是尽量使用Prepared Statements，一个是性能更好，另一个是可以防止SQL注入；\n- **第5个原则：**是尽量使用索引扫描来进行排序，也就是尽量在有索引的字段上进行排序操作。","source":"_posts/2019/MySQL知识点.md","raw":"---\ntitle: MySQL知识点\ndate: 2019-04-14 01:31:54\nupdated: 2019-04-14 01:31:54\ntags: 数据库\n---\n# 1. MySQL中主要的存储引擎\n\nMyISAM是MySQL官方提供的存储引擎，其特点是支持全文索引，查询效率比较高，缺点是不支持事务、使用表级锁。InnoDB在5.5版本后成为了Mysql的默认存储引擎，特点是支持ACID事务、支持外键、支持行级锁提高了并发效率。TokuDB是第三方开发的开源存储引擎，有非常快的写速度，支持数据的压缩存储、可以在线添加索引而不影响读写操作。但是因为压缩的原因，TokuDB非常适合访问频率不高的数据或历史数据归档，不适合大量读取的场景。\n\n<!-- more -->\n\n# 2. MySQL中的锁\n表锁、行锁、共享锁、排它锁。\n\nMyIASAM使用表级锁，InnoDB使用行级锁。表锁开销小，加锁快，不会出现死锁；但是锁的粒度大，发生锁冲突的概率高，并发访问效率比较低。行级锁开销大，加锁慢，有可能会出现死锁，不过因为锁定粒度最小，发生锁冲突的概率低，并发访问效率比较高。\n\n共享锁也就是读锁，其他事务可以读，但不能写。MySQL可以通过Lock In Share Mode语句显示使用共享锁。\n\n排他锁就是写锁，其他事务不能读取，也不能写。对于Update、Delete和INSERT语句，InnoDB会自动给涉及的数据集加排他锁，或者使用select for update显示使用排他锁。\n\n# 3. 索引\n索引可以大幅增加数据库的查询的性能，在实际业务场景中，或多或少都会使用到。\n\n**但是索引是有如下2个代价的:**\na.需要额外的磁盘空间来保存索引\nb.对于插入、更新、删除等操作由于更新索引会增加额外的开销\n\n因此索引比较适合用在读多写少的场景。\n\n## 3.1 MySQL索引类型\n\n共分为5类：\n\n- **唯一索引：**就是索引列中的值必须是唯一的，但是允许出现空值。这种索引一般用来保证数据的唯一性，比如保存账户信息的表，每个账户的id必须保证唯一，如果重复插入相同的账户id时会MySQL返回异常。\n- **主键索引：**是一种特殊的唯一索引，但是它不允许出现空值。\n- **普通索引：**与唯一索引不同，它允许索引列中存在相同的值。例如学生的成绩表，各个学科的分数是允许重复的，就可以使用普通索引。\n- **联合索引：**就是由多个列共同组成的索引。一个表中含有多个单列的索引并不是联合索引，联合索引是对多个列字段按顺序共同组成一个索引。应用联合索引时需要注意最左原则，就是Where查询条件中的字段必须与索引字段从左到右进行匹配。比如，一个用户信息表，用姓名和年龄组成了联合索引，如果查询条件是姓名等于张三，那么满足最左原则；如果查询条件是年龄大于20，由于索引中最左的字段是姓名不是年龄，所以不能使用这个索引。\n- **全文索引：**前面提到了，MyISAM引擎中实现了这个索引，在5.6版本后InnoDB引擎也支持了全文索引，并且在5.7.6版本后支持了中文索引。全文索引只能在CHAR,VARCHAR,TEXT类型字段上使用，底层使用倒排索引实现。要注意对于大数据量的表，生成全文索引会非常消耗时间也非常消耗磁盘空间。\n\n## 3.2 索引实现\n\n索引实现共分4种形式：\n\n- **B+树实现：**b+树比较适合用作'>'或'<'这样的范围查询，是MySQL中最常使用的一种索引实现。\n- **R-tree：**是一种用于处理多维数据的数据结构，可以对地理数据进行空间索引。不过实际业务场景中使用的比较少。\n- **Hash：**是使用散列表来对数据进行索引，Hash方式不像Btree那样需要多次查询才能定位到记录，因此Hash索引的效率高于B-tree，但是不支持范围查找和排序等功能.实际使用的也比较少。\n- **FullText：**就是我们前面提到的全文索引，是一种记录关键字与对应文档关系的倒排索引。\n\n# 4. MySQL的存储过程与函数\n\n存储过程和函数都可以避免开发人员重复编写相同的SQL语句，并且存储过程和函数都是在MySQL服务器中执行的，可以减少客户端和服务器端的数据传输。\n\n存储过程能够实现更复杂的功能，而函数一般用来实现针对性比较强的功能，例如特殊策略求和等。存储过程可以执行包括修改表等一系列数据库操作，而用户定义函数不能用于执行修改全局数据库状态的操作。\n\n存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用。SQL语句中不能使用存储过程，但可以使用函数。\n\n不过存储过程一般与数据库实现绑定，使用存储过程会降低程序的可移植性，应谨慎使用。\n\n# 5. 新特性\n\n可以了解MySQL8.0的一些新特性，例如默认字符集格式改为了UTF8；增加了隐藏索引的功能，隐藏后的索引不会被查询优化器使用，可以使用这个特性用于性能调试；支持了通用表表达式，使复杂查询中的嵌入表语句更加清晰；新增了窗口函数的概念，它可以用来实现新的查询方式。窗口函数与 SUM、COUNT等集合函数类似，但不会将多行查询结果合并，而是将结果放在多行中。即窗口函数不需要GROUP BY。\n\n# 6. MySQL调优\n\n一般MySQL调优有4个纬度：\n\n- 针对数据库设计、表结构设计以及索引设置纬度进行的优化；\n- 对业务中使用的SQL语句进行优化，例如调整Where查询条件；\n- 对mysql服务的配置进行优化，例如对链接数的管理，对索引缓存、查询缓存、排序缓存等各种缓存大小进行优化;\n- 对硬件设备和操作系统设置进行优化，例如调整操作系统参数、禁用Swap、增加内存、升级固态硬盘等等。\n\n这四个纬度从优化的成本角度来讲，从上到下优化成本逐渐升高；从优化效果角度来看，从下到上优化的效果更高。\n\n对于研发人员来说，前两个纬度与业务息息相关，因此需要重点掌握，后两个纬度更适合DBA进行深入学习，简单了解就好。下面介绍前两个纬度。\n\n## 6.1 表结构和索引的优化\n\n应该掌握如下6个原则：\n\n- **第1个原则：**要在设计表结构时，考虑数据库的水平与垂直扩展能力，提前规划好未来1年的数据量、读写量的增长，规划好分库分表方案。比如设计用户信息表，预计1年后用户数据10亿条，写QPS约5000，读QPS30000，可以设计按UID纬度进行散列，分为4个库每个库32张表，单表数据量控制在KW级别；\n- **第2个原则：**要为字段选择合适的数据类型，在保留扩展能力的前提下，优先选用较小的数据结构。例如保存年龄的字段，要使用TINYINT而不要使用INT；\n- **第3个原则：**可以将字段多的表分解成多个表，必要时增加中间表进行关联。假如一张表有4、50个字段显然不是一个好的设计；\n- **第4个原则：**是设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度；\n- **第5个原则：**要擅用索引，比如为经常作为查询条件的字段创建索引、创建联合索引时要根据最左原则考虑索引的复用能力，不要重复创建索引；要为保证数据不能重复的字段创建唯一索引等等。不过要注意索引对插入、更新等写操作是有代价的，不要滥用索引。比如像性别这样唯一很差的字段就不适合建立索引；\n- **第6个原则：**列字段尽量设置为Not Null，MySQL难以对使用Null的列进行查询优化，允许Null会使索引、索引统计和值更加复杂。允许Null值的列需要更多的存储空间，还需要MySQL内部进行特殊处理。\n\n## 6.2 SQL语句进行优化的原则\n\n共分5个原则：\n\n- **第1个原则：**要找的最需要优化的SQL语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询MySQL的慢查询日志来发现需要进行优化的SQL语句；\n- **第2个原则：**要学会利用MySQL提供的分析工具。例如使用Explain来分析语句的执行计划，看看是否使用了索引，使用了哪个索引，扫描了多少记录，是否使用文件排序等等。或者利用Profile命令来分析某个语句执行过程中各个分步的耗时；\n- **第3个原则：**要注意使用查询语句是要避免使用Select *，而是应该指定具体需要获取的字段。原因一是可以避免查询出不需要使用的字段，二是可以避免查询列字段的元信息；\n- **第4个原则：**是尽量使用Prepared Statements，一个是性能更好，另一个是可以防止SQL注入；\n- **第5个原则：**是尽量使用索引扫描来进行排序，也就是尽量在有索引的字段上进行排序操作。","slug":"2019-MySQL知识点","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrk1000k2yku7wcg5n23","content":"<h1 id=\"1-MySQL中主要的存储引擎\"><a href=\"#1-MySQL中主要的存储引擎\" class=\"headerlink\" title=\"1. MySQL中主要的存储引擎\"></a>1. MySQL中主要的存储引擎</h1><p>MyISAM是MySQL官方提供的存储引擎，其特点是支持全文索引，查询效率比较高，缺点是不支持事务、使用表级锁。InnoDB在5.5版本后成为了Mysql的默认存储引擎，特点是支持ACID事务、支持外键、支持行级锁提高了并发效率。TokuDB是第三方开发的开源存储引擎，有非常快的写速度，支持数据的压缩存储、可以在线添加索引而不影响读写操作。但是因为压缩的原因，TokuDB非常适合访问频率不高的数据或历史数据归档，不适合大量读取的场景。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"2-MySQL中的锁\"><a href=\"#2-MySQL中的锁\" class=\"headerlink\" title=\"2. MySQL中的锁\"></a>2. MySQL中的锁</h1><p>表锁、行锁、共享锁、排它锁。</p>\n<p>MyIASAM使用表级锁，InnoDB使用行级锁。表锁开销小，加锁快，不会出现死锁；但是锁的粒度大，发生锁冲突的概率高，并发访问效率比较低。行级锁开销大，加锁慢，有可能会出现死锁，不过因为锁定粒度最小，发生锁冲突的概率低，并发访问效率比较高。</p>\n<p>共享锁也就是读锁，其他事务可以读，但不能写。MySQL可以通过Lock In Share Mode语句显示使用共享锁。</p>\n<p>排他锁就是写锁，其他事务不能读取，也不能写。对于Update、Delete和INSERT语句，InnoDB会自动给涉及的数据集加排他锁，或者使用select for update显示使用排他锁。</p>\n<h1 id=\"3-索引\"><a href=\"#3-索引\" class=\"headerlink\" title=\"3. 索引\"></a>3. 索引</h1><p>索引可以大幅增加数据库的查询的性能，在实际业务场景中，或多或少都会使用到。</p>\n<p><strong>但是索引是有如下2个代价的:</strong><br>a.需要额外的磁盘空间来保存索引<br>b.对于插入、更新、删除等操作由于更新索引会增加额外的开销</p>\n<p>因此索引比较适合用在读多写少的场景。</p>\n<h2 id=\"3-1-MySQL索引类型\"><a href=\"#3-1-MySQL索引类型\" class=\"headerlink\" title=\"3.1 MySQL索引类型\"></a>3.1 MySQL索引类型</h2><p>共分为5类：</p>\n<ul>\n<li><strong>唯一索引：</strong>就是索引列中的值必须是唯一的，但是允许出现空值。这种索引一般用来保证数据的唯一性，比如保存账户信息的表，每个账户的id必须保证唯一，如果重复插入相同的账户id时会MySQL返回异常。</li>\n<li><strong>主键索引：</strong>是一种特殊的唯一索引，但是它不允许出现空值。</li>\n<li><strong>普通索引：</strong>与唯一索引不同，它允许索引列中存在相同的值。例如学生的成绩表，各个学科的分数是允许重复的，就可以使用普通索引。</li>\n<li><strong>联合索引：</strong>就是由多个列共同组成的索引。一个表中含有多个单列的索引并不是联合索引，联合索引是对多个列字段按顺序共同组成一个索引。应用联合索引时需要注意最左原则，就是Where查询条件中的字段必须与索引字段从左到右进行匹配。比如，一个用户信息表，用姓名和年龄组成了联合索引，如果查询条件是姓名等于张三，那么满足最左原则；如果查询条件是年龄大于20，由于索引中最左的字段是姓名不是年龄，所以不能使用这个索引。</li>\n<li><strong>全文索引：</strong>前面提到了，MyISAM引擎中实现了这个索引，在5.6版本后InnoDB引擎也支持了全文索引，并且在5.7.6版本后支持了中文索引。全文索引只能在CHAR,VARCHAR,TEXT类型字段上使用，底层使用倒排索引实现。要注意对于大数据量的表，生成全文索引会非常消耗时间也非常消耗磁盘空间。</li>\n</ul>\n<h2 id=\"3-2-索引实现\"><a href=\"#3-2-索引实现\" class=\"headerlink\" title=\"3.2 索引实现\"></a>3.2 索引实现</h2><p>索引实现共分4种形式：</p>\n<ul>\n<li><strong>B+树实现：</strong>b+树比较适合用作’&gt;’或’&lt;’这样的范围查询，是MySQL中最常使用的一种索引实现。</li>\n<li><strong>R-tree：</strong>是一种用于处理多维数据的数据结构，可以对地理数据进行空间索引。不过实际业务场景中使用的比较少。</li>\n<li><strong>Hash：</strong>是使用散列表来对数据进行索引，Hash方式不像Btree那样需要多次查询才能定位到记录，因此Hash索引的效率高于B-tree，但是不支持范围查找和排序等功能.实际使用的也比较少。</li>\n<li><strong>FullText：</strong>就是我们前面提到的全文索引，是一种记录关键字与对应文档关系的倒排索引。</li>\n</ul>\n<h1 id=\"4-MySQL的存储过程与函数\"><a href=\"#4-MySQL的存储过程与函数\" class=\"headerlink\" title=\"4. MySQL的存储过程与函数\"></a>4. MySQL的存储过程与函数</h1><p>存储过程和函数都可以避免开发人员重复编写相同的SQL语句，并且存储过程和函数都是在MySQL服务器中执行的，可以减少客户端和服务器端的数据传输。</p>\n<p>存储过程能够实现更复杂的功能，而函数一般用来实现针对性比较强的功能，例如特殊策略求和等。存储过程可以执行包括修改表等一系列数据库操作，而用户定义函数不能用于执行修改全局数据库状态的操作。</p>\n<p>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用。SQL语句中不能使用存储过程，但可以使用函数。</p>\n<p>不过存储过程一般与数据库实现绑定，使用存储过程会降低程序的可移植性，应谨慎使用。</p>\n<h1 id=\"5-新特性\"><a href=\"#5-新特性\" class=\"headerlink\" title=\"5. 新特性\"></a>5. 新特性</h1><p>可以了解MySQL8.0的一些新特性，例如默认字符集格式改为了UTF8；增加了隐藏索引的功能，隐藏后的索引不会被查询优化器使用，可以使用这个特性用于性能调试；支持了通用表表达式，使复杂查询中的嵌入表语句更加清晰；新增了窗口函数的概念，它可以用来实现新的查询方式。窗口函数与 SUM、COUNT等集合函数类似，但不会将多行查询结果合并，而是将结果放在多行中。即窗口函数不需要GROUP BY。</p>\n<h1 id=\"6-MySQL调优\"><a href=\"#6-MySQL调优\" class=\"headerlink\" title=\"6. MySQL调优\"></a>6. MySQL调优</h1><p>一般MySQL调优有4个纬度：</p>\n<ul>\n<li>针对数据库设计、表结构设计以及索引设置纬度进行的优化；</li>\n<li>对业务中使用的SQL语句进行优化，例如调整Where查询条件；</li>\n<li>对mysql服务的配置进行优化，例如对链接数的管理，对索引缓存、查询缓存、排序缓存等各种缓存大小进行优化;</li>\n<li>对硬件设备和操作系统设置进行优化，例如调整操作系统参数、禁用Swap、增加内存、升级固态硬盘等等。</li>\n</ul>\n<p>这四个纬度从优化的成本角度来讲，从上到下优化成本逐渐升高；从优化效果角度来看，从下到上优化的效果更高。</p>\n<p>对于研发人员来说，前两个纬度与业务息息相关，因此需要重点掌握，后两个纬度更适合DBA进行深入学习，简单了解就好。下面介绍前两个纬度。</p>\n<h2 id=\"6-1-表结构和索引的优化\"><a href=\"#6-1-表结构和索引的优化\" class=\"headerlink\" title=\"6.1 表结构和索引的优化\"></a>6.1 表结构和索引的优化</h2><p>应该掌握如下6个原则：</p>\n<ul>\n<li><strong>第1个原则：</strong>要在设计表结构时，考虑数据库的水平与垂直扩展能力，提前规划好未来1年的数据量、读写量的增长，规划好分库分表方案。比如设计用户信息表，预计1年后用户数据10亿条，写QPS约5000，读QPS30000，可以设计按UID纬度进行散列，分为4个库每个库32张表，单表数据量控制在KW级别；</li>\n<li><strong>第2个原则：</strong>要为字段选择合适的数据类型，在保留扩展能力的前提下，优先选用较小的数据结构。例如保存年龄的字段，要使用TINYINT而不要使用INT；</li>\n<li><strong>第3个原则：</strong>可以将字段多的表分解成多个表，必要时增加中间表进行关联。假如一张表有4、50个字段显然不是一个好的设计；</li>\n<li><strong>第4个原则：</strong>是设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度；</li>\n<li><strong>第5个原则：</strong>要擅用索引，比如为经常作为查询条件的字段创建索引、创建联合索引时要根据最左原则考虑索引的复用能力，不要重复创建索引；要为保证数据不能重复的字段创建唯一索引等等。不过要注意索引对插入、更新等写操作是有代价的，不要滥用索引。比如像性别这样唯一很差的字段就不适合建立索引；</li>\n<li><strong>第6个原则：</strong>列字段尽量设置为Not Null，MySQL难以对使用Null的列进行查询优化，允许Null会使索引、索引统计和值更加复杂。允许Null值的列需要更多的存储空间，还需要MySQL内部进行特殊处理。</li>\n</ul>\n<h2 id=\"6-2-SQL语句进行优化的原则\"><a href=\"#6-2-SQL语句进行优化的原则\" class=\"headerlink\" title=\"6.2 SQL语句进行优化的原则\"></a>6.2 SQL语句进行优化的原则</h2><p>共分5个原则：</p>\n<ul>\n<li><strong>第1个原则：</strong>要找的最需要优化的SQL语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询MySQL的慢查询日志来发现需要进行优化的SQL语句；</li>\n<li><strong>第2个原则：</strong>要学会利用MySQL提供的分析工具。例如使用Explain来分析语句的执行计划，看看是否使用了索引，使用了哪个索引，扫描了多少记录，是否使用文件排序等等。或者利用Profile命令来分析某个语句执行过程中各个分步的耗时；</li>\n<li><strong>第3个原则：</strong>要注意使用查询语句是要避免使用Select *，而是应该指定具体需要获取的字段。原因一是可以避免查询出不需要使用的字段，二是可以避免查询列字段的元信息；</li>\n<li><strong>第4个原则：</strong>是尽量使用Prepared Statements，一个是性能更好，另一个是可以防止SQL注入；</li>\n<li><strong>第5个原则：</strong>是尽量使用索引扫描来进行排序，也就是尽量在有索引的字段上进行排序操作。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-MySQL中主要的存储引擎\"><a href=\"#1-MySQL中主要的存储引擎\" class=\"headerlink\" title=\"1. MySQL中主要的存储引擎\"></a>1. MySQL中主要的存储引擎</h1><p>MyISAM是MySQL官方提供的存储引擎，其特点是支持全文索引，查询效率比较高，缺点是不支持事务、使用表级锁。InnoDB在5.5版本后成为了Mysql的默认存储引擎，特点是支持ACID事务、支持外键、支持行级锁提高了并发效率。TokuDB是第三方开发的开源存储引擎，有非常快的写速度，支持数据的压缩存储、可以在线添加索引而不影响读写操作。但是因为压缩的原因，TokuDB非常适合访问频率不高的数据或历史数据归档，不适合大量读取的场景。</p>","more":"<h1 id=\"2-MySQL中的锁\"><a href=\"#2-MySQL中的锁\" class=\"headerlink\" title=\"2. MySQL中的锁\"></a>2. MySQL中的锁</h1><p>表锁、行锁、共享锁、排它锁。</p>\n<p>MyIASAM使用表级锁，InnoDB使用行级锁。表锁开销小，加锁快，不会出现死锁；但是锁的粒度大，发生锁冲突的概率高，并发访问效率比较低。行级锁开销大，加锁慢，有可能会出现死锁，不过因为锁定粒度最小，发生锁冲突的概率低，并发访问效率比较高。</p>\n<p>共享锁也就是读锁，其他事务可以读，但不能写。MySQL可以通过Lock In Share Mode语句显示使用共享锁。</p>\n<p>排他锁就是写锁，其他事务不能读取，也不能写。对于Update、Delete和INSERT语句，InnoDB会自动给涉及的数据集加排他锁，或者使用select for update显示使用排他锁。</p>\n<h1 id=\"3-索引\"><a href=\"#3-索引\" class=\"headerlink\" title=\"3. 索引\"></a>3. 索引</h1><p>索引可以大幅增加数据库的查询的性能，在实际业务场景中，或多或少都会使用到。</p>\n<p><strong>但是索引是有如下2个代价的:</strong><br>a.需要额外的磁盘空间来保存索引<br>b.对于插入、更新、删除等操作由于更新索引会增加额外的开销</p>\n<p>因此索引比较适合用在读多写少的场景。</p>\n<h2 id=\"3-1-MySQL索引类型\"><a href=\"#3-1-MySQL索引类型\" class=\"headerlink\" title=\"3.1 MySQL索引类型\"></a>3.1 MySQL索引类型</h2><p>共分为5类：</p>\n<ul>\n<li><strong>唯一索引：</strong>就是索引列中的值必须是唯一的，但是允许出现空值。这种索引一般用来保证数据的唯一性，比如保存账户信息的表，每个账户的id必须保证唯一，如果重复插入相同的账户id时会MySQL返回异常。</li>\n<li><strong>主键索引：</strong>是一种特殊的唯一索引，但是它不允许出现空值。</li>\n<li><strong>普通索引：</strong>与唯一索引不同，它允许索引列中存在相同的值。例如学生的成绩表，各个学科的分数是允许重复的，就可以使用普通索引。</li>\n<li><strong>联合索引：</strong>就是由多个列共同组成的索引。一个表中含有多个单列的索引并不是联合索引，联合索引是对多个列字段按顺序共同组成一个索引。应用联合索引时需要注意最左原则，就是Where查询条件中的字段必须与索引字段从左到右进行匹配。比如，一个用户信息表，用姓名和年龄组成了联合索引，如果查询条件是姓名等于张三，那么满足最左原则；如果查询条件是年龄大于20，由于索引中最左的字段是姓名不是年龄，所以不能使用这个索引。</li>\n<li><strong>全文索引：</strong>前面提到了，MyISAM引擎中实现了这个索引，在5.6版本后InnoDB引擎也支持了全文索引，并且在5.7.6版本后支持了中文索引。全文索引只能在CHAR,VARCHAR,TEXT类型字段上使用，底层使用倒排索引实现。要注意对于大数据量的表，生成全文索引会非常消耗时间也非常消耗磁盘空间。</li>\n</ul>\n<h2 id=\"3-2-索引实现\"><a href=\"#3-2-索引实现\" class=\"headerlink\" title=\"3.2 索引实现\"></a>3.2 索引实现</h2><p>索引实现共分4种形式：</p>\n<ul>\n<li><strong>B+树实现：</strong>b+树比较适合用作’&gt;’或’&lt;’这样的范围查询，是MySQL中最常使用的一种索引实现。</li>\n<li><strong>R-tree：</strong>是一种用于处理多维数据的数据结构，可以对地理数据进行空间索引。不过实际业务场景中使用的比较少。</li>\n<li><strong>Hash：</strong>是使用散列表来对数据进行索引，Hash方式不像Btree那样需要多次查询才能定位到记录，因此Hash索引的效率高于B-tree，但是不支持范围查找和排序等功能.实际使用的也比较少。</li>\n<li><strong>FullText：</strong>就是我们前面提到的全文索引，是一种记录关键字与对应文档关系的倒排索引。</li>\n</ul>\n<h1 id=\"4-MySQL的存储过程与函数\"><a href=\"#4-MySQL的存储过程与函数\" class=\"headerlink\" title=\"4. MySQL的存储过程与函数\"></a>4. MySQL的存储过程与函数</h1><p>存储过程和函数都可以避免开发人员重复编写相同的SQL语句，并且存储过程和函数都是在MySQL服务器中执行的，可以减少客户端和服务器端的数据传输。</p>\n<p>存储过程能够实现更复杂的功能，而函数一般用来实现针对性比较强的功能，例如特殊策略求和等。存储过程可以执行包括修改表等一系列数据库操作，而用户定义函数不能用于执行修改全局数据库状态的操作。</p>\n<p>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用。SQL语句中不能使用存储过程，但可以使用函数。</p>\n<p>不过存储过程一般与数据库实现绑定，使用存储过程会降低程序的可移植性，应谨慎使用。</p>\n<h1 id=\"5-新特性\"><a href=\"#5-新特性\" class=\"headerlink\" title=\"5. 新特性\"></a>5. 新特性</h1><p>可以了解MySQL8.0的一些新特性，例如默认字符集格式改为了UTF8；增加了隐藏索引的功能，隐藏后的索引不会被查询优化器使用，可以使用这个特性用于性能调试；支持了通用表表达式，使复杂查询中的嵌入表语句更加清晰；新增了窗口函数的概念，它可以用来实现新的查询方式。窗口函数与 SUM、COUNT等集合函数类似，但不会将多行查询结果合并，而是将结果放在多行中。即窗口函数不需要GROUP BY。</p>\n<h1 id=\"6-MySQL调优\"><a href=\"#6-MySQL调优\" class=\"headerlink\" title=\"6. MySQL调优\"></a>6. MySQL调优</h1><p>一般MySQL调优有4个纬度：</p>\n<ul>\n<li>针对数据库设计、表结构设计以及索引设置纬度进行的优化；</li>\n<li>对业务中使用的SQL语句进行优化，例如调整Where查询条件；</li>\n<li>对mysql服务的配置进行优化，例如对链接数的管理，对索引缓存、查询缓存、排序缓存等各种缓存大小进行优化;</li>\n<li>对硬件设备和操作系统设置进行优化，例如调整操作系统参数、禁用Swap、增加内存、升级固态硬盘等等。</li>\n</ul>\n<p>这四个纬度从优化的成本角度来讲，从上到下优化成本逐渐升高；从优化效果角度来看，从下到上优化的效果更高。</p>\n<p>对于研发人员来说，前两个纬度与业务息息相关，因此需要重点掌握，后两个纬度更适合DBA进行深入学习，简单了解就好。下面介绍前两个纬度。</p>\n<h2 id=\"6-1-表结构和索引的优化\"><a href=\"#6-1-表结构和索引的优化\" class=\"headerlink\" title=\"6.1 表结构和索引的优化\"></a>6.1 表结构和索引的优化</h2><p>应该掌握如下6个原则：</p>\n<ul>\n<li><strong>第1个原则：</strong>要在设计表结构时，考虑数据库的水平与垂直扩展能力，提前规划好未来1年的数据量、读写量的增长，规划好分库分表方案。比如设计用户信息表，预计1年后用户数据10亿条，写QPS约5000，读QPS30000，可以设计按UID纬度进行散列，分为4个库每个库32张表，单表数据量控制在KW级别；</li>\n<li><strong>第2个原则：</strong>要为字段选择合适的数据类型，在保留扩展能力的前提下，优先选用较小的数据结构。例如保存年龄的字段，要使用TINYINT而不要使用INT；</li>\n<li><strong>第3个原则：</strong>可以将字段多的表分解成多个表，必要时增加中间表进行关联。假如一张表有4、50个字段显然不是一个好的设计；</li>\n<li><strong>第4个原则：</strong>是设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度；</li>\n<li><strong>第5个原则：</strong>要擅用索引，比如为经常作为查询条件的字段创建索引、创建联合索引时要根据最左原则考虑索引的复用能力，不要重复创建索引；要为保证数据不能重复的字段创建唯一索引等等。不过要注意索引对插入、更新等写操作是有代价的，不要滥用索引。比如像性别这样唯一很差的字段就不适合建立索引；</li>\n<li><strong>第6个原则：</strong>列字段尽量设置为Not Null，MySQL难以对使用Null的列进行查询优化，允许Null会使索引、索引统计和值更加复杂。允许Null值的列需要更多的存储空间，还需要MySQL内部进行特殊处理。</li>\n</ul>\n<h2 id=\"6-2-SQL语句进行优化的原则\"><a href=\"#6-2-SQL语句进行优化的原则\" class=\"headerlink\" title=\"6.2 SQL语句进行优化的原则\"></a>6.2 SQL语句进行优化的原则</h2><p>共分5个原则：</p>\n<ul>\n<li><strong>第1个原则：</strong>要找的最需要优化的SQL语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询MySQL的慢查询日志来发现需要进行优化的SQL语句；</li>\n<li><strong>第2个原则：</strong>要学会利用MySQL提供的分析工具。例如使用Explain来分析语句的执行计划，看看是否使用了索引，使用了哪个索引，扫描了多少记录，是否使用文件排序等等。或者利用Profile命令来分析某个语句执行过程中各个分步的耗时；</li>\n<li><strong>第3个原则：</strong>要注意使用查询语句是要避免使用Select *，而是应该指定具体需要获取的字段。原因一是可以避免查询出不需要使用的字段，二是可以避免查询列字段的元信息；</li>\n<li><strong>第4个原则：</strong>是尽量使用Prepared Statements，一个是性能更好，另一个是可以防止SQL注入；</li>\n<li><strong>第5个原则：</strong>是尽量使用索引扫描来进行排序，也就是尽量在有索引的字段上进行排序操作。</li>\n</ul>"},{"title":"乐观锁和悲观锁","date":"2019-02-27T06:36:00.000Z","updated":"2019-02-27T06:36:00.000Z","_content":"\n# 1. 前置知识\n## 1.1 并行与并发\n并发是指在一段时间内宏观上多个程序同时运行。\n并行指的是同一个时刻，多个任务确实真的在同时运行。\n\n<!-- more -->\n\n## 1.2 读现象\n> 通过在写的时候加锁，可以解决脏读。\n> 通过在读的时候加锁，可以解决不可重复读。\n> 通过串行化，可以解决幻读。\n\n### 1.2.1 脏读\n第一种读现象叫做脏读，顾名思义，就是读到了脏数据，即无效数据。\n\n脏读。是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交(commit)到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。\n\n为了解决脏读问题，所以要提高一点隔离性，我在修改代码的时候，不允许别人读代码。他只能读取到我提交后的代码。但是，提高了隔离性，并发性就降低了一些。\n### 1.2.2 不可重复读\n不可重复读。是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。\n我在读读取某一数据的时候，你先不要修改它，这就是进一步提升了隔离性了。\n### 1.2.3 幻读\n幻读。指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。比如同一个事务A内第一次查询时候有n条记录，但是第二次同等条件下查询却又n+1条记录，这就好像产生了幻觉。\n幻读是不可重复读的一种特殊场景。\n### 1.2.4 不可重复读和幻读的区别\n**不可重复读重点在于update和delete，而幻读的重点在于insert**\n\n## 1.3 并发控制\n当程序中可能出现并发的情况时，我们就需要通过一定的手段来保证在并发情况下数据的准确性，通过这种手段保证了当用户和其他用户一起操作时，所得到的结果和他单独操作时的希望的结果是一样的。\n并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。\n没有做好并发控制，就可能导致脏读、不可重复读和幻读等问题。\n\n实现并发控制的主要手段大致可以分为**乐观并发控制**和**悲观并发控制**两种。\n\n# 2. 悲观锁\n当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。\n\n这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。\n\n之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。\n\n悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。\n\n## 2.1 悲观锁实现方式\n悲观锁的实现，往往依靠数据库提供的锁机制。在数据库中，悲观锁的流程如下：\n\n- 在对记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。\n- 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。\n- 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。\n- 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。\n\n拿比较常用的MySql Innodb引擎举例，来说明一下在SQL中如何使用悲观锁。\n\n> 要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;\n\n我们举一个简单的例子，如淘宝下单过程中扣减库存的需求说明一下如何使用悲观锁：\n```\n//0.开始事务\nbegin; \n//1.查询出商品库存信息\nselect quantity from items where id=1 for update;\n//2.修改商品库存为2\nupdate items set quantity=2 where id = 1;\n//3.提交事务\ncommit;\n```\n以上，在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。\n如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。\n\n> MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。\n\n# 3. 乐观锁\n乐观锁（Optimistic Locking）是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。\n\n相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。\n\n￼乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。\n\n## 3.1 乐观锁实现方式\n使用乐观锁就不需要借助数据库的锁机制了。\n\n乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。\n\nCAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。\n\n比如前面的扣减库存问题，通过乐观锁可以实现如下：\n```\n//查询出商品库存信息，quantity = 3\nselect quantity from items where id=1\n//修改商品库存为2\nupdate items set quantity=2 where id=1 and quantity = 3;\n```\n以上，我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。\n\n## 3.2 ABA问题\n以上更新语句存在一个比较重要的问题，即传说中的ABA问题。\n\n比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。\n\n￼有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段。改为以下方式即可：\n```\n//查询出商品信息，version = 1\nselect version from items where id=1\n//修改商品库存为2\nupdate items set quantity=2,version = 3 where id=1 and version = 2;\n```\n乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。\n\n以上SQL其实还是有一定的问题的，就是一旦发上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。\n## 3.3 高并发环境下锁粒度把控\n对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。\n有一条比较好的建议，可以减小乐观锁粒度，最大程度的提升吞吐率，提高并发能力！如下：\n```\n//修改商品库存\nupdate item \nset quantity=quantity - 1 \nwhere id = 1 and quantity - 1 > 0\n```\n以上SQL语句中，如果用户下单数为1，则通过quantity - 1 > 0的方式进行乐观锁控制。\n以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。\n\n怎样才算合理的加锁粒度呢？\n其实卫生间并不只是用来上厕所的，还可以洗澡，洗手。这里就涉及到优化加锁粒度的问题。\n你在卫生间里洗澡，其实别人也可以同时去里面洗手，只要做到隔离起来就可以，如果马桶，浴缸，洗漱台都是隔开相对独立的，实际上卫生间可以同时给三个人使用。\n当然三个人做的事儿不能一样。这样就细化了加锁粒度，你在洗澡的时候只要关上浴室的门，别人还是可以进去洗手的。如果当初设计卫生间的时候没有将不同的功能区域划分隔离开，就不能实现卫生间资源的最大化使用。这就是设计架构的重要性。\n# 4. 如何选择\n在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。\n\n1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。 \n\n2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。\n\n随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。","source":"_posts/2019/乐观锁和悲观锁.md","raw":"---\ntitle: 乐观锁和悲观锁\ndate: 2019-02-27 14:36\nupdated: 2019-02-27 14:36\ntags: 并发\n---\n\n# 1. 前置知识\n## 1.1 并行与并发\n并发是指在一段时间内宏观上多个程序同时运行。\n并行指的是同一个时刻，多个任务确实真的在同时运行。\n\n<!-- more -->\n\n## 1.2 读现象\n> 通过在写的时候加锁，可以解决脏读。\n> 通过在读的时候加锁，可以解决不可重复读。\n> 通过串行化，可以解决幻读。\n\n### 1.2.1 脏读\n第一种读现象叫做脏读，顾名思义，就是读到了脏数据，即无效数据。\n\n脏读。是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交(commit)到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。\n\n为了解决脏读问题，所以要提高一点隔离性，我在修改代码的时候，不允许别人读代码。他只能读取到我提交后的代码。但是，提高了隔离性，并发性就降低了一些。\n### 1.2.2 不可重复读\n不可重复读。是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。\n我在读读取某一数据的时候，你先不要修改它，这就是进一步提升了隔离性了。\n### 1.2.3 幻读\n幻读。指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。比如同一个事务A内第一次查询时候有n条记录，但是第二次同等条件下查询却又n+1条记录，这就好像产生了幻觉。\n幻读是不可重复读的一种特殊场景。\n### 1.2.4 不可重复读和幻读的区别\n**不可重复读重点在于update和delete，而幻读的重点在于insert**\n\n## 1.3 并发控制\n当程序中可能出现并发的情况时，我们就需要通过一定的手段来保证在并发情况下数据的准确性，通过这种手段保证了当用户和其他用户一起操作时，所得到的结果和他单独操作时的希望的结果是一样的。\n并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。\n没有做好并发控制，就可能导致脏读、不可重复读和幻读等问题。\n\n实现并发控制的主要手段大致可以分为**乐观并发控制**和**悲观并发控制**两种。\n\n# 2. 悲观锁\n当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。\n\n这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。\n\n之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。\n\n悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。\n\n## 2.1 悲观锁实现方式\n悲观锁的实现，往往依靠数据库提供的锁机制。在数据库中，悲观锁的流程如下：\n\n- 在对记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。\n- 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。\n- 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。\n- 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。\n\n拿比较常用的MySql Innodb引擎举例，来说明一下在SQL中如何使用悲观锁。\n\n> 要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;\n\n我们举一个简单的例子，如淘宝下单过程中扣减库存的需求说明一下如何使用悲观锁：\n```\n//0.开始事务\nbegin; \n//1.查询出商品库存信息\nselect quantity from items where id=1 for update;\n//2.修改商品库存为2\nupdate items set quantity=2 where id = 1;\n//3.提交事务\ncommit;\n```\n以上，在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。\n如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。\n\n> MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。\n\n# 3. 乐观锁\n乐观锁（Optimistic Locking）是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。\n\n相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。\n\n￼乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。\n\n## 3.1 乐观锁实现方式\n使用乐观锁就不需要借助数据库的锁机制了。\n\n乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。\n\nCAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。\n\n比如前面的扣减库存问题，通过乐观锁可以实现如下：\n```\n//查询出商品库存信息，quantity = 3\nselect quantity from items where id=1\n//修改商品库存为2\nupdate items set quantity=2 where id=1 and quantity = 3;\n```\n以上，我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。\n\n## 3.2 ABA问题\n以上更新语句存在一个比较重要的问题，即传说中的ABA问题。\n\n比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。\n\n￼有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段。改为以下方式即可：\n```\n//查询出商品信息，version = 1\nselect version from items where id=1\n//修改商品库存为2\nupdate items set quantity=2,version = 3 where id=1 and version = 2;\n```\n乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。\n\n以上SQL其实还是有一定的问题的，就是一旦发上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。\n## 3.3 高并发环境下锁粒度把控\n对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。\n有一条比较好的建议，可以减小乐观锁粒度，最大程度的提升吞吐率，提高并发能力！如下：\n```\n//修改商品库存\nupdate item \nset quantity=quantity - 1 \nwhere id = 1 and quantity - 1 > 0\n```\n以上SQL语句中，如果用户下单数为1，则通过quantity - 1 > 0的方式进行乐观锁控制。\n以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。\n\n怎样才算合理的加锁粒度呢？\n其实卫生间并不只是用来上厕所的，还可以洗澡，洗手。这里就涉及到优化加锁粒度的问题。\n你在卫生间里洗澡，其实别人也可以同时去里面洗手，只要做到隔离起来就可以，如果马桶，浴缸，洗漱台都是隔开相对独立的，实际上卫生间可以同时给三个人使用。\n当然三个人做的事儿不能一样。这样就细化了加锁粒度，你在洗澡的时候只要关上浴室的门，别人还是可以进去洗手的。如果当初设计卫生间的时候没有将不同的功能区域划分隔离开，就不能实现卫生间资源的最大化使用。这就是设计架构的重要性。\n# 4. 如何选择\n在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。\n\n1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。 \n\n2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。\n\n随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。","slug":"2019-乐观锁和悲观锁","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrk3000m2ykue3k1a4hu","content":"<h1 id=\"1-前置知识\"><a href=\"#1-前置知识\" class=\"headerlink\" title=\"1. 前置知识\"></a>1. 前置知识</h1><h2 id=\"1-1-并行与并发\"><a href=\"#1-1-并行与并发\" class=\"headerlink\" title=\"1.1 并行与并发\"></a>1.1 并行与并发</h2><p>并发是指在一段时间内宏观上多个程序同时运行。<br>并行指的是同一个时刻，多个任务确实真的在同时运行。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"1-2-读现象\"><a href=\"#1-2-读现象\" class=\"headerlink\" title=\"1.2 读现象\"></a>1.2 读现象</h2><blockquote>\n<p>通过在写的时候加锁，可以解决脏读。<br>通过在读的时候加锁，可以解决不可重复读。<br>通过串行化，可以解决幻读。</p>\n</blockquote>\n<h3 id=\"1-2-1-脏读\"><a href=\"#1-2-1-脏读\" class=\"headerlink\" title=\"1.2.1 脏读\"></a>1.2.1 脏读</h3><p>第一种读现象叫做脏读，顾名思义，就是读到了脏数据，即无效数据。</p>\n<p>脏读。是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交(commit)到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p>\n<p>为了解决脏读问题，所以要提高一点隔离性，我在修改代码的时候，不允许别人读代码。他只能读取到我提交后的代码。但是，提高了隔离性，并发性就降低了一些。</p>\n<h3 id=\"1-2-2-不可重复读\"><a href=\"#1-2-2-不可重复读\" class=\"headerlink\" title=\"1.2.2 不可重复读\"></a>1.2.2 不可重复读</h3><p>不可重复读。是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。<br>我在读读取某一数据的时候，你先不要修改它，这就是进一步提升了隔离性了。</p>\n<h3 id=\"1-2-3-幻读\"><a href=\"#1-2-3-幻读\" class=\"headerlink\" title=\"1.2.3 幻读\"></a>1.2.3 幻读</h3><p>幻读。指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。比如同一个事务A内第一次查询时候有n条记录，但是第二次同等条件下查询却又n+1条记录，这就好像产生了幻觉。<br>幻读是不可重复读的一种特殊场景。</p>\n<h3 id=\"1-2-4-不可重复读和幻读的区别\"><a href=\"#1-2-4-不可重复读和幻读的区别\" class=\"headerlink\" title=\"1.2.4 不可重复读和幻读的区别\"></a>1.2.4 不可重复读和幻读的区别</h3><p><strong>不可重复读重点在于update和delete，而幻读的重点在于insert</strong></p>\n<h2 id=\"1-3-并发控制\"><a href=\"#1-3-并发控制\" class=\"headerlink\" title=\"1.3 并发控制\"></a>1.3 并发控制</h2><p>当程序中可能出现并发的情况时，我们就需要通过一定的手段来保证在并发情况下数据的准确性，通过这种手段保证了当用户和其他用户一起操作时，所得到的结果和他单独操作时的希望的结果是一样的。<br>并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。<br>没有做好并发控制，就可能导致脏读、不可重复读和幻读等问题。</p>\n<p>实现并发控制的主要手段大致可以分为<strong>乐观并发控制</strong>和<strong>悲观并发控制</strong>两种。</p>\n<h1 id=\"2-悲观锁\"><a href=\"#2-悲观锁\" class=\"headerlink\" title=\"2. 悲观锁\"></a>2. 悲观锁</h1><p>当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。</p>\n<p>这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。</p>\n<p>之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。</p>\n<p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。</p>\n<h2 id=\"2-1-悲观锁实现方式\"><a href=\"#2-1-悲观锁实现方式\" class=\"headerlink\" title=\"2.1 悲观锁实现方式\"></a>2.1 悲观锁实现方式</h2><p>悲观锁的实现，往往依靠数据库提供的锁机制。在数据库中，悲观锁的流程如下：</p>\n<ul>\n<li>在对记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li>\n<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。</li>\n<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>\n<li>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li>\n</ul>\n<p>拿比较常用的MySql Innodb引擎举例，来说明一下在SQL中如何使用悲观锁。</p>\n<blockquote>\n<p>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;</p>\n</blockquote>\n<p>我们举一个简单的例子，如淘宝下单过程中扣减库存的需求说明一下如何使用悲观锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;0.开始事务</span><br><span class=\"line\">begin; </span><br><span class=\"line\">&#x2F;&#x2F;1.查询出商品库存信息</span><br><span class=\"line\">select quantity from items where id&#x3D;1 for update;</span><br><span class=\"line\">&#x2F;&#x2F;2.修改商品库存为2</span><br><span class=\"line\">update items set quantity&#x3D;2 where id &#x3D; 1;</span><br><span class=\"line\">&#x2F;&#x2F;3.提交事务</span><br><span class=\"line\">commit;</span><br></pre></td></tr></table></figure>\n<p>以上，在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。<br>如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p>\n<blockquote>\n<p>MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。</p>\n</blockquote>\n<h1 id=\"3-乐观锁\"><a href=\"#3-乐观锁\" class=\"headerlink\" title=\"3. 乐观锁\"></a>3. 乐观锁</h1><p>乐观锁（Optimistic Locking）是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p>\n<p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p>\n<p>￼乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。</p>\n<h2 id=\"3-1-乐观锁实现方式\"><a href=\"#3-1-乐观锁实现方式\" class=\"headerlink\" title=\"3.1 乐观锁实现方式\"></a>3.1 乐观锁实现方式</h2><p>使用乐观锁就不需要借助数据库的锁机制了。</p>\n<p>乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。</p>\n<p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>\n<p>比如前面的扣减库存问题，通过乐观锁可以实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;查询出商品库存信息，quantity &#x3D; 3</span><br><span class=\"line\">select quantity from items where id&#x3D;1</span><br><span class=\"line\">&#x2F;&#x2F;修改商品库存为2</span><br><span class=\"line\">update items set quantity&#x3D;2 where id&#x3D;1 and quantity &#x3D; 3;</span><br></pre></td></tr></table></figure>\n<p>以上，我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。</p>\n<h2 id=\"3-2-ABA问题\"><a href=\"#3-2-ABA问题\" class=\"headerlink\" title=\"3.2 ABA问题\"></a>3.2 ABA问题</h2><p>以上更新语句存在一个比较重要的问题，即传说中的ABA问题。</p>\n<p>比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</p>\n<p>￼有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段。改为以下方式即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;查询出商品信息，version &#x3D; 1</span><br><span class=\"line\">select version from items where id&#x3D;1</span><br><span class=\"line\">&#x2F;&#x2F;修改商品库存为2</span><br><span class=\"line\">update items set quantity&#x3D;2,version &#x3D; 3 where id&#x3D;1 and version &#x3D; 2;</span><br></pre></td></tr></table></figure>\n<p>乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。</p>\n<p>以上SQL其实还是有一定的问题的，就是一旦发上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。</p>\n<h2 id=\"3-3-高并发环境下锁粒度把控\"><a href=\"#3-3-高并发环境下锁粒度把控\" class=\"headerlink\" title=\"3.3 高并发环境下锁粒度把控\"></a>3.3 高并发环境下锁粒度把控</h2><p>对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。<br>有一条比较好的建议，可以减小乐观锁粒度，最大程度的提升吞吐率，提高并发能力！如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;修改商品库存</span><br><span class=\"line\">update item </span><br><span class=\"line\">set quantity&#x3D;quantity - 1 </span><br><span class=\"line\">where id &#x3D; 1 and quantity - 1 &gt; 0</span><br></pre></td></tr></table></figure>\n<p>以上SQL语句中，如果用户下单数为1，则通过quantity - 1 &gt; 0的方式进行乐观锁控制。<br>以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。</p>\n<p>怎样才算合理的加锁粒度呢？<br>其实卫生间并不只是用来上厕所的，还可以洗澡，洗手。这里就涉及到优化加锁粒度的问题。<br>你在卫生间里洗澡，其实别人也可以同时去里面洗手，只要做到隔离起来就可以，如果马桶，浴缸，洗漱台都是隔开相对独立的，实际上卫生间可以同时给三个人使用。<br>当然三个人做的事儿不能一样。这样就细化了加锁粒度，你在洗澡的时候只要关上浴室的门，别人还是可以进去洗手的。如果当初设计卫生间的时候没有将不同的功能区域划分隔离开，就不能实现卫生间资源的最大化使用。这就是设计架构的重要性。</p>\n<h1 id=\"4-如何选择\"><a href=\"#4-如何选择\" class=\"headerlink\" title=\"4. 如何选择\"></a>4. 如何选择</h1><p>在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。</p>\n<p>1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。 </p>\n<p>2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</p>\n<p>随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-前置知识\"><a href=\"#1-前置知识\" class=\"headerlink\" title=\"1. 前置知识\"></a>1. 前置知识</h1><h2 id=\"1-1-并行与并发\"><a href=\"#1-1-并行与并发\" class=\"headerlink\" title=\"1.1 并行与并发\"></a>1.1 并行与并发</h2><p>并发是指在一段时间内宏观上多个程序同时运行。<br>并行指的是同一个时刻，多个任务确实真的在同时运行。</p>","more":"<h2 id=\"1-2-读现象\"><a href=\"#1-2-读现象\" class=\"headerlink\" title=\"1.2 读现象\"></a>1.2 读现象</h2><blockquote>\n<p>通过在写的时候加锁，可以解决脏读。<br>通过在读的时候加锁，可以解决不可重复读。<br>通过串行化，可以解决幻读。</p>\n</blockquote>\n<h3 id=\"1-2-1-脏读\"><a href=\"#1-2-1-脏读\" class=\"headerlink\" title=\"1.2.1 脏读\"></a>1.2.1 脏读</h3><p>第一种读现象叫做脏读，顾名思义，就是读到了脏数据，即无效数据。</p>\n<p>脏读。是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交(commit)到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p>\n<p>为了解决脏读问题，所以要提高一点隔离性，我在修改代码的时候，不允许别人读代码。他只能读取到我提交后的代码。但是，提高了隔离性，并发性就降低了一些。</p>\n<h3 id=\"1-2-2-不可重复读\"><a href=\"#1-2-2-不可重复读\" class=\"headerlink\" title=\"1.2.2 不可重复读\"></a>1.2.2 不可重复读</h3><p>不可重复读。是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。<br>我在读读取某一数据的时候，你先不要修改它，这就是进一步提升了隔离性了。</p>\n<h3 id=\"1-2-3-幻读\"><a href=\"#1-2-3-幻读\" class=\"headerlink\" title=\"1.2.3 幻读\"></a>1.2.3 幻读</h3><p>幻读。指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。比如同一个事务A内第一次查询时候有n条记录，但是第二次同等条件下查询却又n+1条记录，这就好像产生了幻觉。<br>幻读是不可重复读的一种特殊场景。</p>\n<h3 id=\"1-2-4-不可重复读和幻读的区别\"><a href=\"#1-2-4-不可重复读和幻读的区别\" class=\"headerlink\" title=\"1.2.4 不可重复读和幻读的区别\"></a>1.2.4 不可重复读和幻读的区别</h3><p><strong>不可重复读重点在于update和delete，而幻读的重点在于insert</strong></p>\n<h2 id=\"1-3-并发控制\"><a href=\"#1-3-并发控制\" class=\"headerlink\" title=\"1.3 并发控制\"></a>1.3 并发控制</h2><p>当程序中可能出现并发的情况时，我们就需要通过一定的手段来保证在并发情况下数据的准确性，通过这种手段保证了当用户和其他用户一起操作时，所得到的结果和他单独操作时的希望的结果是一样的。<br>并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。<br>没有做好并发控制，就可能导致脏读、不可重复读和幻读等问题。</p>\n<p>实现并发控制的主要手段大致可以分为<strong>乐观并发控制</strong>和<strong>悲观并发控制</strong>两种。</p>\n<h1 id=\"2-悲观锁\"><a href=\"#2-悲观锁\" class=\"headerlink\" title=\"2. 悲观锁\"></a>2. 悲观锁</h1><p>当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。</p>\n<p>这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。</p>\n<p>之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。</p>\n<p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。</p>\n<h2 id=\"2-1-悲观锁实现方式\"><a href=\"#2-1-悲观锁实现方式\" class=\"headerlink\" title=\"2.1 悲观锁实现方式\"></a>2.1 悲观锁实现方式</h2><p>悲观锁的实现，往往依靠数据库提供的锁机制。在数据库中，悲观锁的流程如下：</p>\n<ul>\n<li>在对记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li>\n<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。</li>\n<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>\n<li>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li>\n</ul>\n<p>拿比较常用的MySql Innodb引擎举例，来说明一下在SQL中如何使用悲观锁。</p>\n<blockquote>\n<p>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;</p>\n</blockquote>\n<p>我们举一个简单的例子，如淘宝下单过程中扣减库存的需求说明一下如何使用悲观锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;0.开始事务</span><br><span class=\"line\">begin; </span><br><span class=\"line\">&#x2F;&#x2F;1.查询出商品库存信息</span><br><span class=\"line\">select quantity from items where id&#x3D;1 for update;</span><br><span class=\"line\">&#x2F;&#x2F;2.修改商品库存为2</span><br><span class=\"line\">update items set quantity&#x3D;2 where id &#x3D; 1;</span><br><span class=\"line\">&#x2F;&#x2F;3.提交事务</span><br><span class=\"line\">commit;</span><br></pre></td></tr></table></figure>\n<p>以上，在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。<br>如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p>\n<blockquote>\n<p>MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。</p>\n</blockquote>\n<h1 id=\"3-乐观锁\"><a href=\"#3-乐观锁\" class=\"headerlink\" title=\"3. 乐观锁\"></a>3. 乐观锁</h1><p>乐观锁（Optimistic Locking）是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p>\n<p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p>\n<p>￼乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。</p>\n<h2 id=\"3-1-乐观锁实现方式\"><a href=\"#3-1-乐观锁实现方式\" class=\"headerlink\" title=\"3.1 乐观锁实现方式\"></a>3.1 乐观锁实现方式</h2><p>使用乐观锁就不需要借助数据库的锁机制了。</p>\n<p>乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。</p>\n<p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>\n<p>比如前面的扣减库存问题，通过乐观锁可以实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;查询出商品库存信息，quantity &#x3D; 3</span><br><span class=\"line\">select quantity from items where id&#x3D;1</span><br><span class=\"line\">&#x2F;&#x2F;修改商品库存为2</span><br><span class=\"line\">update items set quantity&#x3D;2 where id&#x3D;1 and quantity &#x3D; 3;</span><br></pre></td></tr></table></figure>\n<p>以上，我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。</p>\n<h2 id=\"3-2-ABA问题\"><a href=\"#3-2-ABA问题\" class=\"headerlink\" title=\"3.2 ABA问题\"></a>3.2 ABA问题</h2><p>以上更新语句存在一个比较重要的问题，即传说中的ABA问题。</p>\n<p>比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</p>\n<p>￼有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段。改为以下方式即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;查询出商品信息，version &#x3D; 1</span><br><span class=\"line\">select version from items where id&#x3D;1</span><br><span class=\"line\">&#x2F;&#x2F;修改商品库存为2</span><br><span class=\"line\">update items set quantity&#x3D;2,version &#x3D; 3 where id&#x3D;1 and version &#x3D; 2;</span><br></pre></td></tr></table></figure>\n<p>乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。</p>\n<p>以上SQL其实还是有一定的问题的，就是一旦发上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。</p>\n<h2 id=\"3-3-高并发环境下锁粒度把控\"><a href=\"#3-3-高并发环境下锁粒度把控\" class=\"headerlink\" title=\"3.3 高并发环境下锁粒度把控\"></a>3.3 高并发环境下锁粒度把控</h2><p>对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。<br>有一条比较好的建议，可以减小乐观锁粒度，最大程度的提升吞吐率，提高并发能力！如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;修改商品库存</span><br><span class=\"line\">update item </span><br><span class=\"line\">set quantity&#x3D;quantity - 1 </span><br><span class=\"line\">where id &#x3D; 1 and quantity - 1 &gt; 0</span><br></pre></td></tr></table></figure>\n<p>以上SQL语句中，如果用户下单数为1，则通过quantity - 1 &gt; 0的方式进行乐观锁控制。<br>以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。</p>\n<p>怎样才算合理的加锁粒度呢？<br>其实卫生间并不只是用来上厕所的，还可以洗澡，洗手。这里就涉及到优化加锁粒度的问题。<br>你在卫生间里洗澡，其实别人也可以同时去里面洗手，只要做到隔离起来就可以，如果马桶，浴缸，洗漱台都是隔开相对独立的，实际上卫生间可以同时给三个人使用。<br>当然三个人做的事儿不能一样。这样就细化了加锁粒度，你在洗澡的时候只要关上浴室的门，别人还是可以进去洗手的。如果当初设计卫生间的时候没有将不同的功能区域划分隔离开，就不能实现卫生间资源的最大化使用。这就是设计架构的重要性。</p>\n<h1 id=\"4-如何选择\"><a href=\"#4-如何选择\" class=\"headerlink\" title=\"4. 如何选择\"></a>4. 如何选择</h1><p>在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。</p>\n<p>1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。 </p>\n<p>2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</p>\n<p>随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。</p>"},{"title":"常用Shell命令","date":"2019-08-04T16:00:00.000Z","updated":"2019-08-12T16:00:00.000Z","_content":"\n# 1. 获取指定第几个正则匹配结果\n\n<!-- more -->\n\nMAC环境下不支持 r 参数\n`sed -nr \"s/$RLV_REG/\\2/p\" filename`\n可使用 -E 代替\n`sed -n -E \"s/$RLV_REG/\\2/p\" filename`\n\n# 2. 正则修改文件内容\n\nMAC环境下的bash不支持 `sed -i \"REG\" filename` 来直接修改文件内容。\n`-i tmp` 在MAC下指添加备份后缀 `.tmp`，作用与下文行2相同。\n\n通用解决方案：\n```\n# 把结果保存到新的文件，再把文件重命名来覆盖原文件\nsed 's/\\\"API_VERSION\\\"/'${tagName}'/' filename > filename.tmp\nmv filename.tmp filename\n```\n\n# 3. 代理\n永久代理：\nAdd this script to ~/.bash_profile.\n```\nexport http_proxy=socks5://127.0.0.1:1080\nexport https_proxy=socks5://127.0.0.1:1080\n```\n只对当前窗口有效：\n```\nexport ALL_PROXY=socks5://127.0.0.1:1086\n```\n","source":"_posts/2019/常用Shell命令.md","raw":"---\ntitle: 常用Shell命令\ndate: 2019-08-05\nupdated: 2019-08-13\ntags: Shell\n---\n\n# 1. 获取指定第几个正则匹配结果\n\n<!-- more -->\n\nMAC环境下不支持 r 参数\n`sed -nr \"s/$RLV_REG/\\2/p\" filename`\n可使用 -E 代替\n`sed -n -E \"s/$RLV_REG/\\2/p\" filename`\n\n# 2. 正则修改文件内容\n\nMAC环境下的bash不支持 `sed -i \"REG\" filename` 来直接修改文件内容。\n`-i tmp` 在MAC下指添加备份后缀 `.tmp`，作用与下文行2相同。\n\n通用解决方案：\n```\n# 把结果保存到新的文件，再把文件重命名来覆盖原文件\nsed 's/\\\"API_VERSION\\\"/'${tagName}'/' filename > filename.tmp\nmv filename.tmp filename\n```\n\n# 3. 代理\n永久代理：\nAdd this script to ~/.bash_profile.\n```\nexport http_proxy=socks5://127.0.0.1:1080\nexport https_proxy=socks5://127.0.0.1:1080\n```\n只对当前窗口有效：\n```\nexport ALL_PROXY=socks5://127.0.0.1:1086\n```\n","slug":"2019-常用Shell命令","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrk4000o2ykueii55u0b","content":"<h1 id=\"1-获取指定第几个正则匹配结果\"><a href=\"#1-获取指定第几个正则匹配结果\" class=\"headerlink\" title=\"1. 获取指定第几个正则匹配结果\"></a>1. 获取指定第几个正则匹配结果</h1><a id=\"more\"></a>\n\n<p>MAC环境下不支持 r 参数<br><code>sed -nr &quot;s/$RLV_REG/\\2/p&quot; filename</code><br>可使用 -E 代替<br><code>sed -n -E &quot;s/$RLV_REG/\\2/p&quot; filename</code></p>\n<h1 id=\"2-正则修改文件内容\"><a href=\"#2-正则修改文件内容\" class=\"headerlink\" title=\"2. 正则修改文件内容\"></a>2. 正则修改文件内容</h1><p>MAC环境下的bash不支持 <code>sed -i &quot;REG&quot; filename</code> 来直接修改文件内容。<br><code>-i tmp</code> 在MAC下指添加备份后缀 <code>.tmp</code>，作用与下文行2相同。</p>\n<p>通用解决方案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 把结果保存到新的文件，再把文件重命名来覆盖原文件</span><br><span class=\"line\">sed &#39;s&#x2F;\\&quot;API_VERSION\\&quot;&#x2F;&#39;$&#123;tagName&#125;&#39;&#x2F;&#39; filename &gt; filename.tmp</span><br><span class=\"line\">mv filename.tmp filename</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-代理\"><a href=\"#3-代理\" class=\"headerlink\" title=\"3. 代理\"></a>3. 代理</h1><p>永久代理：<br>Add this script to ~/.bash_profile.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export http_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class=\"line\">export https_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>\n<p>只对当前窗口有效：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1086</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-获取指定第几个正则匹配结果\"><a href=\"#1-获取指定第几个正则匹配结果\" class=\"headerlink\" title=\"1. 获取指定第几个正则匹配结果\"></a>1. 获取指定第几个正则匹配结果</h1>","more":"<p>MAC环境下不支持 r 参数<br><code>sed -nr &quot;s/$RLV_REG/\\2/p&quot; filename</code><br>可使用 -E 代替<br><code>sed -n -E &quot;s/$RLV_REG/\\2/p&quot; filename</code></p>\n<h1 id=\"2-正则修改文件内容\"><a href=\"#2-正则修改文件内容\" class=\"headerlink\" title=\"2. 正则修改文件内容\"></a>2. 正则修改文件内容</h1><p>MAC环境下的bash不支持 <code>sed -i &quot;REG&quot; filename</code> 来直接修改文件内容。<br><code>-i tmp</code> 在MAC下指添加备份后缀 <code>.tmp</code>，作用与下文行2相同。</p>\n<p>通用解决方案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 把结果保存到新的文件，再把文件重命名来覆盖原文件</span><br><span class=\"line\">sed &#39;s&#x2F;\\&quot;API_VERSION\\&quot;&#x2F;&#39;$&#123;tagName&#125;&#39;&#x2F;&#39; filename &gt; filename.tmp</span><br><span class=\"line\">mv filename.tmp filename</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-代理\"><a href=\"#3-代理\" class=\"headerlink\" title=\"3. 代理\"></a>3. 代理</h1><p>永久代理：<br>Add this script to ~/.bash_profile.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export http_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class=\"line\">export https_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>\n<p>只对当前窗口有效：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1086</span><br></pre></td></tr></table></figure>"},{"title":"如何从MySQL生成数据库的结构表","date":"2019-05-05T14:44:17.000Z","updated":"2019-05-05T14:44:17.000Z","_content":"写论文、作业的时候常常需要做一张类似这样的表格，来说明数据库表的结构：\n\n| 列名 | 数据类型 | 约束 | 备注 |\n| :------: | :------: | :------: | :------: |\n| id | int | PRI | 自增主键 |\n| name | varchar(10) |  | 名字 |\n\n表数少时可以一个个慢慢写，当涉及到表过多时，这就是个耗时耗力的苦差事了。那么有什么办法直接生成这样的设计表吗？\n<!-- more -->\n答案是有的。\n在MySQL中，数据库每一个表中的每一列都会在`information_schema.columns`表中对应一行，也就是说，这个表记录了MySQL中每个库、表的结构信息，我们可以通过对它的查询，来生成数据库结构表。\n\n`informaiton_schema.columns`中共有22个列，下面是常用的列名：\n\n1. `table_catalog`：不管是table | view 这个列的值总是def\n2. `table_schema`：表 | 视图所在的数据库名\n3. `table_name`：表名 | 视图名\n4. `column_name`：列名\n5. `column_default`：列的默认值\n6. `is_nullable`：是否可以取空值\n7. `data_type`：列的数据类型\n8. `character_maximum_length`：列的最大长度（这列只有在数据类型为 char | varchar 时才有意义）\n9. `column_type`：列类型（这个类型包含了`column_name`和`character_maximum_length`的信息）\n10. `column_key`：列上的索引类型（主键-->PRI | 唯一索引 -->UNI | 一般索引 -->MUL）\n\n下面是查询的demo：\n```\nSET @rownum = 0;\n\nSELECT\n\t(@rownum :=@rownum + 1) 序号,\n\tCOLUMN_NAME 列名,\n\tCOLUMN_TYPE 数据类型,\n\tcolumn_key 约束,\n\tIS_NULLABLE 可否为空,\n\tCOLUMN_COMMENT 备注\nFROM\n\tINFORMATION_SCHEMA. COLUMNS\nWHERE\n\ttable_schema = '数据库名'\nAND table_name = '表名'\n-- 用自己的库名表名替换''内容\nORDER BY\n\tcolumn_key DESC\n```\n用数据库图形工具（如Navicat）查询后选中所有查询结果，复制出字段名和数据，到表格中粘贴即可。","source":"_posts/2019/如何从MySQL生成数据库的结构表.md","raw":"---\ntitle: 如何从MySQL生成数据库的结构表\ndate: 2019-05-05 22:44:17\nupdated: 2019-05-05 22:44:17\ntags: 数据库\n---\n写论文、作业的时候常常需要做一张类似这样的表格，来说明数据库表的结构：\n\n| 列名 | 数据类型 | 约束 | 备注 |\n| :------: | :------: | :------: | :------: |\n| id | int | PRI | 自增主键 |\n| name | varchar(10) |  | 名字 |\n\n表数少时可以一个个慢慢写，当涉及到表过多时，这就是个耗时耗力的苦差事了。那么有什么办法直接生成这样的设计表吗？\n<!-- more -->\n答案是有的。\n在MySQL中，数据库每一个表中的每一列都会在`information_schema.columns`表中对应一行，也就是说，这个表记录了MySQL中每个库、表的结构信息，我们可以通过对它的查询，来生成数据库结构表。\n\n`informaiton_schema.columns`中共有22个列，下面是常用的列名：\n\n1. `table_catalog`：不管是table | view 这个列的值总是def\n2. `table_schema`：表 | 视图所在的数据库名\n3. `table_name`：表名 | 视图名\n4. `column_name`：列名\n5. `column_default`：列的默认值\n6. `is_nullable`：是否可以取空值\n7. `data_type`：列的数据类型\n8. `character_maximum_length`：列的最大长度（这列只有在数据类型为 char | varchar 时才有意义）\n9. `column_type`：列类型（这个类型包含了`column_name`和`character_maximum_length`的信息）\n10. `column_key`：列上的索引类型（主键-->PRI | 唯一索引 -->UNI | 一般索引 -->MUL）\n\n下面是查询的demo：\n```\nSET @rownum = 0;\n\nSELECT\n\t(@rownum :=@rownum + 1) 序号,\n\tCOLUMN_NAME 列名,\n\tCOLUMN_TYPE 数据类型,\n\tcolumn_key 约束,\n\tIS_NULLABLE 可否为空,\n\tCOLUMN_COMMENT 备注\nFROM\n\tINFORMATION_SCHEMA. COLUMNS\nWHERE\n\ttable_schema = '数据库名'\nAND table_name = '表名'\n-- 用自己的库名表名替换''内容\nORDER BY\n\tcolumn_key DESC\n```\n用数据库图形工具（如Navicat）查询后选中所有查询结果，复制出字段名和数据，到表格中粘贴即可。","slug":"2019-如何从MySQL生成数据库的结构表","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrk5000q2yku23cghni0","content":"<p>写论文、作业的时候常常需要做一张类似这样的表格，来说明数据库表的结构：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">列名</th>\n<th align=\"center\">数据类型</th>\n<th align=\"center\">约束</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">id</td>\n<td align=\"center\">int</td>\n<td align=\"center\">PRI</td>\n<td align=\"center\">自增主键</td>\n</tr>\n<tr>\n<td align=\"center\">name</td>\n<td align=\"center\">varchar(10)</td>\n<td align=\"center\"></td>\n<td align=\"center\">名字</td>\n</tr>\n</tbody></table>\n<p>表数少时可以一个个慢慢写，当涉及到表过多时，这就是个耗时耗力的苦差事了。那么有什么办法直接生成这样的设计表吗？</p>\n<a id=\"more\"></a>\n<p>答案是有的。<br>在MySQL中，数据库每一个表中的每一列都会在<code>information_schema.columns</code>表中对应一行，也就是说，这个表记录了MySQL中每个库、表的结构信息，我们可以通过对它的查询，来生成数据库结构表。</p>\n<p><code>informaiton_schema.columns</code>中共有22个列，下面是常用的列名：</p>\n<ol>\n<li><code>table_catalog</code>：不管是table | view 这个列的值总是def</li>\n<li><code>table_schema</code>：表 | 视图所在的数据库名</li>\n<li><code>table_name</code>：表名 | 视图名</li>\n<li><code>column_name</code>：列名</li>\n<li><code>column_default</code>：列的默认值</li>\n<li><code>is_nullable</code>：是否可以取空值</li>\n<li><code>data_type</code>：列的数据类型</li>\n<li><code>character_maximum_length</code>：列的最大长度（这列只有在数据类型为 char | varchar 时才有意义）</li>\n<li><code>column_type</code>：列类型（这个类型包含了<code>column_name</code>和<code>character_maximum_length</code>的信息）</li>\n<li><code>column_key</code>：列上的索引类型（主键–&gt;PRI | 唯一索引 –&gt;UNI | 一般索引 –&gt;MUL）</li>\n</ol>\n<p>下面是查询的demo：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET @rownum &#x3D; 0;</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT</span><br><span class=\"line\">\t(@rownum :&#x3D;@rownum + 1) 序号,</span><br><span class=\"line\">\tCOLUMN_NAME 列名,</span><br><span class=\"line\">\tCOLUMN_TYPE 数据类型,</span><br><span class=\"line\">\tcolumn_key 约束,</span><br><span class=\"line\">\tIS_NULLABLE 可否为空,</span><br><span class=\"line\">\tCOLUMN_COMMENT 备注</span><br><span class=\"line\">FROM</span><br><span class=\"line\">\tINFORMATION_SCHEMA. COLUMNS</span><br><span class=\"line\">WHERE</span><br><span class=\"line\">\ttable_schema &#x3D; &#39;数据库名&#39;</span><br><span class=\"line\">AND table_name &#x3D; &#39;表名&#39;</span><br><span class=\"line\">-- 用自己的库名表名替换&#39;&#39;内容</span><br><span class=\"line\">ORDER BY</span><br><span class=\"line\">\tcolumn_key DESC</span><br></pre></td></tr></table></figure>\n<p>用数据库图形工具（如Navicat）查询后选中所有查询结果，复制出字段名和数据，到表格中粘贴即可。</p>\n","site":{"data":{}},"excerpt":"<p>写论文、作业的时候常常需要做一张类似这样的表格，来说明数据库表的结构：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">列名</th>\n<th align=\"center\">数据类型</th>\n<th align=\"center\">约束</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">id</td>\n<td align=\"center\">int</td>\n<td align=\"center\">PRI</td>\n<td align=\"center\">自增主键</td>\n</tr>\n<tr>\n<td align=\"center\">name</td>\n<td align=\"center\">varchar(10)</td>\n<td align=\"center\"></td>\n<td align=\"center\">名字</td>\n</tr>\n</tbody></table>\n<p>表数少时可以一个个慢慢写，当涉及到表过多时，这就是个耗时耗力的苦差事了。那么有什么办法直接生成这样的设计表吗？</p>","more":"<p>答案是有的。<br>在MySQL中，数据库每一个表中的每一列都会在<code>information_schema.columns</code>表中对应一行，也就是说，这个表记录了MySQL中每个库、表的结构信息，我们可以通过对它的查询，来生成数据库结构表。</p>\n<p><code>informaiton_schema.columns</code>中共有22个列，下面是常用的列名：</p>\n<ol>\n<li><code>table_catalog</code>：不管是table | view 这个列的值总是def</li>\n<li><code>table_schema</code>：表 | 视图所在的数据库名</li>\n<li><code>table_name</code>：表名 | 视图名</li>\n<li><code>column_name</code>：列名</li>\n<li><code>column_default</code>：列的默认值</li>\n<li><code>is_nullable</code>：是否可以取空值</li>\n<li><code>data_type</code>：列的数据类型</li>\n<li><code>character_maximum_length</code>：列的最大长度（这列只有在数据类型为 char | varchar 时才有意义）</li>\n<li><code>column_type</code>：列类型（这个类型包含了<code>column_name</code>和<code>character_maximum_length</code>的信息）</li>\n<li><code>column_key</code>：列上的索引类型（主键–&gt;PRI | 唯一索引 –&gt;UNI | 一般索引 –&gt;MUL）</li>\n</ol>\n<p>下面是查询的demo：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET @rownum &#x3D; 0;</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT</span><br><span class=\"line\">\t(@rownum :&#x3D;@rownum + 1) 序号,</span><br><span class=\"line\">\tCOLUMN_NAME 列名,</span><br><span class=\"line\">\tCOLUMN_TYPE 数据类型,</span><br><span class=\"line\">\tcolumn_key 约束,</span><br><span class=\"line\">\tIS_NULLABLE 可否为空,</span><br><span class=\"line\">\tCOLUMN_COMMENT 备注</span><br><span class=\"line\">FROM</span><br><span class=\"line\">\tINFORMATION_SCHEMA. COLUMNS</span><br><span class=\"line\">WHERE</span><br><span class=\"line\">\ttable_schema &#x3D; &#39;数据库名&#39;</span><br><span class=\"line\">AND table_name &#x3D; &#39;表名&#39;</span><br><span class=\"line\">-- 用自己的库名表名替换&#39;&#39;内容</span><br><span class=\"line\">ORDER BY</span><br><span class=\"line\">\tcolumn_key DESC</span><br></pre></td></tr></table></figure>\n<p>用数据库图形工具（如Navicat）查询后选中所有查询结果，复制出字段名和数据，到表格中粘贴即可。</p>"},{"title":"常用MySQL优化","date":"2019-03-25T17:13:59.000Z","updated":"2019-03-25T17:13:59.000Z","_content":"> 作者：zhangqh\n> segmentfault.com/a/1190000012155267\n\n本文总结了19条关于Mysql的优化方案，本文的优化方案都是基于 “ Mysql-索引-BTree类型 ” 的。希望对你有帮助。\n\n<!-- more -->\n\n# 一、EXPLAIN\n\n做MySQL优化，我们要善用 EXPLAIN 查看SQL执行计划。\n\n下面来个简单的示例，标注(1,2,3,4,5)我们要重点关注的数据\n\n{% asset_img 1.webp %}\n\n1. type列，连接类型。一个好的sql语句至少要达到range级别。杜绝出现all级别\n2. key列，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式\n3. key_len列，索引长度\n4. rows列，扫描行数。该值是个预估值\n5. extra列，详细说明。注意常见的不太友好的值有：Using filesort, Using temporary\n\n# 二、SQL语句中IN包含的值不应过多\n\nMySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：`select id from table_name where num in(1,2,3)` 对于连续的数值，能用 between 就不要用 in 了；再或者使用连接来替换。\n\n# 三、SELECT语句务必指明字段名称\n\nSELECT *增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。\n\n# 四、当只需要一条数据的时候，使用limit 1\n\n这是为了使EXPLAIN中type列达到const类型\n\n# 五、如果排序字段没有用到索引，就尽量少排序\n\n# 六、如果限制条件中其他字段没有索引，尽量少用or\n\nor两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用 union all 或者是union(必要的时候)的方式来代替“or”会得到更好的效果\n\n# 七、尽量用union all代替union\n\nunion和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。**当然，union all的前提条件是两个结果集没有重复数据。**\n\n# 八、不使用ORDER BY RAND()\n\n```\nselect id from `table_name` \norder by rand() limit 1000;\n```\n上面的sql语句，可优化为\n```\nselect id from `table_name` t1 join (select rand() * (select max(id) \nfrom `table_name`) asnid) t2 on t1.id > t2.nid limit 1000;\n```\n\n# 九、区分 in 和 exists， not in 和 not exists\n\n```\nselect * from 表A \nwhere id in (select id from 表B)\n```\n上面sql语句相当于\n```\nselect * from 表A \nwhere exists(select * from 表B where 表B.id=表A.id)\n```\n区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以**IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。**\n关于not in和not exists，推荐使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。**如何高效的写出一个替代not exists的sql语句？**\n\n原sql语句\n\n```\nselect colname … from A表 \nwhere a.id not in (select b.id from B表)\n```\n高效的sql语句\n\n```\nselect colname … from A表 Left join B表 on \nwhere a.id = b.id where b.id is null\n```\n取出的结果集如下图表示，A表不在B表中的数据\n{% asset_img 2.webp %}\n\n# 十、使用合理的分页方式以提高分页的效率\n\n```\nselect id,name \nfrom table_name limit 866613, 20\n```\n使用上述sql语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用limit分页查询会越来越慢。\n\n优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。sql可以采用如下的写法：\n```\nselect id,name from table_name \nwhere id> 866612 limit 20\n```\n# 十一、分段查询\n\n在一些用户选择页面中，可能一些用户选择的时间范围过大，造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段进行查询，循环遍历，将结果合并处理进行展示。\n\n如下图这个sql语句，扫描的行数成百万级以上的时候就可以使用分段查询\n{% asset_img 3.webp %}\n\n# 十二、避免在 where 子句中对字段进行 null 值判断\n\n对于null的判断会导致引擎放弃使用索引而进行全表扫描。\n\n# 十三、不建议使用%前缀模糊查询\n\n例如LIKE “%name”或者LIKE “%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。\n\n**那如何查询%name%？**\n\n如下图所示，虽然给secret字段添加了索引，但在explain结果果并没有使用\n{% asset_img 4.webp %}\n那么如何解决这个问题呢，答案：**使用全文索引**\n\n在我们查询中经常会用到select id,fnum,fdst from table_name where user_name like '%zhangsan%'; 。这样的语句，普通索引是无法满足查询需求的。庆幸的是在MySQL中，有全文索引来帮助我们。\n\n创建全文索引的sql语法是：\n```\nALTER TABLE `table_name` ADD FULLTEXT \nINDEX `idx_user_name` (`user_name`);\n```\n使用全文索引的sql语句是：\n```\nselect id,fnum,fdst from table_name \nwhere match(user_name) against('zhangsan' in booleanmode);\n```\n**注意：在需要创建全文索引之前，请联系DBA确定能否创建。同时需要注意的是查询语句的写法与普通索引的区别**\n\n# 十四、避免在where子句中对字段进行表达式操作\n\n比如\n\n```\nselect user_id,user_project from table_name \nwhere age*2=36;\n```\n中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成\n\n```\nselect user_id,user_project from table_name \nwhere age=36/2;\n```\n# 十五、避免隐式类型转换\n\nwhere 子句中出现 column 字段的类型和传入的参数类型不一致的时候发生的类型转换，建议先确定where中的参数类型\n{% asset_img 5.webp %}\n\n# 十六、对于联合索引来说，要遵守最左前缀法则\n\n举列来说索引含有字段id,name,school，可以直接用id字段，也可以id,name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面\n\n# 十七、必要时可以使用force index来强制查询走某个索引\n\n有的时候MySQL优化器采取它认为合适的索引来检索sql语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用force index来强制优化器使用我们制定的索引。\n\n# 十八、注意范围查询语句\n\n对于联合索引来说，如果存在范围查询，比如between,>,<等条件时，会造成后面的索引字段失效。\n\n# 十九、关于JOIN优化\n{% asset_img 6.webp %}\nLEFT JOIN A表为驱动表\n\nINNER JOIN MySQL会自动找出那个数据少的表作用驱动表\n\nRIGHT JOIN B表为驱动表\n\n**注意：MySQL中没有full join，可以用以下方式来解决**\n\n```\nselect * from A left join B on B.name = A.name \nwhere B.name is null\nunion all\nselect * from B;\n```\n**尽量使用inner join，避免left join**\n\n参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是left join在驱动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表。\n\n**合理利用索引**\n\n被驱动表的索引字段作为on的限制字段。\n\n**利用小表去驱动大表**\n{% asset_img 7.webp %}\n从原理图能够直观的看出如果能够减少驱动表的话，减少嵌套循环中的循环次数，以减少 IO总量及CPU运算的次数。\n\n**巧用STRAIGHT_JOIN**\n\ninner join是由mysql选择驱动表，但是有些特殊情况需要选择另个表作为驱动表，比如有group by、order by等「Using filesort」、「Using temporary」时。STRAIGHT_JOIN来强制连接顺序，在STRAIGHT_JOIN左边的表名就是驱动表，右边则是被驱动表。**在使用STRAIGHT_JOIN有个前提条件是该查询是内连接，也就是inner join。其他链接不推荐使用STRAIGHT_JOIN，否则可能造成查询结果不准确。**\n{% asset_img 8.webp %}\n这个方式有时可能减少3倍的时间。\n\n这里只列举了上述优化方案，当然还有其他的优化方式，大家可以去摸索尝试，感谢关注。\n\n\n\n\n\n\n\n\n\n","source":"_posts/2019/常用MySQL优化.md","raw":"---\ntitle: 常用MySQL优化\ndate: 2019-03-26 01:13:59\nupdated: 2019-03-26 01:13:59\ntags: 数据库\n---\n> 作者：zhangqh\n> segmentfault.com/a/1190000012155267\n\n本文总结了19条关于Mysql的优化方案，本文的优化方案都是基于 “ Mysql-索引-BTree类型 ” 的。希望对你有帮助。\n\n<!-- more -->\n\n# 一、EXPLAIN\n\n做MySQL优化，我们要善用 EXPLAIN 查看SQL执行计划。\n\n下面来个简单的示例，标注(1,2,3,4,5)我们要重点关注的数据\n\n{% asset_img 1.webp %}\n\n1. type列，连接类型。一个好的sql语句至少要达到range级别。杜绝出现all级别\n2. key列，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式\n3. key_len列，索引长度\n4. rows列，扫描行数。该值是个预估值\n5. extra列，详细说明。注意常见的不太友好的值有：Using filesort, Using temporary\n\n# 二、SQL语句中IN包含的值不应过多\n\nMySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：`select id from table_name where num in(1,2,3)` 对于连续的数值，能用 between 就不要用 in 了；再或者使用连接来替换。\n\n# 三、SELECT语句务必指明字段名称\n\nSELECT *增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。\n\n# 四、当只需要一条数据的时候，使用limit 1\n\n这是为了使EXPLAIN中type列达到const类型\n\n# 五、如果排序字段没有用到索引，就尽量少排序\n\n# 六、如果限制条件中其他字段没有索引，尽量少用or\n\nor两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用 union all 或者是union(必要的时候)的方式来代替“or”会得到更好的效果\n\n# 七、尽量用union all代替union\n\nunion和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。**当然，union all的前提条件是两个结果集没有重复数据。**\n\n# 八、不使用ORDER BY RAND()\n\n```\nselect id from `table_name` \norder by rand() limit 1000;\n```\n上面的sql语句，可优化为\n```\nselect id from `table_name` t1 join (select rand() * (select max(id) \nfrom `table_name`) asnid) t2 on t1.id > t2.nid limit 1000;\n```\n\n# 九、区分 in 和 exists， not in 和 not exists\n\n```\nselect * from 表A \nwhere id in (select id from 表B)\n```\n上面sql语句相当于\n```\nselect * from 表A \nwhere exists(select * from 表B where 表B.id=表A.id)\n```\n区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以**IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。**\n关于not in和not exists，推荐使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。**如何高效的写出一个替代not exists的sql语句？**\n\n原sql语句\n\n```\nselect colname … from A表 \nwhere a.id not in (select b.id from B表)\n```\n高效的sql语句\n\n```\nselect colname … from A表 Left join B表 on \nwhere a.id = b.id where b.id is null\n```\n取出的结果集如下图表示，A表不在B表中的数据\n{% asset_img 2.webp %}\n\n# 十、使用合理的分页方式以提高分页的效率\n\n```\nselect id,name \nfrom table_name limit 866613, 20\n```\n使用上述sql语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用limit分页查询会越来越慢。\n\n优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。sql可以采用如下的写法：\n```\nselect id,name from table_name \nwhere id> 866612 limit 20\n```\n# 十一、分段查询\n\n在一些用户选择页面中，可能一些用户选择的时间范围过大，造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段进行查询，循环遍历，将结果合并处理进行展示。\n\n如下图这个sql语句，扫描的行数成百万级以上的时候就可以使用分段查询\n{% asset_img 3.webp %}\n\n# 十二、避免在 where 子句中对字段进行 null 值判断\n\n对于null的判断会导致引擎放弃使用索引而进行全表扫描。\n\n# 十三、不建议使用%前缀模糊查询\n\n例如LIKE “%name”或者LIKE “%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。\n\n**那如何查询%name%？**\n\n如下图所示，虽然给secret字段添加了索引，但在explain结果果并没有使用\n{% asset_img 4.webp %}\n那么如何解决这个问题呢，答案：**使用全文索引**\n\n在我们查询中经常会用到select id,fnum,fdst from table_name where user_name like '%zhangsan%'; 。这样的语句，普通索引是无法满足查询需求的。庆幸的是在MySQL中，有全文索引来帮助我们。\n\n创建全文索引的sql语法是：\n```\nALTER TABLE `table_name` ADD FULLTEXT \nINDEX `idx_user_name` (`user_name`);\n```\n使用全文索引的sql语句是：\n```\nselect id,fnum,fdst from table_name \nwhere match(user_name) against('zhangsan' in booleanmode);\n```\n**注意：在需要创建全文索引之前，请联系DBA确定能否创建。同时需要注意的是查询语句的写法与普通索引的区别**\n\n# 十四、避免在where子句中对字段进行表达式操作\n\n比如\n\n```\nselect user_id,user_project from table_name \nwhere age*2=36;\n```\n中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成\n\n```\nselect user_id,user_project from table_name \nwhere age=36/2;\n```\n# 十五、避免隐式类型转换\n\nwhere 子句中出现 column 字段的类型和传入的参数类型不一致的时候发生的类型转换，建议先确定where中的参数类型\n{% asset_img 5.webp %}\n\n# 十六、对于联合索引来说，要遵守最左前缀法则\n\n举列来说索引含有字段id,name,school，可以直接用id字段，也可以id,name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面\n\n# 十七、必要时可以使用force index来强制查询走某个索引\n\n有的时候MySQL优化器采取它认为合适的索引来检索sql语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用force index来强制优化器使用我们制定的索引。\n\n# 十八、注意范围查询语句\n\n对于联合索引来说，如果存在范围查询，比如between,>,<等条件时，会造成后面的索引字段失效。\n\n# 十九、关于JOIN优化\n{% asset_img 6.webp %}\nLEFT JOIN A表为驱动表\n\nINNER JOIN MySQL会自动找出那个数据少的表作用驱动表\n\nRIGHT JOIN B表为驱动表\n\n**注意：MySQL中没有full join，可以用以下方式来解决**\n\n```\nselect * from A left join B on B.name = A.name \nwhere B.name is null\nunion all\nselect * from B;\n```\n**尽量使用inner join，避免left join**\n\n参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是left join在驱动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表。\n\n**合理利用索引**\n\n被驱动表的索引字段作为on的限制字段。\n\n**利用小表去驱动大表**\n{% asset_img 7.webp %}\n从原理图能够直观的看出如果能够减少驱动表的话，减少嵌套循环中的循环次数，以减少 IO总量及CPU运算的次数。\n\n**巧用STRAIGHT_JOIN**\n\ninner join是由mysql选择驱动表，但是有些特殊情况需要选择另个表作为驱动表，比如有group by、order by等「Using filesort」、「Using temporary」时。STRAIGHT_JOIN来强制连接顺序，在STRAIGHT_JOIN左边的表名就是驱动表，右边则是被驱动表。**在使用STRAIGHT_JOIN有个前提条件是该查询是内连接，也就是inner join。其他链接不推荐使用STRAIGHT_JOIN，否则可能造成查询结果不准确。**\n{% asset_img 8.webp %}\n这个方式有时可能减少3倍的时间。\n\n这里只列举了上述优化方案，当然还有其他的优化方式，大家可以去摸索尝试，感谢关注。\n\n\n\n\n\n\n\n\n\n","slug":"2019-常用MySQL优化","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrk6000s2ykuhvtv5xyx","content":"<blockquote>\n<p>作者：zhangqh<br>segmentfault.com/a/1190000012155267</p>\n</blockquote>\n<p>本文总结了19条关于Mysql的优化方案，本文的优化方案都是基于 “ Mysql-索引-BTree类型 ” 的。希望对你有帮助。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"一、EXPLAIN\"><a href=\"#一、EXPLAIN\" class=\"headerlink\" title=\"一、EXPLAIN\"></a>一、EXPLAIN</h1><p>做MySQL优化，我们要善用 EXPLAIN 查看SQL执行计划。</p>\n<p>下面来个简单的示例，标注(1,2,3,4,5)我们要重点关注的数据</p>\n<img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/1.webp\" class=\"\">\n\n<ol>\n<li>type列，连接类型。一个好的sql语句至少要达到range级别。杜绝出现all级别</li>\n<li>key列，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式</li>\n<li>key_len列，索引长度</li>\n<li>rows列，扫描行数。该值是个预估值</li>\n<li>extra列，详细说明。注意常见的不太友好的值有：Using filesort, Using temporary</li>\n</ol>\n<h1 id=\"二、SQL语句中IN包含的值不应过多\"><a href=\"#二、SQL语句中IN包含的值不应过多\" class=\"headerlink\" title=\"二、SQL语句中IN包含的值不应过多\"></a>二、SQL语句中IN包含的值不应过多</h1><p>MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：<code>select id from table_name where num in(1,2,3)</code> 对于连续的数值，能用 between 就不要用 in 了；再或者使用连接来替换。</p>\n<h1 id=\"三、SELECT语句务必指明字段名称\"><a href=\"#三、SELECT语句务必指明字段名称\" class=\"headerlink\" title=\"三、SELECT语句务必指明字段名称\"></a>三、SELECT语句务必指明字段名称</h1><p>SELECT *增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。</p>\n<h1 id=\"四、当只需要一条数据的时候，使用limit-1\"><a href=\"#四、当只需要一条数据的时候，使用limit-1\" class=\"headerlink\" title=\"四、当只需要一条数据的时候，使用limit 1\"></a>四、当只需要一条数据的时候，使用limit 1</h1><p>这是为了使EXPLAIN中type列达到const类型</p>\n<h1 id=\"五、如果排序字段没有用到索引，就尽量少排序\"><a href=\"#五、如果排序字段没有用到索引，就尽量少排序\" class=\"headerlink\" title=\"五、如果排序字段没有用到索引，就尽量少排序\"></a>五、如果排序字段没有用到索引，就尽量少排序</h1><h1 id=\"六、如果限制条件中其他字段没有索引，尽量少用or\"><a href=\"#六、如果限制条件中其他字段没有索引，尽量少用or\" class=\"headerlink\" title=\"六、如果限制条件中其他字段没有索引，尽量少用or\"></a>六、如果限制条件中其他字段没有索引，尽量少用or</h1><p>or两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用 union all 或者是union(必要的时候)的方式来代替“or”会得到更好的效果</p>\n<h1 id=\"七、尽量用union-all代替union\"><a href=\"#七、尽量用union-all代替union\" class=\"headerlink\" title=\"七、尽量用union all代替union\"></a>七、尽量用union all代替union</h1><p>union和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。<strong>当然，union all的前提条件是两个结果集没有重复数据。</strong></p>\n<h1 id=\"八、不使用ORDER-BY-RAND\"><a href=\"#八、不使用ORDER-BY-RAND\" class=\"headerlink\" title=\"八、不使用ORDER BY RAND()\"></a>八、不使用ORDER BY RAND()</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id from &#96;table_name&#96; </span><br><span class=\"line\">order by rand() limit 1000;</span><br></pre></td></tr></table></figure>\n<p>上面的sql语句，可优化为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id from &#96;table_name&#96; t1 join (select rand() * (select max(id) </span><br><span class=\"line\">from &#96;table_name&#96;) asnid) t2 on t1.id &gt; t2.nid limit 1000;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"九、区分-in-和-exists，-not-in-和-not-exists\"><a href=\"#九、区分-in-和-exists，-not-in-和-not-exists\" class=\"headerlink\" title=\"九、区分 in 和 exists， not in 和 not exists\"></a>九、区分 in 和 exists， not in 和 not exists</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from 表A </span><br><span class=\"line\">where id in (select id from 表B)</span><br></pre></td></tr></table></figure>\n<p>上面sql语句相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from 表A </span><br><span class=\"line\">where exists(select * from 表B where 表B.id&#x3D;表A.id)</span><br></pre></td></tr></table></figure>\n<p>区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以<strong>IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</strong><br>关于not in和not exists，推荐使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。<strong>如何高效的写出一个替代not exists的sql语句？</strong></p>\n<p>原sql语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select colname … from A表 </span><br><span class=\"line\">where a.id not in (select b.id from B表)</span><br></pre></td></tr></table></figure>\n<p>高效的sql语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select colname … from A表 Left join B表 on </span><br><span class=\"line\">where a.id &#x3D; b.id where b.id is null</span><br></pre></td></tr></table></figure>\n<p>取出的结果集如下图表示，A表不在B表中的数据</p>\n<img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/2.webp\" class=\"\">\n\n<h1 id=\"十、使用合理的分页方式以提高分页的效率\"><a href=\"#十、使用合理的分页方式以提高分页的效率\" class=\"headerlink\" title=\"十、使用合理的分页方式以提高分页的效率\"></a>十、使用合理的分页方式以提高分页的效率</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id,name </span><br><span class=\"line\">from table_name limit 866613, 20</span><br></pre></td></tr></table></figure>\n<p>使用上述sql语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用limit分页查询会越来越慢。</p>\n<p>优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。sql可以采用如下的写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id,name from table_name </span><br><span class=\"line\">where id&gt; 866612 limit 20</span><br></pre></td></tr></table></figure>\n<h1 id=\"十一、分段查询\"><a href=\"#十一、分段查询\" class=\"headerlink\" title=\"十一、分段查询\"></a>十一、分段查询</h1><p>在一些用户选择页面中，可能一些用户选择的时间范围过大，造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段进行查询，循环遍历，将结果合并处理进行展示。</p>\n<p>如下图这个sql语句，扫描的行数成百万级以上的时候就可以使用分段查询</p>\n<img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/3.webp\" class=\"\">\n\n<h1 id=\"十二、避免在-where-子句中对字段进行-null-值判断\"><a href=\"#十二、避免在-where-子句中对字段进行-null-值判断\" class=\"headerlink\" title=\"十二、避免在 where 子句中对字段进行 null 值判断\"></a>十二、避免在 where 子句中对字段进行 null 值判断</h1><p>对于null的判断会导致引擎放弃使用索引而进行全表扫描。</p>\n<h1 id=\"十三、不建议使用-前缀模糊查询\"><a href=\"#十三、不建议使用-前缀模糊查询\" class=\"headerlink\" title=\"十三、不建议使用%前缀模糊查询\"></a>十三、不建议使用%前缀模糊查询</h1><p>例如LIKE “%name”或者LIKE “%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。</p>\n<p><strong>那如何查询%name%？</strong></p>\n<p>如下图所示，虽然给secret字段添加了索引，但在explain结果果并没有使用</p>\n<img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/4.webp\" class=\"\">\n<p>那么如何解决这个问题呢，答案：<strong>使用全文索引</strong></p>\n<p>在我们查询中经常会用到select id,fnum,fdst from table_name where user_name like ‘%zhangsan%’; 。这样的语句，普通索引是无法满足查询需求的。庆幸的是在MySQL中，有全文索引来帮助我们。</p>\n<p>创建全文索引的sql语法是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE &#96;table_name&#96; ADD FULLTEXT </span><br><span class=\"line\">INDEX &#96;idx_user_name&#96; (&#96;user_name&#96;);</span><br></pre></td></tr></table></figure>\n<p>使用全文索引的sql语句是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id,fnum,fdst from table_name </span><br><span class=\"line\">where match(user_name) against(&#39;zhangsan&#39; in booleanmode);</span><br></pre></td></tr></table></figure>\n<p><strong>注意：在需要创建全文索引之前，请联系DBA确定能否创建。同时需要注意的是查询语句的写法与普通索引的区别</strong></p>\n<h1 id=\"十四、避免在where子句中对字段进行表达式操作\"><a href=\"#十四、避免在where子句中对字段进行表达式操作\" class=\"headerlink\" title=\"十四、避免在where子句中对字段进行表达式操作\"></a>十四、避免在where子句中对字段进行表达式操作</h1><p>比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select user_id,user_project from table_name </span><br><span class=\"line\">where age*2&#x3D;36;</span><br></pre></td></tr></table></figure>\n<p>中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select user_id,user_project from table_name </span><br><span class=\"line\">where age&#x3D;36&#x2F;2;</span><br></pre></td></tr></table></figure>\n<h1 id=\"十五、避免隐式类型转换\"><a href=\"#十五、避免隐式类型转换\" class=\"headerlink\" title=\"十五、避免隐式类型转换\"></a>十五、避免隐式类型转换</h1><p>where 子句中出现 column 字段的类型和传入的参数类型不一致的时候发生的类型转换，建议先确定where中的参数类型</p>\n<img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/5.webp\" class=\"\">\n\n<h1 id=\"十六、对于联合索引来说，要遵守最左前缀法则\"><a href=\"#十六、对于联合索引来说，要遵守最左前缀法则\" class=\"headerlink\" title=\"十六、对于联合索引来说，要遵守最左前缀法则\"></a>十六、对于联合索引来说，要遵守最左前缀法则</h1><p>举列来说索引含有字段id,name,school，可以直接用id字段，也可以id,name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面</p>\n<h1 id=\"十七、必要时可以使用force-index来强制查询走某个索引\"><a href=\"#十七、必要时可以使用force-index来强制查询走某个索引\" class=\"headerlink\" title=\"十七、必要时可以使用force index来强制查询走某个索引\"></a>十七、必要时可以使用force index来强制查询走某个索引</h1><p>有的时候MySQL优化器采取它认为合适的索引来检索sql语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用force index来强制优化器使用我们制定的索引。</p>\n<h1 id=\"十八、注意范围查询语句\"><a href=\"#十八、注意范围查询语句\" class=\"headerlink\" title=\"十八、注意范围查询语句\"></a>十八、注意范围查询语句</h1><p>对于联合索引来说，如果存在范围查询，比如between,&gt;,&lt;等条件时，会造成后面的索引字段失效。</p>\n<h1 id=\"十九、关于JOIN优化\"><a href=\"#十九、关于JOIN优化\" class=\"headerlink\" title=\"十九、关于JOIN优化\"></a>十九、关于JOIN优化</h1><img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/6.webp\" class=\"\">\n<p>LEFT JOIN A表为驱动表</p>\n<p>INNER JOIN MySQL会自动找出那个数据少的表作用驱动表</p>\n<p>RIGHT JOIN B表为驱动表</p>\n<p><strong>注意：MySQL中没有full join，可以用以下方式来解决</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from A left join B on B.name &#x3D; A.name </span><br><span class=\"line\">where B.name is null</span><br><span class=\"line\">union all</span><br><span class=\"line\">select * from B;</span><br></pre></td></tr></table></figure>\n<p><strong>尽量使用inner join，避免left join</strong></p>\n<p>参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是left join在驱动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表。</p>\n<p><strong>合理利用索引</strong></p>\n<p>被驱动表的索引字段作为on的限制字段。</p>\n<p><strong>利用小表去驱动大表</strong></p>\n<img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/7.webp\" class=\"\">\n<p>从原理图能够直观的看出如果能够减少驱动表的话，减少嵌套循环中的循环次数，以减少 IO总量及CPU运算的次数。</p>\n<p><strong>巧用STRAIGHT_JOIN</strong></p>\n<p>inner join是由mysql选择驱动表，但是有些特殊情况需要选择另个表作为驱动表，比如有group by、order by等「Using filesort」、「Using temporary」时。STRAIGHT_JOIN来强制连接顺序，在STRAIGHT_JOIN左边的表名就是驱动表，右边则是被驱动表。<strong>在使用STRAIGHT_JOIN有个前提条件是该查询是内连接，也就是inner join。其他链接不推荐使用STRAIGHT_JOIN，否则可能造成查询结果不准确。</strong></p>\n<img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/8.webp\" class=\"\">\n<p>这个方式有时可能减少3倍的时间。</p>\n<p>这里只列举了上述优化方案，当然还有其他的优化方式，大家可以去摸索尝试，感谢关注。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>作者：zhangqh<br>segmentfault.com/a/1190000012155267</p>\n</blockquote>\n<p>本文总结了19条关于Mysql的优化方案，本文的优化方案都是基于 “ Mysql-索引-BTree类型 ” 的。希望对你有帮助。</p>","more":"<h1 id=\"一、EXPLAIN\"><a href=\"#一、EXPLAIN\" class=\"headerlink\" title=\"一、EXPLAIN\"></a>一、EXPLAIN</h1><p>做MySQL优化，我们要善用 EXPLAIN 查看SQL执行计划。</p>\n<p>下面来个简单的示例，标注(1,2,3,4,5)我们要重点关注的数据</p>\n<img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/1.webp\" class=\"\">\n\n<ol>\n<li>type列，连接类型。一个好的sql语句至少要达到range级别。杜绝出现all级别</li>\n<li>key列，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式</li>\n<li>key_len列，索引长度</li>\n<li>rows列，扫描行数。该值是个预估值</li>\n<li>extra列，详细说明。注意常见的不太友好的值有：Using filesort, Using temporary</li>\n</ol>\n<h1 id=\"二、SQL语句中IN包含的值不应过多\"><a href=\"#二、SQL语句中IN包含的值不应过多\" class=\"headerlink\" title=\"二、SQL语句中IN包含的值不应过多\"></a>二、SQL语句中IN包含的值不应过多</h1><p>MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：<code>select id from table_name where num in(1,2,3)</code> 对于连续的数值，能用 between 就不要用 in 了；再或者使用连接来替换。</p>\n<h1 id=\"三、SELECT语句务必指明字段名称\"><a href=\"#三、SELECT语句务必指明字段名称\" class=\"headerlink\" title=\"三、SELECT语句务必指明字段名称\"></a>三、SELECT语句务必指明字段名称</h1><p>SELECT *增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。</p>\n<h1 id=\"四、当只需要一条数据的时候，使用limit-1\"><a href=\"#四、当只需要一条数据的时候，使用limit-1\" class=\"headerlink\" title=\"四、当只需要一条数据的时候，使用limit 1\"></a>四、当只需要一条数据的时候，使用limit 1</h1><p>这是为了使EXPLAIN中type列达到const类型</p>\n<h1 id=\"五、如果排序字段没有用到索引，就尽量少排序\"><a href=\"#五、如果排序字段没有用到索引，就尽量少排序\" class=\"headerlink\" title=\"五、如果排序字段没有用到索引，就尽量少排序\"></a>五、如果排序字段没有用到索引，就尽量少排序</h1><h1 id=\"六、如果限制条件中其他字段没有索引，尽量少用or\"><a href=\"#六、如果限制条件中其他字段没有索引，尽量少用or\" class=\"headerlink\" title=\"六、如果限制条件中其他字段没有索引，尽量少用or\"></a>六、如果限制条件中其他字段没有索引，尽量少用or</h1><p>or两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用 union all 或者是union(必要的时候)的方式来代替“or”会得到更好的效果</p>\n<h1 id=\"七、尽量用union-all代替union\"><a href=\"#七、尽量用union-all代替union\" class=\"headerlink\" title=\"七、尽量用union all代替union\"></a>七、尽量用union all代替union</h1><p>union和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。<strong>当然，union all的前提条件是两个结果集没有重复数据。</strong></p>\n<h1 id=\"八、不使用ORDER-BY-RAND\"><a href=\"#八、不使用ORDER-BY-RAND\" class=\"headerlink\" title=\"八、不使用ORDER BY RAND()\"></a>八、不使用ORDER BY RAND()</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id from &#96;table_name&#96; </span><br><span class=\"line\">order by rand() limit 1000;</span><br></pre></td></tr></table></figure>\n<p>上面的sql语句，可优化为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id from &#96;table_name&#96; t1 join (select rand() * (select max(id) </span><br><span class=\"line\">from &#96;table_name&#96;) asnid) t2 on t1.id &gt; t2.nid limit 1000;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"九、区分-in-和-exists，-not-in-和-not-exists\"><a href=\"#九、区分-in-和-exists，-not-in-和-not-exists\" class=\"headerlink\" title=\"九、区分 in 和 exists， not in 和 not exists\"></a>九、区分 in 和 exists， not in 和 not exists</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from 表A </span><br><span class=\"line\">where id in (select id from 表B)</span><br></pre></td></tr></table></figure>\n<p>上面sql语句相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from 表A </span><br><span class=\"line\">where exists(select * from 表B where 表B.id&#x3D;表A.id)</span><br></pre></td></tr></table></figure>\n<p>区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以<strong>IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</strong><br>关于not in和not exists，推荐使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。<strong>如何高效的写出一个替代not exists的sql语句？</strong></p>\n<p>原sql语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select colname … from A表 </span><br><span class=\"line\">where a.id not in (select b.id from B表)</span><br></pre></td></tr></table></figure>\n<p>高效的sql语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select colname … from A表 Left join B表 on </span><br><span class=\"line\">where a.id &#x3D; b.id where b.id is null</span><br></pre></td></tr></table></figure>\n<p>取出的结果集如下图表示，A表不在B表中的数据</p>\n<img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/2.webp\" class=\"\">\n\n<h1 id=\"十、使用合理的分页方式以提高分页的效率\"><a href=\"#十、使用合理的分页方式以提高分页的效率\" class=\"headerlink\" title=\"十、使用合理的分页方式以提高分页的效率\"></a>十、使用合理的分页方式以提高分页的效率</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id,name </span><br><span class=\"line\">from table_name limit 866613, 20</span><br></pre></td></tr></table></figure>\n<p>使用上述sql语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用limit分页查询会越来越慢。</p>\n<p>优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。sql可以采用如下的写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id,name from table_name </span><br><span class=\"line\">where id&gt; 866612 limit 20</span><br></pre></td></tr></table></figure>\n<h1 id=\"十一、分段查询\"><a href=\"#十一、分段查询\" class=\"headerlink\" title=\"十一、分段查询\"></a>十一、分段查询</h1><p>在一些用户选择页面中，可能一些用户选择的时间范围过大，造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段进行查询，循环遍历，将结果合并处理进行展示。</p>\n<p>如下图这个sql语句，扫描的行数成百万级以上的时候就可以使用分段查询</p>\n<img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/3.webp\" class=\"\">\n\n<h1 id=\"十二、避免在-where-子句中对字段进行-null-值判断\"><a href=\"#十二、避免在-where-子句中对字段进行-null-值判断\" class=\"headerlink\" title=\"十二、避免在 where 子句中对字段进行 null 值判断\"></a>十二、避免在 where 子句中对字段进行 null 值判断</h1><p>对于null的判断会导致引擎放弃使用索引而进行全表扫描。</p>\n<h1 id=\"十三、不建议使用-前缀模糊查询\"><a href=\"#十三、不建议使用-前缀模糊查询\" class=\"headerlink\" title=\"十三、不建议使用%前缀模糊查询\"></a>十三、不建议使用%前缀模糊查询</h1><p>例如LIKE “%name”或者LIKE “%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。</p>\n<p><strong>那如何查询%name%？</strong></p>\n<p>如下图所示，虽然给secret字段添加了索引，但在explain结果果并没有使用</p>\n<img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/4.webp\" class=\"\">\n<p>那么如何解决这个问题呢，答案：<strong>使用全文索引</strong></p>\n<p>在我们查询中经常会用到select id,fnum,fdst from table_name where user_name like ‘%zhangsan%’; 。这样的语句，普通索引是无法满足查询需求的。庆幸的是在MySQL中，有全文索引来帮助我们。</p>\n<p>创建全文索引的sql语法是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE &#96;table_name&#96; ADD FULLTEXT </span><br><span class=\"line\">INDEX &#96;idx_user_name&#96; (&#96;user_name&#96;);</span><br></pre></td></tr></table></figure>\n<p>使用全文索引的sql语句是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id,fnum,fdst from table_name </span><br><span class=\"line\">where match(user_name) against(&#39;zhangsan&#39; in booleanmode);</span><br></pre></td></tr></table></figure>\n<p><strong>注意：在需要创建全文索引之前，请联系DBA确定能否创建。同时需要注意的是查询语句的写法与普通索引的区别</strong></p>\n<h1 id=\"十四、避免在where子句中对字段进行表达式操作\"><a href=\"#十四、避免在where子句中对字段进行表达式操作\" class=\"headerlink\" title=\"十四、避免在where子句中对字段进行表达式操作\"></a>十四、避免在where子句中对字段进行表达式操作</h1><p>比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select user_id,user_project from table_name </span><br><span class=\"line\">where age*2&#x3D;36;</span><br></pre></td></tr></table></figure>\n<p>中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select user_id,user_project from table_name </span><br><span class=\"line\">where age&#x3D;36&#x2F;2;</span><br></pre></td></tr></table></figure>\n<h1 id=\"十五、避免隐式类型转换\"><a href=\"#十五、避免隐式类型转换\" class=\"headerlink\" title=\"十五、避免隐式类型转换\"></a>十五、避免隐式类型转换</h1><p>where 子句中出现 column 字段的类型和传入的参数类型不一致的时候发生的类型转换，建议先确定where中的参数类型</p>\n<img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/5.webp\" class=\"\">\n\n<h1 id=\"十六、对于联合索引来说，要遵守最左前缀法则\"><a href=\"#十六、对于联合索引来说，要遵守最左前缀法则\" class=\"headerlink\" title=\"十六、对于联合索引来说，要遵守最左前缀法则\"></a>十六、对于联合索引来说，要遵守最左前缀法则</h1><p>举列来说索引含有字段id,name,school，可以直接用id字段，也可以id,name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面</p>\n<h1 id=\"十七、必要时可以使用force-index来强制查询走某个索引\"><a href=\"#十七、必要时可以使用force-index来强制查询走某个索引\" class=\"headerlink\" title=\"十七、必要时可以使用force index来强制查询走某个索引\"></a>十七、必要时可以使用force index来强制查询走某个索引</h1><p>有的时候MySQL优化器采取它认为合适的索引来检索sql语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用force index来强制优化器使用我们制定的索引。</p>\n<h1 id=\"十八、注意范围查询语句\"><a href=\"#十八、注意范围查询语句\" class=\"headerlink\" title=\"十八、注意范围查询语句\"></a>十八、注意范围查询语句</h1><p>对于联合索引来说，如果存在范围查询，比如between,&gt;,&lt;等条件时，会造成后面的索引字段失效。</p>\n<h1 id=\"十九、关于JOIN优化\"><a href=\"#十九、关于JOIN优化\" class=\"headerlink\" title=\"十九、关于JOIN优化\"></a>十九、关于JOIN优化</h1><img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/6.webp\" class=\"\">\n<p>LEFT JOIN A表为驱动表</p>\n<p>INNER JOIN MySQL会自动找出那个数据少的表作用驱动表</p>\n<p>RIGHT JOIN B表为驱动表</p>\n<p><strong>注意：MySQL中没有full join，可以用以下方式来解决</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from A left join B on B.name &#x3D; A.name </span><br><span class=\"line\">where B.name is null</span><br><span class=\"line\">union all</span><br><span class=\"line\">select * from B;</span><br></pre></td></tr></table></figure>\n<p><strong>尽量使用inner join，避免left join</strong></p>\n<p>参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是left join在驱动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表。</p>\n<p><strong>合理利用索引</strong></p>\n<p>被驱动表的索引字段作为on的限制字段。</p>\n<p><strong>利用小表去驱动大表</strong></p>\n<img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/7.webp\" class=\"\">\n<p>从原理图能够直观的看出如果能够减少驱动表的话，减少嵌套循环中的循环次数，以减少 IO总量及CPU运算的次数。</p>\n<p><strong>巧用STRAIGHT_JOIN</strong></p>\n<p>inner join是由mysql选择驱动表，但是有些特殊情况需要选择另个表作为驱动表，比如有group by、order by等「Using filesort」、「Using temporary」时。STRAIGHT_JOIN来强制连接顺序，在STRAIGHT_JOIN左边的表名就是驱动表，右边则是被驱动表。<strong>在使用STRAIGHT_JOIN有个前提条件是该查询是内连接，也就是inner join。其他链接不推荐使用STRAIGHT_JOIN，否则可能造成查询结果不准确。</strong></p>\n<img src=\"/2019/03/26/2019-%E5%B8%B8%E7%94%A8MySQL%E4%BC%98%E5%8C%96/8.webp\" class=\"\">\n<p>这个方式有时可能减少3倍的时间。</p>\n<p>这里只列举了上述优化方案，当然还有其他的优化方式，大家可以去摸索尝试，感谢关注。</p>"},{"title":"建站日志","date":"2019-01-24T08:10:00.000Z","updated":"2020-05-22T09:55:00.000Z","_content":"> 本站的搭建流程\n\n<!-- more -->\n\n# 1. Hexo博客框架\n\n[Hexo：快速、简洁且高效的博客框架](https://hexo.io/zh-cn/docs/)\n\n# 2. yilia主题\n\n[hexo：yilia](https://github.com/litten/hexo-theme-yilia)\n\n# 3. Hexo+Github实现相册功能\n\n## 3.1 教程\n[Lawlite：Hexo+Github实现相册功能](http://lawlite.me/2017/04/13/Hexo-Github%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/#more)\n[wardseptember：补充教程，解决缩略图不显示等问题](https://blog.csdn.net/wardseptember/article/details/82780684)\n\n## 3.2 参考实现\n[Litten的博客备份](https://github.com/litten/BlogBackup)\n[lawlite的博客备份](https://github.com/lawlite19/Blog-Back-Up)\n\n# 4. hexo+yilia主题添加文章访问量统计(2019-03-28)\n[https://blog.csdn.net/qq_40910541/article/details/80659193](https://blog.csdn.net/qq_40910541/article/details/80659193)\n\n## 4.1 引入[不蒜子](http://busuanzi.ibruce.info/)\n将下面代码添加在 /themes/yilia/layout/_partial/footer.ejs 的末尾\n```\n<script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n```\n\n## 4.2 添加站点访问量\n将下面代码添加在 /themes/yilia/layout/_partial/footer.ejs 中末尾。\n```\n<span id=\"busuanzi_container_site_pv\">本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次</span>\n```\n\n## 4.3 添加文章访问量\n添加在/themes/yilia/layout/_partial/article.ejs的header的日期后面：\n```\n<header class=\"article-header\">\n<%- partial('post/title', {class_name: 'article-title'}) %>\n<% if (!post.noDate){ %>\n<%- partial('post/date', {class_name: 'archive-article-date', date_format: null}) %>\n<% } %>\n\n<!-- 添加代码 -->\n<% if ( !index ){ %>\n    <span class=\"archive-article-date\">\n    阅读量 <span id=\"busuanzi_value_page_pv\"></span>\n    </span>\n<% } %>\n\n</header>\n```\n\n# 5.踩坑\n## 5.1 缺少Deployer\n\n```\nERROR Deployer not found: git\n```\nhexo初始化可能不自带这个包，要手动安装\n```\nnpm install hexo-deployer-git\n```\n\n## 5.2 SSH问题\n使用SSH KEY,本地生成id_rsa 和id_rsa_pub文件,并复制id_rsa_pub文件中的内容添加到帐号之后,部署(hexo d)报错:\n\n```shell\nPermission denied (publickey).\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights\nand the repository exists.\nFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\n```\n\n测试当前的SSH是否配置成功,在git bash 中执行命令`ssh -T git@github.com`报错如下:\nPermission denied (publickey).\n\n原因:说明当前`SSH`没有配置成功\n\n解决:\n请确保以下2步均做到\n1、远程服务器已经有了对应于本地主机上公钥\n2、本地主机ssh服务开启(windows上是ssh-agent.exe运行)，并且本地主机私钥要包含在ssh服务列表中\n\n- 第一步已经完成,已经将`id_rsa.pub`文件中的内容添加到了github帐号\n\n- 第二步：检查本地私钥是否存在于ssh服务中\n\n```\ncd ~/.ssh\neval 'ssh-agent -s'\n```\n如果运行这句出现Could not open a connection to your authentication agent，那么就先运行\n`ssh-agent bash`\n再运行\n`ssh-add -l`\n如果不存在，需要添加进去\n`ssh-add ~/.ssh/id_rsa`\n添加完成之后,再执行`ssh -T git@github.com`测试SSH是否配置成功!!!\n\n如果出现以下内容说明配置成功\n\n```\nHi username! You've successfully authenticated,\n but GitHub does not provide shell access.\n```\n\n## 5.3 仓库设置问题\n源代码分支可以正常提交，deploy失败，ssh连接建立成功。\n原因：\nclone时使用了https，这个信息保存在`.git/config`里，但是在yml中设置的是`git@`开头的ssh地址。\n\n解决方案，修改`.git/config`里的仓库地址，与yml一致。\n","source":"_posts/2019/建站日志.md","raw":"---\ntitle: 建站日志\ndate: 2019-01-24 16:10\nupdated: 2020-05-22 17:55\ntags: 杂谈\n---\n> 本站的搭建流程\n\n<!-- more -->\n\n# 1. Hexo博客框架\n\n[Hexo：快速、简洁且高效的博客框架](https://hexo.io/zh-cn/docs/)\n\n# 2. yilia主题\n\n[hexo：yilia](https://github.com/litten/hexo-theme-yilia)\n\n# 3. Hexo+Github实现相册功能\n\n## 3.1 教程\n[Lawlite：Hexo+Github实现相册功能](http://lawlite.me/2017/04/13/Hexo-Github%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/#more)\n[wardseptember：补充教程，解决缩略图不显示等问题](https://blog.csdn.net/wardseptember/article/details/82780684)\n\n## 3.2 参考实现\n[Litten的博客备份](https://github.com/litten/BlogBackup)\n[lawlite的博客备份](https://github.com/lawlite19/Blog-Back-Up)\n\n# 4. hexo+yilia主题添加文章访问量统计(2019-03-28)\n[https://blog.csdn.net/qq_40910541/article/details/80659193](https://blog.csdn.net/qq_40910541/article/details/80659193)\n\n## 4.1 引入[不蒜子](http://busuanzi.ibruce.info/)\n将下面代码添加在 /themes/yilia/layout/_partial/footer.ejs 的末尾\n```\n<script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n```\n\n## 4.2 添加站点访问量\n将下面代码添加在 /themes/yilia/layout/_partial/footer.ejs 中末尾。\n```\n<span id=\"busuanzi_container_site_pv\">本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次</span>\n```\n\n## 4.3 添加文章访问量\n添加在/themes/yilia/layout/_partial/article.ejs的header的日期后面：\n```\n<header class=\"article-header\">\n<%- partial('post/title', {class_name: 'article-title'}) %>\n<% if (!post.noDate){ %>\n<%- partial('post/date', {class_name: 'archive-article-date', date_format: null}) %>\n<% } %>\n\n<!-- 添加代码 -->\n<% if ( !index ){ %>\n    <span class=\"archive-article-date\">\n    阅读量 <span id=\"busuanzi_value_page_pv\"></span>\n    </span>\n<% } %>\n\n</header>\n```\n\n# 5.踩坑\n## 5.1 缺少Deployer\n\n```\nERROR Deployer not found: git\n```\nhexo初始化可能不自带这个包，要手动安装\n```\nnpm install hexo-deployer-git\n```\n\n## 5.2 SSH问题\n使用SSH KEY,本地生成id_rsa 和id_rsa_pub文件,并复制id_rsa_pub文件中的内容添加到帐号之后,部署(hexo d)报错:\n\n```shell\nPermission denied (publickey).\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights\nand the repository exists.\nFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\n```\n\n测试当前的SSH是否配置成功,在git bash 中执行命令`ssh -T git@github.com`报错如下:\nPermission denied (publickey).\n\n原因:说明当前`SSH`没有配置成功\n\n解决:\n请确保以下2步均做到\n1、远程服务器已经有了对应于本地主机上公钥\n2、本地主机ssh服务开启(windows上是ssh-agent.exe运行)，并且本地主机私钥要包含在ssh服务列表中\n\n- 第一步已经完成,已经将`id_rsa.pub`文件中的内容添加到了github帐号\n\n- 第二步：检查本地私钥是否存在于ssh服务中\n\n```\ncd ~/.ssh\neval 'ssh-agent -s'\n```\n如果运行这句出现Could not open a connection to your authentication agent，那么就先运行\n`ssh-agent bash`\n再运行\n`ssh-add -l`\n如果不存在，需要添加进去\n`ssh-add ~/.ssh/id_rsa`\n添加完成之后,再执行`ssh -T git@github.com`测试SSH是否配置成功!!!\n\n如果出现以下内容说明配置成功\n\n```\nHi username! You've successfully authenticated,\n but GitHub does not provide shell access.\n```\n\n## 5.3 仓库设置问题\n源代码分支可以正常提交，deploy失败，ssh连接建立成功。\n原因：\nclone时使用了https，这个信息保存在`.git/config`里，但是在yml中设置的是`git@`开头的ssh地址。\n\n解决方案，修改`.git/config`里的仓库地址，与yml一致。\n","slug":"2019-建站日志","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrk7000u2yku8e2rfcxf","content":"<blockquote>\n<p>本站的搭建流程</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h1 id=\"1-Hexo博客框架\"><a href=\"#1-Hexo博客框架\" class=\"headerlink\" title=\"1. Hexo博客框架\"></a>1. Hexo博客框架</h1><p><a href=\"https://hexo.io/zh-cn/docs/\">Hexo：快速、简洁且高效的博客框架</a></p>\n<h1 id=\"2-yilia主题\"><a href=\"#2-yilia主题\" class=\"headerlink\" title=\"2. yilia主题\"></a>2. yilia主题</h1><p><a href=\"https://github.com/litten/hexo-theme-yilia\">hexo：yilia</a></p>\n<h1 id=\"3-Hexo-Github实现相册功能\"><a href=\"#3-Hexo-Github实现相册功能\" class=\"headerlink\" title=\"3. Hexo+Github实现相册功能\"></a>3. Hexo+Github实现相册功能</h1><h2 id=\"3-1-教程\"><a href=\"#3-1-教程\" class=\"headerlink\" title=\"3.1 教程\"></a>3.1 教程</h2><p><a href=\"http://lawlite.me/2017/04/13/Hexo-Github%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/#more\">Lawlite：Hexo+Github实现相册功能</a><br><a href=\"https://blog.csdn.net/wardseptember/article/details/82780684\">wardseptember：补充教程，解决缩略图不显示等问题</a></p>\n<h2 id=\"3-2-参考实现\"><a href=\"#3-2-参考实现\" class=\"headerlink\" title=\"3.2 参考实现\"></a>3.2 参考实现</h2><p><a href=\"https://github.com/litten/BlogBackup\">Litten的博客备份</a><br><a href=\"https://github.com/lawlite19/Blog-Back-Up\">lawlite的博客备份</a></p>\n<h1 id=\"4-hexo-yilia主题添加文章访问量统计-2019-03-28\"><a href=\"#4-hexo-yilia主题添加文章访问量统计-2019-03-28\" class=\"headerlink\" title=\"4. hexo+yilia主题添加文章访问量统计(2019-03-28)\"></a>4. hexo+yilia主题添加文章访问量统计(2019-03-28)</h1><p><a href=\"https://blog.csdn.net/qq_40910541/article/details/80659193\">https://blog.csdn.net/qq_40910541/article/details/80659193</a></p>\n<h2 id=\"4-1-引入不蒜子\"><a href=\"#4-1-引入不蒜子\" class=\"headerlink\" title=\"4.1 引入不蒜子\"></a>4.1 引入<a href=\"http://busuanzi.ibruce.info/\">不蒜子</a></h2><p>将下面代码添加在 /themes/yilia/layout/_partial/footer.ejs 的末尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script async src&#x3D;&quot;&#x2F;&#x2F;dn-lbstatics.qbox.me&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2-添加站点访问量\"><a href=\"#4-2-添加站点访问量\" class=\"headerlink\" title=\"4.2 添加站点访问量\"></a>4.2 添加站点访问量</h2><p>将下面代码添加在 /themes/yilia/layout/_partial/footer.ejs 中末尾。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;次&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-3-添加文章访问量\"><a href=\"#4-3-添加文章访问量\" class=\"headerlink\" title=\"4.3 添加文章访问量\"></a>4.3 添加文章访问量</h2><p>添加在/themes/yilia/layout/_partial/article.ejs的header的日期后面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;header class&#x3D;&quot;article-header&quot;&gt;</span><br><span class=\"line\">&lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;</span><br><span class=\"line\">&lt;% if (!post.noDate)&#123; %&gt;</span><br><span class=\"line\">&lt;%- partial(&#39;post&#x2F;date&#39;, &#123;class_name: &#39;archive-article-date&#39;, date_format: null&#125;) %&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 添加代码 --&gt;</span><br><span class=\"line\">&lt;% if ( !index )&#123; %&gt;</span><br><span class=\"line\">    &lt;span class&#x3D;&quot;archive-article-date&quot;&gt;</span><br><span class=\"line\">    阅读量 &lt;span id&#x3D;&quot;busuanzi_value_page_pv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class=\"line\">    &lt;&#x2F;span&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;header&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-踩坑\"><a href=\"#5-踩坑\" class=\"headerlink\" title=\"5.踩坑\"></a>5.踩坑</h1><h2 id=\"5-1-缺少Deployer\"><a href=\"#5-1-缺少Deployer\" class=\"headerlink\" title=\"5.1 缺少Deployer\"></a>5.1 缺少Deployer</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>\n<p>hexo初始化可能不自带这个包，要手动安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-SSH问题\"><a href=\"#5-2-SSH问题\" class=\"headerlink\" title=\"5.2 SSH问题\"></a>5.2 SSH问题</h2><p>使用SSH KEY,本地生成id_rsa 和id_rsa_pub文件,并复制id_rsa_pub文件中的内容添加到帐号之后,部署(hexo d)报错:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Permission denied (publickey).</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br><span class=\"line\">FATAL Something&#x27;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure>\n\n<p>测试当前的SSH是否配置成功,在git bash 中执行命令<code>ssh -T git@github.com</code>报错如下:<br>Permission denied (publickey).</p>\n<p>原因:说明当前<code>SSH</code>没有配置成功</p>\n<p>解决:<br>请确保以下2步均做到<br>1、远程服务器已经有了对应于本地主机上公钥<br>2、本地主机ssh服务开启(windows上是ssh-agent.exe运行)，并且本地主机私钥要包含在ssh服务列表中</p>\n<ul>\n<li><p>第一步已经完成,已经将<code>id_rsa.pub</code>文件中的内容添加到了github帐号</p>\n</li>\n<li><p>第二步：检查本地私钥是否存在于ssh服务中</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~&#x2F;.ssh</span><br><span class=\"line\">eval &#39;ssh-agent -s&#39;</span><br></pre></td></tr></table></figure>\n<p>如果运行这句出现Could not open a connection to your authentication agent，那么就先运行<br><code>ssh-agent bash</code><br>再运行<br><code>ssh-add -l</code><br>如果不存在，需要添加进去<br><code>ssh-add ~/.ssh/id_rsa</code><br>添加完成之后,再执行<code>ssh -T git@github.com</code>测试SSH是否配置成功!!!</p>\n<p>如果出现以下内容说明配置成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hi username! You&#39;ve successfully authenticated,</span><br><span class=\"line\"> but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-3-仓库设置问题\"><a href=\"#5-3-仓库设置问题\" class=\"headerlink\" title=\"5.3 仓库设置问题\"></a>5.3 仓库设置问题</h2><p>源代码分支可以正常提交，deploy失败，ssh连接建立成功。<br>原因：<br>clone时使用了https，这个信息保存在<code>.git/config</code>里，但是在yml中设置的是<code>git@</code>开头的ssh地址。</p>\n<p>解决方案，修改<code>.git/config</code>里的仓库地址，与yml一致。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本站的搭建流程</p>\n</blockquote>","more":"<h1 id=\"1-Hexo博客框架\"><a href=\"#1-Hexo博客框架\" class=\"headerlink\" title=\"1. Hexo博客框架\"></a>1. Hexo博客框架</h1><p><a href=\"https://hexo.io/zh-cn/docs/\">Hexo：快速、简洁且高效的博客框架</a></p>\n<h1 id=\"2-yilia主题\"><a href=\"#2-yilia主题\" class=\"headerlink\" title=\"2. yilia主题\"></a>2. yilia主题</h1><p><a href=\"https://github.com/litten/hexo-theme-yilia\">hexo：yilia</a></p>\n<h1 id=\"3-Hexo-Github实现相册功能\"><a href=\"#3-Hexo-Github实现相册功能\" class=\"headerlink\" title=\"3. Hexo+Github实现相册功能\"></a>3. Hexo+Github实现相册功能</h1><h2 id=\"3-1-教程\"><a href=\"#3-1-教程\" class=\"headerlink\" title=\"3.1 教程\"></a>3.1 教程</h2><p><a href=\"http://lawlite.me/2017/04/13/Hexo-Github%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/#more\">Lawlite：Hexo+Github实现相册功能</a><br><a href=\"https://blog.csdn.net/wardseptember/article/details/82780684\">wardseptember：补充教程，解决缩略图不显示等问题</a></p>\n<h2 id=\"3-2-参考实现\"><a href=\"#3-2-参考实现\" class=\"headerlink\" title=\"3.2 参考实现\"></a>3.2 参考实现</h2><p><a href=\"https://github.com/litten/BlogBackup\">Litten的博客备份</a><br><a href=\"https://github.com/lawlite19/Blog-Back-Up\">lawlite的博客备份</a></p>\n<h1 id=\"4-hexo-yilia主题添加文章访问量统计-2019-03-28\"><a href=\"#4-hexo-yilia主题添加文章访问量统计-2019-03-28\" class=\"headerlink\" title=\"4. hexo+yilia主题添加文章访问量统计(2019-03-28)\"></a>4. hexo+yilia主题添加文章访问量统计(2019-03-28)</h1><p><a href=\"https://blog.csdn.net/qq_40910541/article/details/80659193\">https://blog.csdn.net/qq_40910541/article/details/80659193</a></p>\n<h2 id=\"4-1-引入不蒜子\"><a href=\"#4-1-引入不蒜子\" class=\"headerlink\" title=\"4.1 引入不蒜子\"></a>4.1 引入<a href=\"http://busuanzi.ibruce.info/\">不蒜子</a></h2><p>将下面代码添加在 /themes/yilia/layout/_partial/footer.ejs 的末尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script async src&#x3D;&quot;&#x2F;&#x2F;dn-lbstatics.qbox.me&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2-添加站点访问量\"><a href=\"#4-2-添加站点访问量\" class=\"headerlink\" title=\"4.2 添加站点访问量\"></a>4.2 添加站点访问量</h2><p>将下面代码添加在 /themes/yilia/layout/_partial/footer.ejs 中末尾。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;次&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-3-添加文章访问量\"><a href=\"#4-3-添加文章访问量\" class=\"headerlink\" title=\"4.3 添加文章访问量\"></a>4.3 添加文章访问量</h2><p>添加在/themes/yilia/layout/_partial/article.ejs的header的日期后面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;header class&#x3D;&quot;article-header&quot;&gt;</span><br><span class=\"line\">&lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;</span><br><span class=\"line\">&lt;% if (!post.noDate)&#123; %&gt;</span><br><span class=\"line\">&lt;%- partial(&#39;post&#x2F;date&#39;, &#123;class_name: &#39;archive-article-date&#39;, date_format: null&#125;) %&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 添加代码 --&gt;</span><br><span class=\"line\">&lt;% if ( !index )&#123; %&gt;</span><br><span class=\"line\">    &lt;span class&#x3D;&quot;archive-article-date&quot;&gt;</span><br><span class=\"line\">    阅读量 &lt;span id&#x3D;&quot;busuanzi_value_page_pv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class=\"line\">    &lt;&#x2F;span&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;header&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-踩坑\"><a href=\"#5-踩坑\" class=\"headerlink\" title=\"5.踩坑\"></a>5.踩坑</h1><h2 id=\"5-1-缺少Deployer\"><a href=\"#5-1-缺少Deployer\" class=\"headerlink\" title=\"5.1 缺少Deployer\"></a>5.1 缺少Deployer</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>\n<p>hexo初始化可能不自带这个包，要手动安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-SSH问题\"><a href=\"#5-2-SSH问题\" class=\"headerlink\" title=\"5.2 SSH问题\"></a>5.2 SSH问题</h2><p>使用SSH KEY,本地生成id_rsa 和id_rsa_pub文件,并复制id_rsa_pub文件中的内容添加到帐号之后,部署(hexo d)报错:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Permission denied (publickey).</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br><span class=\"line\">FATAL Something&#x27;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure>\n\n<p>测试当前的SSH是否配置成功,在git bash 中执行命令<code>ssh -T git@github.com</code>报错如下:<br>Permission denied (publickey).</p>\n<p>原因:说明当前<code>SSH</code>没有配置成功</p>\n<p>解决:<br>请确保以下2步均做到<br>1、远程服务器已经有了对应于本地主机上公钥<br>2、本地主机ssh服务开启(windows上是ssh-agent.exe运行)，并且本地主机私钥要包含在ssh服务列表中</p>\n<ul>\n<li><p>第一步已经完成,已经将<code>id_rsa.pub</code>文件中的内容添加到了github帐号</p>\n</li>\n<li><p>第二步：检查本地私钥是否存在于ssh服务中</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~&#x2F;.ssh</span><br><span class=\"line\">eval &#39;ssh-agent -s&#39;</span><br></pre></td></tr></table></figure>\n<p>如果运行这句出现Could not open a connection to your authentication agent，那么就先运行<br><code>ssh-agent bash</code><br>再运行<br><code>ssh-add -l</code><br>如果不存在，需要添加进去<br><code>ssh-add ~/.ssh/id_rsa</code><br>添加完成之后,再执行<code>ssh -T git@github.com</code>测试SSH是否配置成功!!!</p>\n<p>如果出现以下内容说明配置成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hi username! You&#39;ve successfully authenticated,</span><br><span class=\"line\"> but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-3-仓库设置问题\"><a href=\"#5-3-仓库设置问题\" class=\"headerlink\" title=\"5.3 仓库设置问题\"></a>5.3 仓库设置问题</h2><p>源代码分支可以正常提交，deploy失败，ssh连接建立成功。<br>原因：<br>clone时使用了https，这个信息保存在<code>.git/config</code>里，但是在yml中设置的是<code>git@</code>开头的ssh地址。</p>\n<p>解决方案，修改<code>.git/config</code>里的仓库地址，与yml一致。</p>"},{"title":"批量执行不确定数量的异步方法","date":"2019-10-30T16:00:00.000Z","updated":"2019-10-30T16:00:00.000Z","_content":"\nPromise.all()参数可变时的使用方法\n\n<!-- more -->\n\n```\nlet pushTokenList = [];\nlet errIdList = [];\nlet functions = [];\nuserList.forEach((item)=>{\n    let params = {\n        TableName: process.env.USERS,\n        KeyConditionExpression: \"#id = :id\",\n        ProjectionExpression:\"pushToken\",\n        ExpressionAttributeNames: {\n            \"#id\": \"id\"\n        },\n        ExpressionAttributeValues: {\n            \":id\": item.userId\n        }\n    }\n    functions.push(async ()=>{\n        try {\n            let data = await db.query(params).promise();\n            if (data.Count === 0 || !data.Items[0].pushToken) {\n                throw new Error().attr({code: 4001258, error_desc: \"invalid userId\", context: {userId: item.userId}});\n            }else {\n                pushTokenList.push(data.Items[0].pushToken);\n            }\n        }catch (err) {\n            errIdList.push(err);\n        }\n    })\n});\n\nlet promises = [];\nfunctions.forEach(item=>{\n    promises.push(item());\n})\nlet result = await Promise.all(promises);\n\nreturn {pushTokenList, errIdList}\n```","source":"_posts/2019/批量执行不确定数量的异步方法.md","raw":"---\ntitle: 批量执行不确定数量的异步方法\ndate: 2019-10-31\nupdated: 2019-10-31\ntags: JS\n---\n\nPromise.all()参数可变时的使用方法\n\n<!-- more -->\n\n```\nlet pushTokenList = [];\nlet errIdList = [];\nlet functions = [];\nuserList.forEach((item)=>{\n    let params = {\n        TableName: process.env.USERS,\n        KeyConditionExpression: \"#id = :id\",\n        ProjectionExpression:\"pushToken\",\n        ExpressionAttributeNames: {\n            \"#id\": \"id\"\n        },\n        ExpressionAttributeValues: {\n            \":id\": item.userId\n        }\n    }\n    functions.push(async ()=>{\n        try {\n            let data = await db.query(params).promise();\n            if (data.Count === 0 || !data.Items[0].pushToken) {\n                throw new Error().attr({code: 4001258, error_desc: \"invalid userId\", context: {userId: item.userId}});\n            }else {\n                pushTokenList.push(data.Items[0].pushToken);\n            }\n        }catch (err) {\n            errIdList.push(err);\n        }\n    })\n});\n\nlet promises = [];\nfunctions.forEach(item=>{\n    promises.push(item());\n})\nlet result = await Promise.all(promises);\n\nreturn {pushTokenList, errIdList}\n```","slug":"2019-批量执行不确定数量的异步方法","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrk8000v2ykudcqk558o","content":"<p>Promise.all()参数可变时的使用方法</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let pushTokenList &#x3D; [];</span><br><span class=\"line\">let errIdList &#x3D; [];</span><br><span class=\"line\">let functions &#x3D; [];</span><br><span class=\"line\">userList.forEach((item)&#x3D;&gt;&#123;</span><br><span class=\"line\">    let params &#x3D; &#123;</span><br><span class=\"line\">        TableName: process.env.USERS,</span><br><span class=\"line\">        KeyConditionExpression: &quot;#id &#x3D; :id&quot;,</span><br><span class=\"line\">        ProjectionExpression:&quot;pushToken&quot;,</span><br><span class=\"line\">        ExpressionAttributeNames: &#123;</span><br><span class=\"line\">            &quot;#id&quot;: &quot;id&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ExpressionAttributeValues: &#123;</span><br><span class=\"line\">            &quot;:id&quot;: item.userId</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    functions.push(async ()&#x3D;&gt;&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            let data &#x3D; await db.query(params).promise();</span><br><span class=\"line\">            if (data.Count &#x3D;&#x3D;&#x3D; 0 || !data.Items[0].pushToken) &#123;</span><br><span class=\"line\">                throw new Error().attr(&#123;code: 4001258, error_desc: &quot;invalid userId&quot;, context: &#123;userId: item.userId&#125;&#125;);</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                pushTokenList.push(data.Items[0].pushToken);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;catch (err) &#123;</span><br><span class=\"line\">            errIdList.push(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">let promises &#x3D; [];</span><br><span class=\"line\">functions.forEach(item&#x3D;&gt;&#123;</span><br><span class=\"line\">    promises.push(item());</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let result &#x3D; await Promise.all(promises);</span><br><span class=\"line\"></span><br><span class=\"line\">return &#123;pushTokenList, errIdList&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Promise.all()参数可变时的使用方法</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let pushTokenList &#x3D; [];</span><br><span class=\"line\">let errIdList &#x3D; [];</span><br><span class=\"line\">let functions &#x3D; [];</span><br><span class=\"line\">userList.forEach((item)&#x3D;&gt;&#123;</span><br><span class=\"line\">    let params &#x3D; &#123;</span><br><span class=\"line\">        TableName: process.env.USERS,</span><br><span class=\"line\">        KeyConditionExpression: &quot;#id &#x3D; :id&quot;,</span><br><span class=\"line\">        ProjectionExpression:&quot;pushToken&quot;,</span><br><span class=\"line\">        ExpressionAttributeNames: &#123;</span><br><span class=\"line\">            &quot;#id&quot;: &quot;id&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ExpressionAttributeValues: &#123;</span><br><span class=\"line\">            &quot;:id&quot;: item.userId</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    functions.push(async ()&#x3D;&gt;&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            let data &#x3D; await db.query(params).promise();</span><br><span class=\"line\">            if (data.Count &#x3D;&#x3D;&#x3D; 0 || !data.Items[0].pushToken) &#123;</span><br><span class=\"line\">                throw new Error().attr(&#123;code: 4001258, error_desc: &quot;invalid userId&quot;, context: &#123;userId: item.userId&#125;&#125;);</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                pushTokenList.push(data.Items[0].pushToken);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;catch (err) &#123;</span><br><span class=\"line\">            errIdList.push(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">let promises &#x3D; [];</span><br><span class=\"line\">functions.forEach(item&#x3D;&gt;&#123;</span><br><span class=\"line\">    promises.push(item());</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let result &#x3D; await Promise.all(promises);</span><br><span class=\"line\"></span><br><span class=\"line\">return &#123;pushTokenList, errIdList&#125;</span><br></pre></td></tr></table></figure>"},{"title":"数据库基础知识","date":"2019-04-13T17:01:40.000Z","updated":"2020-04-03T16:00:00.000Z","_content":"\n# 1. 数据库的不同类型\n\n<!-- more -->\n\n## 1.1 常用的关系型数据库\n\n- **Oracle：**功能强大，主要缺点就是贵\n- **MySQL：**互联网行业中最流行的数据库，这不仅仅是因为MySQL的免费。可以说关系数据库场景中你需要的功能，MySQL都能很好的满足，后面详解部分会详细介绍MySQL的一些知识点\n- **MariaDB：**是MySQL的分支，由开源社区维护，MariaDB虽然被看作MySQL的替代品，但它在扩展功能、存储引擎上都有非常好的改进\n- **PostgreSQL：**也叫PGSQL，PGSQL类似于Oracle的多进程框架，可以支持高并发的应用场景，PG几乎支持所有的SQL标准，支持类型相当丰富。PG更加适合严格的企业应用场景，而MySQL更适合业务逻辑相对简单、数据可靠性要求较低的互联网场景。\n\n## 1.2 NoSQL数据库（非关系型数据库）\n\n- **Redis：**提供了持久化能力，支持多种数据类型。Redis适用于数据变化快且数据大小可预测的场景。\n- **MongoDB：**一个基于分布式文件存储的数据库，将数据存储为一个文档，数据结构由键值对组成。MongoDB比较适合表结构不明确，且数据结构可能不断变化的场景，不适合有事务和复杂查询的场景。\n- **HBase：**建立在HDFS，也就是Hadoop文件系统之上的分布式面向列的数据库。类似于谷歌的大表设计，HBase可以提供快速随机访问海量结构化数据。在表中它由行排序，一个表有多个列族以及每一个列族可以有任意数量的列。 HBase依赖HDFS可以实现海量数据的可靠存储，适用于数据量大，写多读少，不需要复杂查询的场景。\n- **Cassandra：**一个高可靠的大规模分布式存储系统。支持分布式的结构化Key-value存储，以高可用性为主要目标。适合写多的场景，适合做一些简单查询，不适合用来做数据分析统计。\n- **Pika：**一个可持久化的大容量类Redis存储服务， 兼容五种主要数据结构的大部分命令。Pika使用磁盘存储，主要解决Redis大容量存储的成本问题。\n\n## 1.3 NewSQL数据库（新一代关系型数据库）\n\n- **TiDB：**开源的分布式关系数据库，几乎完全兼容MySQL，能够支持水平弹性扩展、ACID事务、标准SQL、MySQL语法和MySQL协议，具有数据强一致的高可用特性。既适合在线事务处理，也适合在线分析处理。\n- **OceanBase：**OceanBase是蚂蚁金服的数据库，OB是可以满足金融级的可靠性和数据一致性要求的数据库系统。当你需要使用事务，并且数据量比较大，就比较适合使用OB。不过目前OB已经商业化，不再开源。\n\n# 2. 事务特性及事务类型\n\n## 2.1数据库事务特性（ACID）\n\n数据库共4个特性：\n\n- **原子性：**是指事务由原子的操作序列组成，所有操作要么全部成功，要么全部失败回滚。\n- **一致性：**是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处以一致性状态。比如在做多表操作时，多个表要么都是事务后新的值，要么都是事务前的旧值。\n- **隔离性：**是指多个用户并发访问数据库时，数据库为每个用户执行的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。事务的隔离级别我们稍后介绍。\n- **持久性：**是指一个事务一旦提交并执行成功，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n\n## 2.2 事物并发问题与隔离级别\n\n### 2.2.1 事务并发问题\n\n- **脏读：**脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据，例如，账户A转帐给B500元，B余额增加后但事务还没有提交完成，此时如果另外的请求中获取的是B增加后的余额，这就发生了脏读，因为事务如果失败回滚时，B的余额就不应该增加。\n- **不可重复读：**不可重复读是指对于数据库中某个数据，一个事务范围内多次查询返回了不同的数据值，这是由于在多次查询之间，有其他事务修改了数据并进行了提交。\n- **幻读：**是指一个事务中执行两次完全相同的查询时，第二次查询所返回的结果集跟第一个查询不相同。与不可重复读的区别在于，不可重复读是对同一条记录，两次读取的值不同。而幻读是记录的增加或删除，导致两次相同条件获取的结果记录数不同。\n\n### 2.2.2 事务的四种隔离级别\n\n可以用于解决这几种并发问题。如图右面，由上到下的4种隔离级别由低到高。\n\n- **级别一读未提交：**也就是可以读取到其他事务未提交的内容，这是最低的隔离级别，这个隔离级别下，前面提到的三种并发问题都有可能发生。\n- **级别二读已提交：**就是只能读取到其他事务已经提交的数据。这个隔离级别可以解决脏读问题。\n- **级别三可重复读：**可以保证整个事务过程中，对同数据的多次读取结果是相同的。这个级别可以解决脏读和不可重复读的问题。MySQL默认的隔离级别就是可重复读。\n- **级别四串行化：**这是最高的隔离级别，所有事务操作都依次顺序执行。这个级别会导致并发度下降，性能最差。不过这个级别可以解决前面提到的所有并发问题。\n\n## 2.3 事务分类\n\n共分5大类：\n\n- **扁平化事务：**在扁平事务中，所有的操作都在同一层次，这也是我们平时使用最多的一种事务。它的主要限制是不能提交或者回滚事务的某一部分，要么都成功，要么都回滚。\n- **带保存点的扁平事务：为**了解决第一种事务的弊端，就有了第二种带保存点的扁平事务。它允许事务在执行过程中回滚到较早的状态，而不是全部回滚。通过在事务中插入保存点，当操作失败后，可以选择回滚到最近的保存点处。\n- **链事务：**可以看做是第二种事务的变种。它在事务提交时，会将必要的上下文隐式传递给下一个事务，当事务失败时就可以回滚到最近的事务。不过，链事务只能回滚到最近的保存点，而带保存点的扁平化事务是可以回滚到任意的保存点。\n- **嵌套事务：**由顶层事务和子事务构成，类似于树的结构。一般顶层事务负责逻辑管理，子事务负责具体的工作，子事务可以提交，但真正提交要等到父事务提交，如果上层事务回滚，那么所有的子事务都会回滚。\n- **分布式事务：**是指分布式环境中的扁平化事务。\n\n分布式事务中，常用的解决方案共4种：\n\n- **a.XA协议：**是保证强一致性的刚性事务。实现方式有两段式提交和三段式提交。两段式提交需要有一个事务协调者来保证所有的事务参与者都完成了第一阶段的准备工作。如果协调者收到所有参与者都准备好的消息，就会通知所有的事务执行第二阶段提交。一般场景下两段式提交已经能够很好得解决分布式事务了，然而两阶段在即使只有一个进程发生故障时，也会导致整个系统存在较长时间的阻塞。三段式提交通过增加Pre-commit阶段来减少前面提到的系统阻塞的时间。三段式提交很少在实际中使用，简单了解就可以了。\n- **b.TCC：**是满足最终一致性的柔性事务方案。TCC采用补偿机制，核心思想是对每个操作，都要注册对应的确认和补偿操作。它分为三个阶段：Try阶段主要对业务系统进行检测及资源预留；Confirm阶段对业务系统做确认提交。Cancel阶段是在业务执行错误，执行回滚，释放预留的资源。\n- **c.消息事务：**第三种方案是消息一致性方案。基本思路是将本地操作和发送消息放在一个事务中，保证本地操作和消息发送要么都成功要么都失败。下游应用订阅消息，收到消息后执行对应操作。\n- **d.GTS/Fescar：**阿里云中的全局事务服务GTS，对应的开源版本是Fescar。Fescar基于两段式提交进行改良，剥离了分布式事务方案对数据库在协议支持上的要求。使用Fescar的前提是分支事务中涉及的资源，必须是支持ACID事务的关系型数据库。分支的提交和回滚机制，都依赖于本地事务来保障。 Fescar的实现目前还存在一些局限，比如事务隔离级别最高支持到读已提交级别。\n\n# 3. 数据库的范式\n\n前关系数据库有六种范式：第一范式、第二范式、第三范式、巴斯-科德范式（BCNF）、第四范式和第五范式。**范式级别越高对数据表的要求越严格。**\n\n- 第一范式要求最低，只要求表中字段不可用在拆分。\n\n- 第二范式在第一范式的基础上要求每条记录由主键唯一区分，记录中所有属性都依赖于主键。\n\n- 第三范式在第二范式的基础上，要求所有属性必须直接依赖主键，不允许间接依赖。\n\n一般说来，数据库只需满足第三范式就可以了。\n\n# 4. 非关系型数据库和关系型数据库的特点（优缺点）\n\n- RDS:\n  - 特点：\n    1. 关系型数据库的最大特点就是事务的一数性；\n    2. 关系型数据库，是指采用了关系模型来组织数据的数据库；\n    3. 简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织\n  - 优点：\n    1. 容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解\n    2. 使用方便：通用的SQL语言使得操作关系型数据库非常方便，支持很多复杂操作\n    3. 易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率\n  - 缺点：\n    1. 为了维护一致性所付出的巨大代价就是其读写性能比较差\n    2. 每次操作都要进行sql语句的解析，消耗较大\n    3. 关系型数据库往往每一步都要进行加锁的操作，也造成了数据库的负担\n    4. 固定的表结构会使数据的存储不灵活\n    5. 高并发时，读写性能不足\n\n- NoSql：\n  - 特点：\n    1. 使用键值对存储数据；\n    2. 分布式；\n    3. 一般不支持ACID特性；\n    4. 非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合\n  - 优点：\n    1. 高并发，读写能力强\n    2. 基于键值对，数据没有耦合性\n    3. 弱化数据结构一致性，使用灵活，容易扩展，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。\n    4. 存储数据的格式多样：支持文档、图片等等，而关系型数据库则只支持基础类型。\n  - 缺点：\n    1. 通用性差，没有sql语句那样通用的语句，学习成本较高\n    2. 不适合持久存储海量数据\n    3. 没有外键关联、事务处理（这个不一定）等复杂的操作，所以只适合存储一些较为简单的数据。对于需要进行较复杂查询的数据，关系型数据库显的更为合适。\n","source":"_posts/2019/数据库基础知识.md","raw":"---\ntitle: 数据库基础知识\ndate: 2019-04-14 01:01:40\nupdated: 2020-04-04\ntags: 数据库\n---\n\n# 1. 数据库的不同类型\n\n<!-- more -->\n\n## 1.1 常用的关系型数据库\n\n- **Oracle：**功能强大，主要缺点就是贵\n- **MySQL：**互联网行业中最流行的数据库，这不仅仅是因为MySQL的免费。可以说关系数据库场景中你需要的功能，MySQL都能很好的满足，后面详解部分会详细介绍MySQL的一些知识点\n- **MariaDB：**是MySQL的分支，由开源社区维护，MariaDB虽然被看作MySQL的替代品，但它在扩展功能、存储引擎上都有非常好的改进\n- **PostgreSQL：**也叫PGSQL，PGSQL类似于Oracle的多进程框架，可以支持高并发的应用场景，PG几乎支持所有的SQL标准，支持类型相当丰富。PG更加适合严格的企业应用场景，而MySQL更适合业务逻辑相对简单、数据可靠性要求较低的互联网场景。\n\n## 1.2 NoSQL数据库（非关系型数据库）\n\n- **Redis：**提供了持久化能力，支持多种数据类型。Redis适用于数据变化快且数据大小可预测的场景。\n- **MongoDB：**一个基于分布式文件存储的数据库，将数据存储为一个文档，数据结构由键值对组成。MongoDB比较适合表结构不明确，且数据结构可能不断变化的场景，不适合有事务和复杂查询的场景。\n- **HBase：**建立在HDFS，也就是Hadoop文件系统之上的分布式面向列的数据库。类似于谷歌的大表设计，HBase可以提供快速随机访问海量结构化数据。在表中它由行排序，一个表有多个列族以及每一个列族可以有任意数量的列。 HBase依赖HDFS可以实现海量数据的可靠存储，适用于数据量大，写多读少，不需要复杂查询的场景。\n- **Cassandra：**一个高可靠的大规模分布式存储系统。支持分布式的结构化Key-value存储，以高可用性为主要目标。适合写多的场景，适合做一些简单查询，不适合用来做数据分析统计。\n- **Pika：**一个可持久化的大容量类Redis存储服务， 兼容五种主要数据结构的大部分命令。Pika使用磁盘存储，主要解决Redis大容量存储的成本问题。\n\n## 1.3 NewSQL数据库（新一代关系型数据库）\n\n- **TiDB：**开源的分布式关系数据库，几乎完全兼容MySQL，能够支持水平弹性扩展、ACID事务、标准SQL、MySQL语法和MySQL协议，具有数据强一致的高可用特性。既适合在线事务处理，也适合在线分析处理。\n- **OceanBase：**OceanBase是蚂蚁金服的数据库，OB是可以满足金融级的可靠性和数据一致性要求的数据库系统。当你需要使用事务，并且数据量比较大，就比较适合使用OB。不过目前OB已经商业化，不再开源。\n\n# 2. 事务特性及事务类型\n\n## 2.1数据库事务特性（ACID）\n\n数据库共4个特性：\n\n- **原子性：**是指事务由原子的操作序列组成，所有操作要么全部成功，要么全部失败回滚。\n- **一致性：**是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处以一致性状态。比如在做多表操作时，多个表要么都是事务后新的值，要么都是事务前的旧值。\n- **隔离性：**是指多个用户并发访问数据库时，数据库为每个用户执行的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。事务的隔离级别我们稍后介绍。\n- **持久性：**是指一个事务一旦提交并执行成功，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n\n## 2.2 事物并发问题与隔离级别\n\n### 2.2.1 事务并发问题\n\n- **脏读：**脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据，例如，账户A转帐给B500元，B余额增加后但事务还没有提交完成，此时如果另外的请求中获取的是B增加后的余额，这就发生了脏读，因为事务如果失败回滚时，B的余额就不应该增加。\n- **不可重复读：**不可重复读是指对于数据库中某个数据，一个事务范围内多次查询返回了不同的数据值，这是由于在多次查询之间，有其他事务修改了数据并进行了提交。\n- **幻读：**是指一个事务中执行两次完全相同的查询时，第二次查询所返回的结果集跟第一个查询不相同。与不可重复读的区别在于，不可重复读是对同一条记录，两次读取的值不同。而幻读是记录的增加或删除，导致两次相同条件获取的结果记录数不同。\n\n### 2.2.2 事务的四种隔离级别\n\n可以用于解决这几种并发问题。如图右面，由上到下的4种隔离级别由低到高。\n\n- **级别一读未提交：**也就是可以读取到其他事务未提交的内容，这是最低的隔离级别，这个隔离级别下，前面提到的三种并发问题都有可能发生。\n- **级别二读已提交：**就是只能读取到其他事务已经提交的数据。这个隔离级别可以解决脏读问题。\n- **级别三可重复读：**可以保证整个事务过程中，对同数据的多次读取结果是相同的。这个级别可以解决脏读和不可重复读的问题。MySQL默认的隔离级别就是可重复读。\n- **级别四串行化：**这是最高的隔离级别，所有事务操作都依次顺序执行。这个级别会导致并发度下降，性能最差。不过这个级别可以解决前面提到的所有并发问题。\n\n## 2.3 事务分类\n\n共分5大类：\n\n- **扁平化事务：**在扁平事务中，所有的操作都在同一层次，这也是我们平时使用最多的一种事务。它的主要限制是不能提交或者回滚事务的某一部分，要么都成功，要么都回滚。\n- **带保存点的扁平事务：为**了解决第一种事务的弊端，就有了第二种带保存点的扁平事务。它允许事务在执行过程中回滚到较早的状态，而不是全部回滚。通过在事务中插入保存点，当操作失败后，可以选择回滚到最近的保存点处。\n- **链事务：**可以看做是第二种事务的变种。它在事务提交时，会将必要的上下文隐式传递给下一个事务，当事务失败时就可以回滚到最近的事务。不过，链事务只能回滚到最近的保存点，而带保存点的扁平化事务是可以回滚到任意的保存点。\n- **嵌套事务：**由顶层事务和子事务构成，类似于树的结构。一般顶层事务负责逻辑管理，子事务负责具体的工作，子事务可以提交，但真正提交要等到父事务提交，如果上层事务回滚，那么所有的子事务都会回滚。\n- **分布式事务：**是指分布式环境中的扁平化事务。\n\n分布式事务中，常用的解决方案共4种：\n\n- **a.XA协议：**是保证强一致性的刚性事务。实现方式有两段式提交和三段式提交。两段式提交需要有一个事务协调者来保证所有的事务参与者都完成了第一阶段的准备工作。如果协调者收到所有参与者都准备好的消息，就会通知所有的事务执行第二阶段提交。一般场景下两段式提交已经能够很好得解决分布式事务了，然而两阶段在即使只有一个进程发生故障时，也会导致整个系统存在较长时间的阻塞。三段式提交通过增加Pre-commit阶段来减少前面提到的系统阻塞的时间。三段式提交很少在实际中使用，简单了解就可以了。\n- **b.TCC：**是满足最终一致性的柔性事务方案。TCC采用补偿机制，核心思想是对每个操作，都要注册对应的确认和补偿操作。它分为三个阶段：Try阶段主要对业务系统进行检测及资源预留；Confirm阶段对业务系统做确认提交。Cancel阶段是在业务执行错误，执行回滚，释放预留的资源。\n- **c.消息事务：**第三种方案是消息一致性方案。基本思路是将本地操作和发送消息放在一个事务中，保证本地操作和消息发送要么都成功要么都失败。下游应用订阅消息，收到消息后执行对应操作。\n- **d.GTS/Fescar：**阿里云中的全局事务服务GTS，对应的开源版本是Fescar。Fescar基于两段式提交进行改良，剥离了分布式事务方案对数据库在协议支持上的要求。使用Fescar的前提是分支事务中涉及的资源，必须是支持ACID事务的关系型数据库。分支的提交和回滚机制，都依赖于本地事务来保障。 Fescar的实现目前还存在一些局限，比如事务隔离级别最高支持到读已提交级别。\n\n# 3. 数据库的范式\n\n前关系数据库有六种范式：第一范式、第二范式、第三范式、巴斯-科德范式（BCNF）、第四范式和第五范式。**范式级别越高对数据表的要求越严格。**\n\n- 第一范式要求最低，只要求表中字段不可用在拆分。\n\n- 第二范式在第一范式的基础上要求每条记录由主键唯一区分，记录中所有属性都依赖于主键。\n\n- 第三范式在第二范式的基础上，要求所有属性必须直接依赖主键，不允许间接依赖。\n\n一般说来，数据库只需满足第三范式就可以了。\n\n# 4. 非关系型数据库和关系型数据库的特点（优缺点）\n\n- RDS:\n  - 特点：\n    1. 关系型数据库的最大特点就是事务的一数性；\n    2. 关系型数据库，是指采用了关系模型来组织数据的数据库；\n    3. 简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织\n  - 优点：\n    1. 容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解\n    2. 使用方便：通用的SQL语言使得操作关系型数据库非常方便，支持很多复杂操作\n    3. 易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率\n  - 缺点：\n    1. 为了维护一致性所付出的巨大代价就是其读写性能比较差\n    2. 每次操作都要进行sql语句的解析，消耗较大\n    3. 关系型数据库往往每一步都要进行加锁的操作，也造成了数据库的负担\n    4. 固定的表结构会使数据的存储不灵活\n    5. 高并发时，读写性能不足\n\n- NoSql：\n  - 特点：\n    1. 使用键值对存储数据；\n    2. 分布式；\n    3. 一般不支持ACID特性；\n    4. 非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合\n  - 优点：\n    1. 高并发，读写能力强\n    2. 基于键值对，数据没有耦合性\n    3. 弱化数据结构一致性，使用灵活，容易扩展，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。\n    4. 存储数据的格式多样：支持文档、图片等等，而关系型数据库则只支持基础类型。\n  - 缺点：\n    1. 通用性差，没有sql语句那样通用的语句，学习成本较高\n    2. 不适合持久存储海量数据\n    3. 没有外键关联、事务处理（这个不一定）等复杂的操作，所以只适合存储一些较为简单的数据。对于需要进行较复杂查询的数据，关系型数据库显的更为合适。\n","slug":"2019-数据库基础知识","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrk9000y2ykuady37lc1","content":"<h1 id=\"1-数据库的不同类型\"><a href=\"#1-数据库的不同类型\" class=\"headerlink\" title=\"1. 数据库的不同类型\"></a>1. 数据库的不同类型</h1><a id=\"more\"></a>\n\n<h2 id=\"1-1-常用的关系型数据库\"><a href=\"#1-1-常用的关系型数据库\" class=\"headerlink\" title=\"1.1 常用的关系型数据库\"></a>1.1 常用的关系型数据库</h2><ul>\n<li><strong>Oracle：</strong>功能强大，主要缺点就是贵</li>\n<li><strong>MySQL：</strong>互联网行业中最流行的数据库，这不仅仅是因为MySQL的免费。可以说关系数据库场景中你需要的功能，MySQL都能很好的满足，后面详解部分会详细介绍MySQL的一些知识点</li>\n<li><strong>MariaDB：</strong>是MySQL的分支，由开源社区维护，MariaDB虽然被看作MySQL的替代品，但它在扩展功能、存储引擎上都有非常好的改进</li>\n<li><strong>PostgreSQL：</strong>也叫PGSQL，PGSQL类似于Oracle的多进程框架，可以支持高并发的应用场景，PG几乎支持所有的SQL标准，支持类型相当丰富。PG更加适合严格的企业应用场景，而MySQL更适合业务逻辑相对简单、数据可靠性要求较低的互联网场景。</li>\n</ul>\n<h2 id=\"1-2-NoSQL数据库（非关系型数据库）\"><a href=\"#1-2-NoSQL数据库（非关系型数据库）\" class=\"headerlink\" title=\"1.2 NoSQL数据库（非关系型数据库）\"></a>1.2 NoSQL数据库（非关系型数据库）</h2><ul>\n<li><strong>Redis：</strong>提供了持久化能力，支持多种数据类型。Redis适用于数据变化快且数据大小可预测的场景。</li>\n<li><strong>MongoDB：</strong>一个基于分布式文件存储的数据库，将数据存储为一个文档，数据结构由键值对组成。MongoDB比较适合表结构不明确，且数据结构可能不断变化的场景，不适合有事务和复杂查询的场景。</li>\n<li><strong>HBase：</strong>建立在HDFS，也就是Hadoop文件系统之上的分布式面向列的数据库。类似于谷歌的大表设计，HBase可以提供快速随机访问海量结构化数据。在表中它由行排序，一个表有多个列族以及每一个列族可以有任意数量的列。 HBase依赖HDFS可以实现海量数据的可靠存储，适用于数据量大，写多读少，不需要复杂查询的场景。</li>\n<li><strong>Cassandra：</strong>一个高可靠的大规模分布式存储系统。支持分布式的结构化Key-value存储，以高可用性为主要目标。适合写多的场景，适合做一些简单查询，不适合用来做数据分析统计。</li>\n<li><strong>Pika：</strong>一个可持久化的大容量类Redis存储服务， 兼容五种主要数据结构的大部分命令。Pika使用磁盘存储，主要解决Redis大容量存储的成本问题。</li>\n</ul>\n<h2 id=\"1-3-NewSQL数据库（新一代关系型数据库）\"><a href=\"#1-3-NewSQL数据库（新一代关系型数据库）\" class=\"headerlink\" title=\"1.3 NewSQL数据库（新一代关系型数据库）\"></a>1.3 NewSQL数据库（新一代关系型数据库）</h2><ul>\n<li><strong>TiDB：</strong>开源的分布式关系数据库，几乎完全兼容MySQL，能够支持水平弹性扩展、ACID事务、标准SQL、MySQL语法和MySQL协议，具有数据强一致的高可用特性。既适合在线事务处理，也适合在线分析处理。</li>\n<li><strong>OceanBase：</strong>OceanBase是蚂蚁金服的数据库，OB是可以满足金融级的可靠性和数据一致性要求的数据库系统。当你需要使用事务，并且数据量比较大，就比较适合使用OB。不过目前OB已经商业化，不再开源。</li>\n</ul>\n<h1 id=\"2-事务特性及事务类型\"><a href=\"#2-事务特性及事务类型\" class=\"headerlink\" title=\"2. 事务特性及事务类型\"></a>2. 事务特性及事务类型</h1><h2 id=\"2-1数据库事务特性（ACID）\"><a href=\"#2-1数据库事务特性（ACID）\" class=\"headerlink\" title=\"2.1数据库事务特性（ACID）\"></a>2.1数据库事务特性（ACID）</h2><p>数据库共4个特性：</p>\n<ul>\n<li><strong>原子性：</strong>是指事务由原子的操作序列组成，所有操作要么全部成功，要么全部失败回滚。</li>\n<li><strong>一致性：</strong>是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处以一致性状态。比如在做多表操作时，多个表要么都是事务后新的值，要么都是事务前的旧值。</li>\n<li><strong>隔离性：</strong>是指多个用户并发访问数据库时，数据库为每个用户执行的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。事务的隔离级别我们稍后介绍。</li>\n<li><strong>持久性：</strong>是指一个事务一旦提交并执行成功，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>\n</ul>\n<h2 id=\"2-2-事物并发问题与隔离级别\"><a href=\"#2-2-事物并发问题与隔离级别\" class=\"headerlink\" title=\"2.2 事物并发问题与隔离级别\"></a>2.2 事物并发问题与隔离级别</h2><h3 id=\"2-2-1-事务并发问题\"><a href=\"#2-2-1-事务并发问题\" class=\"headerlink\" title=\"2.2.1 事务并发问题\"></a>2.2.1 事务并发问题</h3><ul>\n<li><strong>脏读：</strong>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据，例如，账户A转帐给B500元，B余额增加后但事务还没有提交完成，此时如果另外的请求中获取的是B增加后的余额，这就发生了脏读，因为事务如果失败回滚时，B的余额就不应该增加。</li>\n<li><strong>不可重复读：</strong>不可重复读是指对于数据库中某个数据，一个事务范围内多次查询返回了不同的数据值，这是由于在多次查询之间，有其他事务修改了数据并进行了提交。</li>\n<li><strong>幻读：</strong>是指一个事务中执行两次完全相同的查询时，第二次查询所返回的结果集跟第一个查询不相同。与不可重复读的区别在于，不可重复读是对同一条记录，两次读取的值不同。而幻读是记录的增加或删除，导致两次相同条件获取的结果记录数不同。</li>\n</ul>\n<h3 id=\"2-2-2-事务的四种隔离级别\"><a href=\"#2-2-2-事务的四种隔离级别\" class=\"headerlink\" title=\"2.2.2 事务的四种隔离级别\"></a>2.2.2 事务的四种隔离级别</h3><p>可以用于解决这几种并发问题。如图右面，由上到下的4种隔离级别由低到高。</p>\n<ul>\n<li><strong>级别一读未提交：</strong>也就是可以读取到其他事务未提交的内容，这是最低的隔离级别，这个隔离级别下，前面提到的三种并发问题都有可能发生。</li>\n<li><strong>级别二读已提交：</strong>就是只能读取到其他事务已经提交的数据。这个隔离级别可以解决脏读问题。</li>\n<li><strong>级别三可重复读：</strong>可以保证整个事务过程中，对同数据的多次读取结果是相同的。这个级别可以解决脏读和不可重复读的问题。MySQL默认的隔离级别就是可重复读。</li>\n<li><strong>级别四串行化：</strong>这是最高的隔离级别，所有事务操作都依次顺序执行。这个级别会导致并发度下降，性能最差。不过这个级别可以解决前面提到的所有并发问题。</li>\n</ul>\n<h2 id=\"2-3-事务分类\"><a href=\"#2-3-事务分类\" class=\"headerlink\" title=\"2.3 事务分类\"></a>2.3 事务分类</h2><p>共分5大类：</p>\n<ul>\n<li><strong>扁平化事务：</strong>在扁平事务中，所有的操作都在同一层次，这也是我们平时使用最多的一种事务。它的主要限制是不能提交或者回滚事务的某一部分，要么都成功，要么都回滚。</li>\n<li><strong>带保存点的扁平事务：为</strong>了解决第一种事务的弊端，就有了第二种带保存点的扁平事务。它允许事务在执行过程中回滚到较早的状态，而不是全部回滚。通过在事务中插入保存点，当操作失败后，可以选择回滚到最近的保存点处。</li>\n<li><strong>链事务：</strong>可以看做是第二种事务的变种。它在事务提交时，会将必要的上下文隐式传递给下一个事务，当事务失败时就可以回滚到最近的事务。不过，链事务只能回滚到最近的保存点，而带保存点的扁平化事务是可以回滚到任意的保存点。</li>\n<li><strong>嵌套事务：</strong>由顶层事务和子事务构成，类似于树的结构。一般顶层事务负责逻辑管理，子事务负责具体的工作，子事务可以提交，但真正提交要等到父事务提交，如果上层事务回滚，那么所有的子事务都会回滚。</li>\n<li><strong>分布式事务：</strong>是指分布式环境中的扁平化事务。</li>\n</ul>\n<p>分布式事务中，常用的解决方案共4种：</p>\n<ul>\n<li><strong>a.XA协议：</strong>是保证强一致性的刚性事务。实现方式有两段式提交和三段式提交。两段式提交需要有一个事务协调者来保证所有的事务参与者都完成了第一阶段的准备工作。如果协调者收到所有参与者都准备好的消息，就会通知所有的事务执行第二阶段提交。一般场景下两段式提交已经能够很好得解决分布式事务了，然而两阶段在即使只有一个进程发生故障时，也会导致整个系统存在较长时间的阻塞。三段式提交通过增加Pre-commit阶段来减少前面提到的系统阻塞的时间。三段式提交很少在实际中使用，简单了解就可以了。</li>\n<li><strong>b.TCC：</strong>是满足最终一致性的柔性事务方案。TCC采用补偿机制，核心思想是对每个操作，都要注册对应的确认和补偿操作。它分为三个阶段：Try阶段主要对业务系统进行检测及资源预留；Confirm阶段对业务系统做确认提交。Cancel阶段是在业务执行错误，执行回滚，释放预留的资源。</li>\n<li><strong>c.消息事务：</strong>第三种方案是消息一致性方案。基本思路是将本地操作和发送消息放在一个事务中，保证本地操作和消息发送要么都成功要么都失败。下游应用订阅消息，收到消息后执行对应操作。</li>\n<li><strong>d.GTS/Fescar：</strong>阿里云中的全局事务服务GTS，对应的开源版本是Fescar。Fescar基于两段式提交进行改良，剥离了分布式事务方案对数据库在协议支持上的要求。使用Fescar的前提是分支事务中涉及的资源，必须是支持ACID事务的关系型数据库。分支的提交和回滚机制，都依赖于本地事务来保障。 Fescar的实现目前还存在一些局限，比如事务隔离级别最高支持到读已提交级别。</li>\n</ul>\n<h1 id=\"3-数据库的范式\"><a href=\"#3-数据库的范式\" class=\"headerlink\" title=\"3. 数据库的范式\"></a>3. 数据库的范式</h1><p>前关系数据库有六种范式：第一范式、第二范式、第三范式、巴斯-科德范式（BCNF）、第四范式和第五范式。<strong>范式级别越高对数据表的要求越严格。</strong></p>\n<ul>\n<li><p>第一范式要求最低，只要求表中字段不可用在拆分。</p>\n</li>\n<li><p>第二范式在第一范式的基础上要求每条记录由主键唯一区分，记录中所有属性都依赖于主键。</p>\n</li>\n<li><p>第三范式在第二范式的基础上，要求所有属性必须直接依赖主键，不允许间接依赖。</p>\n</li>\n</ul>\n<p>一般说来，数据库只需满足第三范式就可以了。</p>\n<h1 id=\"4-非关系型数据库和关系型数据库的特点（优缺点）\"><a href=\"#4-非关系型数据库和关系型数据库的特点（优缺点）\" class=\"headerlink\" title=\"4. 非关系型数据库和关系型数据库的特点（优缺点）\"></a>4. 非关系型数据库和关系型数据库的特点（优缺点）</h1><ul>\n<li><p>RDS:</p>\n<ul>\n<li>特点：<ol>\n<li>关系型数据库的最大特点就是事务的一数性；</li>\n<li>关系型数据库，是指采用了关系模型来组织数据的数据库；</li>\n<li>简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织</li>\n</ol>\n</li>\n<li>优点：<ol>\n<li>容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解</li>\n<li>使用方便：通用的SQL语言使得操作关系型数据库非常方便，支持很多复杂操作</li>\n<li>易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率</li>\n</ol>\n</li>\n<li>缺点：<ol>\n<li>为了维护一致性所付出的巨大代价就是其读写性能比较差</li>\n<li>每次操作都要进行sql语句的解析，消耗较大</li>\n<li>关系型数据库往往每一步都要进行加锁的操作，也造成了数据库的负担</li>\n<li>固定的表结构会使数据的存储不灵活</li>\n<li>高并发时，读写性能不足</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>NoSql：</p>\n<ul>\n<li>特点：<ol>\n<li>使用键值对存储数据；</li>\n<li>分布式；</li>\n<li>一般不支持ACID特性；</li>\n<li>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合</li>\n</ol>\n</li>\n<li>优点：<ol>\n<li>高并发，读写能力强</li>\n<li>基于键值对，数据没有耦合性</li>\n<li>弱化数据结构一致性，使用灵活，容易扩展，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。</li>\n<li>存储数据的格式多样：支持文档、图片等等，而关系型数据库则只支持基础类型。</li>\n</ol>\n</li>\n<li>缺点：<ol>\n<li>通用性差，没有sql语句那样通用的语句，学习成本较高</li>\n<li>不适合持久存储海量数据</li>\n<li>没有外键关联、事务处理（这个不一定）等复杂的操作，所以只适合存储一些较为简单的数据。对于需要进行较复杂查询的数据，关系型数据库显的更为合适。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-数据库的不同类型\"><a href=\"#1-数据库的不同类型\" class=\"headerlink\" title=\"1. 数据库的不同类型\"></a>1. 数据库的不同类型</h1>","more":"<h2 id=\"1-1-常用的关系型数据库\"><a href=\"#1-1-常用的关系型数据库\" class=\"headerlink\" title=\"1.1 常用的关系型数据库\"></a>1.1 常用的关系型数据库</h2><ul>\n<li><strong>Oracle：</strong>功能强大，主要缺点就是贵</li>\n<li><strong>MySQL：</strong>互联网行业中最流行的数据库，这不仅仅是因为MySQL的免费。可以说关系数据库场景中你需要的功能，MySQL都能很好的满足，后面详解部分会详细介绍MySQL的一些知识点</li>\n<li><strong>MariaDB：</strong>是MySQL的分支，由开源社区维护，MariaDB虽然被看作MySQL的替代品，但它在扩展功能、存储引擎上都有非常好的改进</li>\n<li><strong>PostgreSQL：</strong>也叫PGSQL，PGSQL类似于Oracle的多进程框架，可以支持高并发的应用场景，PG几乎支持所有的SQL标准，支持类型相当丰富。PG更加适合严格的企业应用场景，而MySQL更适合业务逻辑相对简单、数据可靠性要求较低的互联网场景。</li>\n</ul>\n<h2 id=\"1-2-NoSQL数据库（非关系型数据库）\"><a href=\"#1-2-NoSQL数据库（非关系型数据库）\" class=\"headerlink\" title=\"1.2 NoSQL数据库（非关系型数据库）\"></a>1.2 NoSQL数据库（非关系型数据库）</h2><ul>\n<li><strong>Redis：</strong>提供了持久化能力，支持多种数据类型。Redis适用于数据变化快且数据大小可预测的场景。</li>\n<li><strong>MongoDB：</strong>一个基于分布式文件存储的数据库，将数据存储为一个文档，数据结构由键值对组成。MongoDB比较适合表结构不明确，且数据结构可能不断变化的场景，不适合有事务和复杂查询的场景。</li>\n<li><strong>HBase：</strong>建立在HDFS，也就是Hadoop文件系统之上的分布式面向列的数据库。类似于谷歌的大表设计，HBase可以提供快速随机访问海量结构化数据。在表中它由行排序，一个表有多个列族以及每一个列族可以有任意数量的列。 HBase依赖HDFS可以实现海量数据的可靠存储，适用于数据量大，写多读少，不需要复杂查询的场景。</li>\n<li><strong>Cassandra：</strong>一个高可靠的大规模分布式存储系统。支持分布式的结构化Key-value存储，以高可用性为主要目标。适合写多的场景，适合做一些简单查询，不适合用来做数据分析统计。</li>\n<li><strong>Pika：</strong>一个可持久化的大容量类Redis存储服务， 兼容五种主要数据结构的大部分命令。Pika使用磁盘存储，主要解决Redis大容量存储的成本问题。</li>\n</ul>\n<h2 id=\"1-3-NewSQL数据库（新一代关系型数据库）\"><a href=\"#1-3-NewSQL数据库（新一代关系型数据库）\" class=\"headerlink\" title=\"1.3 NewSQL数据库（新一代关系型数据库）\"></a>1.3 NewSQL数据库（新一代关系型数据库）</h2><ul>\n<li><strong>TiDB：</strong>开源的分布式关系数据库，几乎完全兼容MySQL，能够支持水平弹性扩展、ACID事务、标准SQL、MySQL语法和MySQL协议，具有数据强一致的高可用特性。既适合在线事务处理，也适合在线分析处理。</li>\n<li><strong>OceanBase：</strong>OceanBase是蚂蚁金服的数据库，OB是可以满足金融级的可靠性和数据一致性要求的数据库系统。当你需要使用事务，并且数据量比较大，就比较适合使用OB。不过目前OB已经商业化，不再开源。</li>\n</ul>\n<h1 id=\"2-事务特性及事务类型\"><a href=\"#2-事务特性及事务类型\" class=\"headerlink\" title=\"2. 事务特性及事务类型\"></a>2. 事务特性及事务类型</h1><h2 id=\"2-1数据库事务特性（ACID）\"><a href=\"#2-1数据库事务特性（ACID）\" class=\"headerlink\" title=\"2.1数据库事务特性（ACID）\"></a>2.1数据库事务特性（ACID）</h2><p>数据库共4个特性：</p>\n<ul>\n<li><strong>原子性：</strong>是指事务由原子的操作序列组成，所有操作要么全部成功，要么全部失败回滚。</li>\n<li><strong>一致性：</strong>是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处以一致性状态。比如在做多表操作时，多个表要么都是事务后新的值，要么都是事务前的旧值。</li>\n<li><strong>隔离性：</strong>是指多个用户并发访问数据库时，数据库为每个用户执行的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。事务的隔离级别我们稍后介绍。</li>\n<li><strong>持久性：</strong>是指一个事务一旦提交并执行成功，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>\n</ul>\n<h2 id=\"2-2-事物并发问题与隔离级别\"><a href=\"#2-2-事物并发问题与隔离级别\" class=\"headerlink\" title=\"2.2 事物并发问题与隔离级别\"></a>2.2 事物并发问题与隔离级别</h2><h3 id=\"2-2-1-事务并发问题\"><a href=\"#2-2-1-事务并发问题\" class=\"headerlink\" title=\"2.2.1 事务并发问题\"></a>2.2.1 事务并发问题</h3><ul>\n<li><strong>脏读：</strong>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据，例如，账户A转帐给B500元，B余额增加后但事务还没有提交完成，此时如果另外的请求中获取的是B增加后的余额，这就发生了脏读，因为事务如果失败回滚时，B的余额就不应该增加。</li>\n<li><strong>不可重复读：</strong>不可重复读是指对于数据库中某个数据，一个事务范围内多次查询返回了不同的数据值，这是由于在多次查询之间，有其他事务修改了数据并进行了提交。</li>\n<li><strong>幻读：</strong>是指一个事务中执行两次完全相同的查询时，第二次查询所返回的结果集跟第一个查询不相同。与不可重复读的区别在于，不可重复读是对同一条记录，两次读取的值不同。而幻读是记录的增加或删除，导致两次相同条件获取的结果记录数不同。</li>\n</ul>\n<h3 id=\"2-2-2-事务的四种隔离级别\"><a href=\"#2-2-2-事务的四种隔离级别\" class=\"headerlink\" title=\"2.2.2 事务的四种隔离级别\"></a>2.2.2 事务的四种隔离级别</h3><p>可以用于解决这几种并发问题。如图右面，由上到下的4种隔离级别由低到高。</p>\n<ul>\n<li><strong>级别一读未提交：</strong>也就是可以读取到其他事务未提交的内容，这是最低的隔离级别，这个隔离级别下，前面提到的三种并发问题都有可能发生。</li>\n<li><strong>级别二读已提交：</strong>就是只能读取到其他事务已经提交的数据。这个隔离级别可以解决脏读问题。</li>\n<li><strong>级别三可重复读：</strong>可以保证整个事务过程中，对同数据的多次读取结果是相同的。这个级别可以解决脏读和不可重复读的问题。MySQL默认的隔离级别就是可重复读。</li>\n<li><strong>级别四串行化：</strong>这是最高的隔离级别，所有事务操作都依次顺序执行。这个级别会导致并发度下降，性能最差。不过这个级别可以解决前面提到的所有并发问题。</li>\n</ul>\n<h2 id=\"2-3-事务分类\"><a href=\"#2-3-事务分类\" class=\"headerlink\" title=\"2.3 事务分类\"></a>2.3 事务分类</h2><p>共分5大类：</p>\n<ul>\n<li><strong>扁平化事务：</strong>在扁平事务中，所有的操作都在同一层次，这也是我们平时使用最多的一种事务。它的主要限制是不能提交或者回滚事务的某一部分，要么都成功，要么都回滚。</li>\n<li><strong>带保存点的扁平事务：为</strong>了解决第一种事务的弊端，就有了第二种带保存点的扁平事务。它允许事务在执行过程中回滚到较早的状态，而不是全部回滚。通过在事务中插入保存点，当操作失败后，可以选择回滚到最近的保存点处。</li>\n<li><strong>链事务：</strong>可以看做是第二种事务的变种。它在事务提交时，会将必要的上下文隐式传递给下一个事务，当事务失败时就可以回滚到最近的事务。不过，链事务只能回滚到最近的保存点，而带保存点的扁平化事务是可以回滚到任意的保存点。</li>\n<li><strong>嵌套事务：</strong>由顶层事务和子事务构成，类似于树的结构。一般顶层事务负责逻辑管理，子事务负责具体的工作，子事务可以提交，但真正提交要等到父事务提交，如果上层事务回滚，那么所有的子事务都会回滚。</li>\n<li><strong>分布式事务：</strong>是指分布式环境中的扁平化事务。</li>\n</ul>\n<p>分布式事务中，常用的解决方案共4种：</p>\n<ul>\n<li><strong>a.XA协议：</strong>是保证强一致性的刚性事务。实现方式有两段式提交和三段式提交。两段式提交需要有一个事务协调者来保证所有的事务参与者都完成了第一阶段的准备工作。如果协调者收到所有参与者都准备好的消息，就会通知所有的事务执行第二阶段提交。一般场景下两段式提交已经能够很好得解决分布式事务了，然而两阶段在即使只有一个进程发生故障时，也会导致整个系统存在较长时间的阻塞。三段式提交通过增加Pre-commit阶段来减少前面提到的系统阻塞的时间。三段式提交很少在实际中使用，简单了解就可以了。</li>\n<li><strong>b.TCC：</strong>是满足最终一致性的柔性事务方案。TCC采用补偿机制，核心思想是对每个操作，都要注册对应的确认和补偿操作。它分为三个阶段：Try阶段主要对业务系统进行检测及资源预留；Confirm阶段对业务系统做确认提交。Cancel阶段是在业务执行错误，执行回滚，释放预留的资源。</li>\n<li><strong>c.消息事务：</strong>第三种方案是消息一致性方案。基本思路是将本地操作和发送消息放在一个事务中，保证本地操作和消息发送要么都成功要么都失败。下游应用订阅消息，收到消息后执行对应操作。</li>\n<li><strong>d.GTS/Fescar：</strong>阿里云中的全局事务服务GTS，对应的开源版本是Fescar。Fescar基于两段式提交进行改良，剥离了分布式事务方案对数据库在协议支持上的要求。使用Fescar的前提是分支事务中涉及的资源，必须是支持ACID事务的关系型数据库。分支的提交和回滚机制，都依赖于本地事务来保障。 Fescar的实现目前还存在一些局限，比如事务隔离级别最高支持到读已提交级别。</li>\n</ul>\n<h1 id=\"3-数据库的范式\"><a href=\"#3-数据库的范式\" class=\"headerlink\" title=\"3. 数据库的范式\"></a>3. 数据库的范式</h1><p>前关系数据库有六种范式：第一范式、第二范式、第三范式、巴斯-科德范式（BCNF）、第四范式和第五范式。<strong>范式级别越高对数据表的要求越严格。</strong></p>\n<ul>\n<li><p>第一范式要求最低，只要求表中字段不可用在拆分。</p>\n</li>\n<li><p>第二范式在第一范式的基础上要求每条记录由主键唯一区分，记录中所有属性都依赖于主键。</p>\n</li>\n<li><p>第三范式在第二范式的基础上，要求所有属性必须直接依赖主键，不允许间接依赖。</p>\n</li>\n</ul>\n<p>一般说来，数据库只需满足第三范式就可以了。</p>\n<h1 id=\"4-非关系型数据库和关系型数据库的特点（优缺点）\"><a href=\"#4-非关系型数据库和关系型数据库的特点（优缺点）\" class=\"headerlink\" title=\"4. 非关系型数据库和关系型数据库的特点（优缺点）\"></a>4. 非关系型数据库和关系型数据库的特点（优缺点）</h1><ul>\n<li><p>RDS:</p>\n<ul>\n<li>特点：<ol>\n<li>关系型数据库的最大特点就是事务的一数性；</li>\n<li>关系型数据库，是指采用了关系模型来组织数据的数据库；</li>\n<li>简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织</li>\n</ol>\n</li>\n<li>优点：<ol>\n<li>容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解</li>\n<li>使用方便：通用的SQL语言使得操作关系型数据库非常方便，支持很多复杂操作</li>\n<li>易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率</li>\n</ol>\n</li>\n<li>缺点：<ol>\n<li>为了维护一致性所付出的巨大代价就是其读写性能比较差</li>\n<li>每次操作都要进行sql语句的解析，消耗较大</li>\n<li>关系型数据库往往每一步都要进行加锁的操作，也造成了数据库的负担</li>\n<li>固定的表结构会使数据的存储不灵活</li>\n<li>高并发时，读写性能不足</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>NoSql：</p>\n<ul>\n<li>特点：<ol>\n<li>使用键值对存储数据；</li>\n<li>分布式；</li>\n<li>一般不支持ACID特性；</li>\n<li>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合</li>\n</ol>\n</li>\n<li>优点：<ol>\n<li>高并发，读写能力强</li>\n<li>基于键值对，数据没有耦合性</li>\n<li>弱化数据结构一致性，使用灵活，容易扩展，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。</li>\n<li>存储数据的格式多样：支持文档、图片等等，而关系型数据库则只支持基础类型。</li>\n</ol>\n</li>\n<li>缺点：<ol>\n<li>通用性差，没有sql语句那样通用的语句，学习成本较高</li>\n<li>不适合持久存储海量数据</li>\n<li>没有外键关联、事务处理（这个不一定）等复杂的操作，所以只适合存储一些较为简单的数据。对于需要进行较复杂查询的数据，关系型数据库显的更为合适。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"树【未完待续】","date":"2019-03-25T18:02:09.000Z","updated":"2019-03-25T18:02:09.000Z","_content":"二叉树、二叉查找树、2-3查找树、字典树（trie树）、平衡树（AVL树）、红黑树、B~树（B树、B+树、B*树）、R树...\n网上的资料过于复杂，且发现很多错误，所以打算自己重新总结一次。\n\n<!-- more -->\n\n# B~树\n\n插入或者删除元素都会导致节点发生裂变反应，有时候会非常麻烦，但正因为如此才让B树能够始终保持多路平衡，这也是B树自身的一个优势：自平衡；B树主要应用于文件系统以及部分数据库索引，如MongoDB，大部分关系型数据库索引则是使用B+树实现。\n\n## B树\n\n最坏的情况下磁盘IO的次数由树的高度来决定，减少磁盘IO的次数就必须要压缩树的高度，让瘦高的树尽量变成矮胖的树，所以B-Tree就这样诞生了。\n\nm阶B-Tree满足以下条件：\n1. 每个节点最多拥有m个子树\n2. 根节点至少有2个子树\n3. 分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）\n4. 所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列\n\n## B+树\n\nB+Tree是B树的变种，有着比B树更高的查询性能，来看下m阶B+Tree特征：\n\n1、有m个子树的节点包含有m个元素（B-Tree中是m-1）\n\n2、根节点和分支节点中不保存数据，只用于索引，所有数据都保存在叶子节点中。\n\n3、所有分支节点和根节点都同时存在于子节点中，在子节点元素中是最大或者最小的元素。\n\n4、叶子节点会包含所有的关键字，以及指向数据记录的指针，并且叶子节点本身是根据关键字的大小从小到大顺序链接。\n\nB+树的优势：\n1.单节点可以存储更多的元素，使得查询磁盘IO次数更少。\n2.所有查询都要查找到叶子节点，查询性能稳定。\n1. 更加高效的单元素查找\n2. 叶子节点形成有顺链表，范围查找性能更优\n## B*树\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 参考资料：\n\n> 什么是B-Tree：https://www.cnblogs.com/dongguacai/p/7239599.html\n> 什么是B+Tree：https://www.cnblogs.com/dongguacai/p/7241860.html\n> ","source":"_posts/2019/树.md","raw":"---\ntitle: 树【未完待续】\ndate: 2019-03-26 02:02:09\nupdated: 2019-03-26 02:02:09\ntags: 数据结构\n---\n二叉树、二叉查找树、2-3查找树、字典树（trie树）、平衡树（AVL树）、红黑树、B~树（B树、B+树、B*树）、R树...\n网上的资料过于复杂，且发现很多错误，所以打算自己重新总结一次。\n\n<!-- more -->\n\n# B~树\n\n插入或者删除元素都会导致节点发生裂变反应，有时候会非常麻烦，但正因为如此才让B树能够始终保持多路平衡，这也是B树自身的一个优势：自平衡；B树主要应用于文件系统以及部分数据库索引，如MongoDB，大部分关系型数据库索引则是使用B+树实现。\n\n## B树\n\n最坏的情况下磁盘IO的次数由树的高度来决定，减少磁盘IO的次数就必须要压缩树的高度，让瘦高的树尽量变成矮胖的树，所以B-Tree就这样诞生了。\n\nm阶B-Tree满足以下条件：\n1. 每个节点最多拥有m个子树\n2. 根节点至少有2个子树\n3. 分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）\n4. 所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列\n\n## B+树\n\nB+Tree是B树的变种，有着比B树更高的查询性能，来看下m阶B+Tree特征：\n\n1、有m个子树的节点包含有m个元素（B-Tree中是m-1）\n\n2、根节点和分支节点中不保存数据，只用于索引，所有数据都保存在叶子节点中。\n\n3、所有分支节点和根节点都同时存在于子节点中，在子节点元素中是最大或者最小的元素。\n\n4、叶子节点会包含所有的关键字，以及指向数据记录的指针，并且叶子节点本身是根据关键字的大小从小到大顺序链接。\n\nB+树的优势：\n1.单节点可以存储更多的元素，使得查询磁盘IO次数更少。\n2.所有查询都要查找到叶子节点，查询性能稳定。\n1. 更加高效的单元素查找\n2. 叶子节点形成有顺链表，范围查找性能更优\n## B*树\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 参考资料：\n\n> 什么是B-Tree：https://www.cnblogs.com/dongguacai/p/7239599.html\n> 什么是B+Tree：https://www.cnblogs.com/dongguacai/p/7241860.html\n> ","slug":"2019-树","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrka00102yku6sqlbrb0","content":"<p>二叉树、二叉查找树、2-3查找树、字典树（trie树）、平衡树（AVL树）、红黑树、B~树（B树、B+树、B*树）、R树…<br>网上的资料过于复杂，且发现很多错误，所以打算自己重新总结一次。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B~树\"></a>B~树</h1><p>插入或者删除元素都会导致节点发生裂变反应，有时候会非常麻烦，但正因为如此才让B树能够始终保持多路平衡，这也是B树自身的一个优势：自平衡；B树主要应用于文件系统以及部分数据库索引，如MongoDB，大部分关系型数据库索引则是使用B+树实现。</p>\n<h2 id=\"B树\"><a href=\"#B树\" class=\"headerlink\" title=\"B树\"></a>B树</h2><p>最坏的情况下磁盘IO的次数由树的高度来决定，减少磁盘IO的次数就必须要压缩树的高度，让瘦高的树尽量变成矮胖的树，所以B-Tree就这样诞生了。</p>\n<p>m阶B-Tree满足以下条件：</p>\n<ol>\n<li>每个节点最多拥有m个子树</li>\n<li>根节点至少有2个子树</li>\n<li>分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）</li>\n<li>所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列</li>\n</ol>\n<h2 id=\"B-树-1\"><a href=\"#B-树-1\" class=\"headerlink\" title=\"B+树\"></a>B+树</h2><p>B+Tree是B树的变种，有着比B树更高的查询性能，来看下m阶B+Tree特征：</p>\n<p>1、有m个子树的节点包含有m个元素（B-Tree中是m-1）</p>\n<p>2、根节点和分支节点中不保存数据，只用于索引，所有数据都保存在叶子节点中。</p>\n<p>3、所有分支节点和根节点都同时存在于子节点中，在子节点元素中是最大或者最小的元素。</p>\n<p>4、叶子节点会包含所有的关键字，以及指向数据记录的指针，并且叶子节点本身是根据关键字的大小从小到大顺序链接。</p>\n<p>B+树的优势：<br>1.单节点可以存储更多的元素，使得查询磁盘IO次数更少。<br>2.所有查询都要查找到叶子节点，查询性能稳定。</p>\n<ol>\n<li>更加高效的单元素查找</li>\n<li>叶子节点形成有顺链表，范围查找性能更优<h2 id=\"B-树-2\"><a href=\"#B-树-2\" class=\"headerlink\" title=\"B*树\"></a>B*树</h2></li>\n</ol>\n<h1 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h1><blockquote>\n<p>什么是B-Tree：<a href=\"https://www.cnblogs.com/dongguacai/p/7239599.html\">https://www.cnblogs.com/dongguacai/p/7239599.html</a><br>什么是B+Tree：<a href=\"https://www.cnblogs.com/dongguacai/p/7241860.html\">https://www.cnblogs.com/dongguacai/p/7241860.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>二叉树、二叉查找树、2-3查找树、字典树（trie树）、平衡树（AVL树）、红黑树、B~树（B树、B+树、B*树）、R树…<br>网上的资料过于复杂，且发现很多错误，所以打算自己重新总结一次。</p>","more":"<h1 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B~树\"></a>B~树</h1><p>插入或者删除元素都会导致节点发生裂变反应，有时候会非常麻烦，但正因为如此才让B树能够始终保持多路平衡，这也是B树自身的一个优势：自平衡；B树主要应用于文件系统以及部分数据库索引，如MongoDB，大部分关系型数据库索引则是使用B+树实现。</p>\n<h2 id=\"B树\"><a href=\"#B树\" class=\"headerlink\" title=\"B树\"></a>B树</h2><p>最坏的情况下磁盘IO的次数由树的高度来决定，减少磁盘IO的次数就必须要压缩树的高度，让瘦高的树尽量变成矮胖的树，所以B-Tree就这样诞生了。</p>\n<p>m阶B-Tree满足以下条件：</p>\n<ol>\n<li>每个节点最多拥有m个子树</li>\n<li>根节点至少有2个子树</li>\n<li>分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）</li>\n<li>所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列</li>\n</ol>\n<h2 id=\"B-树-1\"><a href=\"#B-树-1\" class=\"headerlink\" title=\"B+树\"></a>B+树</h2><p>B+Tree是B树的变种，有着比B树更高的查询性能，来看下m阶B+Tree特征：</p>\n<p>1、有m个子树的节点包含有m个元素（B-Tree中是m-1）</p>\n<p>2、根节点和分支节点中不保存数据，只用于索引，所有数据都保存在叶子节点中。</p>\n<p>3、所有分支节点和根节点都同时存在于子节点中，在子节点元素中是最大或者最小的元素。</p>\n<p>4、叶子节点会包含所有的关键字，以及指向数据记录的指针，并且叶子节点本身是根据关键字的大小从小到大顺序链接。</p>\n<p>B+树的优势：<br>1.单节点可以存储更多的元素，使得查询磁盘IO次数更少。<br>2.所有查询都要查找到叶子节点，查询性能稳定。</p>\n<ol>\n<li>更加高效的单元素查找</li>\n<li>叶子节点形成有顺链表，范围查找性能更优<h2 id=\"B-树-2\"><a href=\"#B-树-2\" class=\"headerlink\" title=\"B*树\"></a>B*树</h2></li>\n</ol>\n<h1 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h1><blockquote>\n<p>什么是B-Tree：<a href=\"https://www.cnblogs.com/dongguacai/p/7239599.html\">https://www.cnblogs.com/dongguacai/p/7239599.html</a><br>什么是B+Tree：<a href=\"https://www.cnblogs.com/dongguacai/p/7241860.html\">https://www.cnblogs.com/dongguacai/p/7241860.html</a></p>\n</blockquote>"},{"title":"Node.js 递归遍历文件夹并返回带路径的文件名数组","date":"2019-12-11T16:00:00.000Z","updated":"2019-12-11T16:00:00.000Z","_content":"\nNode.js 递归遍历文件夹并返回带路径的文件名数组\n\n<!-- more -->\n```javascript\nconst fs = require('fs');\n\nconst nameArr = traversingFoldersSync('./dist');\nconsole.log(nameArr);\n\nfunction traversingFoldersSync(path) {\n  let fileArr = [];\n  let pa = fs.readdirSync(path);\n  pa.forEach(function (ele, index) {\n    let info = fs.statSync(path + \"/\" + ele);\n    if (info.isDirectory()) {\n      // console.log(\"dir: \" + ele)\n      fileArr = fileArr.concat(traversingFoldersSync(path + \"/\" + ele));\n    } else {\n      // console.log(\"file: \" +path + \"/\"+ ele);\n      fileArr.push(path + \"/\"+ ele);\n    }\n  })\n  return fileArr;\n}\n```\n","source":"_posts/2019/递归文件夹并返回带路径的文件名数组.md","raw":"---\ntitle: Node.js 递归遍历文件夹并返回带路径的文件名数组\ndate: 2019-12-12\nupdated: 2019-12-12\ntags: JS\n---\n\nNode.js 递归遍历文件夹并返回带路径的文件名数组\n\n<!-- more -->\n```javascript\nconst fs = require('fs');\n\nconst nameArr = traversingFoldersSync('./dist');\nconsole.log(nameArr);\n\nfunction traversingFoldersSync(path) {\n  let fileArr = [];\n  let pa = fs.readdirSync(path);\n  pa.forEach(function (ele, index) {\n    let info = fs.statSync(path + \"/\" + ele);\n    if (info.isDirectory()) {\n      // console.log(\"dir: \" + ele)\n      fileArr = fileArr.concat(traversingFoldersSync(path + \"/\" + ele));\n    } else {\n      // console.log(\"file: \" +path + \"/\"+ ele);\n      fileArr.push(path + \"/\"+ ele);\n    }\n  })\n  return fileArr;\n}\n```\n","slug":"2019-递归文件夹并返回带路径的文件名数组","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkb00132ykudf0fef8x","content":"<p>Node.js 递归遍历文件夹并返回带路径的文件名数组</p>\n<a id=\"more\"></a>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> nameArr = traversingFoldersSync(<span class=\"string\">&#x27;./dist&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nameArr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traversingFoldersSync</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fileArr = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pa = fs.readdirSync(path);</span><br><span class=\"line\">  pa.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ele, index</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> info = fs.statSync(path + <span class=\"string\">&quot;/&quot;</span> + ele);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (info.isDirectory()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// console.log(&quot;dir: &quot; + ele)</span></span><br><span class=\"line\">      fileArr = fileArr.concat(traversingFoldersSync(path + <span class=\"string\">&quot;/&quot;</span> + ele));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// console.log(&quot;file: &quot; +path + &quot;/&quot;+ ele);</span></span><br><span class=\"line\">      fileArr.push(path + <span class=\"string\">&quot;/&quot;</span>+ ele);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fileArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Node.js 递归遍历文件夹并返回带路径的文件名数组</p>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> nameArr = traversingFoldersSync(<span class=\"string\">&#x27;./dist&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nameArr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traversingFoldersSync</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fileArr = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pa = fs.readdirSync(path);</span><br><span class=\"line\">  pa.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ele, index</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> info = fs.statSync(path + <span class=\"string\">&quot;/&quot;</span> + ele);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (info.isDirectory()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// console.log(&quot;dir: &quot; + ele)</span></span><br><span class=\"line\">      fileArr = fileArr.concat(traversingFoldersSync(path + <span class=\"string\">&quot;/&quot;</span> + ele));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// console.log(&quot;file: &quot; +path + &quot;/&quot;+ ele);</span></span><br><span class=\"line\">      fileArr.push(path + <span class=\"string\">&quot;/&quot;</span>+ ele);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fileArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"淘宝数据中期设计与重构计划","date":"2021-02-08T03:27:23.000Z","updated":"2021-02-07T03:27:23.000Z","_content":"\n# 前言\n淘宝数据已经走到了一个转折点，系统的数据量以及用户访问量都在稳步上升，早期的一些设计在现在看来有些捉襟见肘，需要做点什么。\n\n# 一、 架构中的问题识别（需求分析）：我们遇到了什么问题？\n\n<!-- more -->\n## 1、性能问题\n### 1.1 大表\n直播商品表以每月3-4百万条的速度增长，冷热数据区分明显，两个月之前的数据基本不会被读取。\n\n### 1.2 每日大批量写操作的的系统负载\n随着需求的增加，定时任务的运行时间越来越长，可能会影响用户白天的使用。\n\n## 2、数据准确性\n### 2.1 每日数据更新时的数据一致性\n\n### 2.2 \n\n## 3、人工成本过高\n### 3.1 每天的数据校验、修补，每月的榜单等都是开发者亲自执行，不可避免，耗时耗力\n\n\n# 二、重构方案\n## 1.水平分表\n系统绝对并发量没有太高，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈，可以将items_info、live_stream_data、anchor_data表进行水平拆分。\n\n## 2.垂直分库\n按照业务归属不同，将不同的表拆分到不同的库中，抽象出单独的业务模块，比如榜单模块。\n\n## 3.\n","source":"_posts/2021/淘宝数据中期设计与重构计划.md","raw":"---\ntitle: 淘宝数据中期设计与重构计划\ndate: 2021-02-08 11:27:23\nupdated: 2021-02-07 11:27:23\ntags: 系统设计\n---\n\n# 前言\n淘宝数据已经走到了一个转折点，系统的数据量以及用户访问量都在稳步上升，早期的一些设计在现在看来有些捉襟见肘，需要做点什么。\n\n# 一、 架构中的问题识别（需求分析）：我们遇到了什么问题？\n\n<!-- more -->\n## 1、性能问题\n### 1.1 大表\n直播商品表以每月3-4百万条的速度增长，冷热数据区分明显，两个月之前的数据基本不会被读取。\n\n### 1.2 每日大批量写操作的的系统负载\n随着需求的增加，定时任务的运行时间越来越长，可能会影响用户白天的使用。\n\n## 2、数据准确性\n### 2.1 每日数据更新时的数据一致性\n\n### 2.2 \n\n## 3、人工成本过高\n### 3.1 每天的数据校验、修补，每月的榜单等都是开发者亲自执行，不可避免，耗时耗力\n\n\n# 二、重构方案\n## 1.水平分表\n系统绝对并发量没有太高，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈，可以将items_info、live_stream_data、anchor_data表进行水平拆分。\n\n## 2.垂直分库\n按照业务归属不同，将不同的表拆分到不同的库中，抽象出单独的业务模块，比如榜单模块。\n\n## 3.\n","slug":"2021-淘宝数据中期设计与重构计划","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkd00142yku6czqhm0x","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>淘宝数据已经走到了一个转折点，系统的数据量以及用户访问量都在稳步上升，早期的一些设计在现在看来有些捉襟见肘，需要做点什么。</p>\n<h1 id=\"一、-架构中的问题识别（需求分析）：我们遇到了什么问题？\"><a href=\"#一、-架构中的问题识别（需求分析）：我们遇到了什么问题？\" class=\"headerlink\" title=\"一、 架构中的问题识别（需求分析）：我们遇到了什么问题？\"></a>一、 架构中的问题识别（需求分析）：我们遇到了什么问题？</h1><a id=\"more\"></a>\n<h2 id=\"1、性能问题\"><a href=\"#1、性能问题\" class=\"headerlink\" title=\"1、性能问题\"></a>1、性能问题</h2><h3 id=\"1-1-大表\"><a href=\"#1-1-大表\" class=\"headerlink\" title=\"1.1 大表\"></a>1.1 大表</h3><p>直播商品表以每月3-4百万条的速度增长，冷热数据区分明显，两个月之前的数据基本不会被读取。</p>\n<h3 id=\"1-2-每日大批量写操作的的系统负载\"><a href=\"#1-2-每日大批量写操作的的系统负载\" class=\"headerlink\" title=\"1.2 每日大批量写操作的的系统负载\"></a>1.2 每日大批量写操作的的系统负载</h3><p>随着需求的增加，定时任务的运行时间越来越长，可能会影响用户白天的使用。</p>\n<h2 id=\"2、数据准确性\"><a href=\"#2、数据准确性\" class=\"headerlink\" title=\"2、数据准确性\"></a>2、数据准确性</h2><h3 id=\"2-1-每日数据更新时的数据一致性\"><a href=\"#2-1-每日数据更新时的数据一致性\" class=\"headerlink\" title=\"2.1 每日数据更新时的数据一致性\"></a>2.1 每日数据更新时的数据一致性</h3><h3 id=\"2-2\"><a href=\"#2-2\" class=\"headerlink\" title=\"2.2\"></a>2.2</h3><h2 id=\"3、人工成本过高\"><a href=\"#3、人工成本过高\" class=\"headerlink\" title=\"3、人工成本过高\"></a>3、人工成本过高</h2><h3 id=\"3-1-每天的数据校验、修补，每月的榜单等都是开发者亲自执行，不可避免，耗时耗力\"><a href=\"#3-1-每天的数据校验、修补，每月的榜单等都是开发者亲自执行，不可避免，耗时耗力\" class=\"headerlink\" title=\"3.1 每天的数据校验、修补，每月的榜单等都是开发者亲自执行，不可避免，耗时耗力\"></a>3.1 每天的数据校验、修补，每月的榜单等都是开发者亲自执行，不可避免，耗时耗力</h3><h1 id=\"二、重构方案\"><a href=\"#二、重构方案\" class=\"headerlink\" title=\"二、重构方案\"></a>二、重构方案</h1><h2 id=\"1-水平分表\"><a href=\"#1-水平分表\" class=\"headerlink\" title=\"1.水平分表\"></a>1.水平分表</h2><p>系统绝对并发量没有太高，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈，可以将items_info、live_stream_data、anchor_data表进行水平拆分。</p>\n<h2 id=\"2-垂直分库\"><a href=\"#2-垂直分库\" class=\"headerlink\" title=\"2.垂直分库\"></a>2.垂直分库</h2><p>按照业务归属不同，将不同的表拆分到不同的库中，抽象出单独的业务模块，比如榜单模块。</p>\n<h2 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h2>","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>淘宝数据已经走到了一个转折点，系统的数据量以及用户访问量都在稳步上升，早期的一些设计在现在看来有些捉襟见肘，需要做点什么。</p>\n<h1 id=\"一、-架构中的问题识别（需求分析）：我们遇到了什么问题？\"><a href=\"#一、-架构中的问题识别（需求分析）：我们遇到了什么问题？\" class=\"headerlink\" title=\"一、 架构中的问题识别（需求分析）：我们遇到了什么问题？\"></a>一、 架构中的问题识别（需求分析）：我们遇到了什么问题？</h1>","more":"<h2 id=\"1、性能问题\"><a href=\"#1、性能问题\" class=\"headerlink\" title=\"1、性能问题\"></a>1、性能问题</h2><h3 id=\"1-1-大表\"><a href=\"#1-1-大表\" class=\"headerlink\" title=\"1.1 大表\"></a>1.1 大表</h3><p>直播商品表以每月3-4百万条的速度增长，冷热数据区分明显，两个月之前的数据基本不会被读取。</p>\n<h3 id=\"1-2-每日大批量写操作的的系统负载\"><a href=\"#1-2-每日大批量写操作的的系统负载\" class=\"headerlink\" title=\"1.2 每日大批量写操作的的系统负载\"></a>1.2 每日大批量写操作的的系统负载</h3><p>随着需求的增加，定时任务的运行时间越来越长，可能会影响用户白天的使用。</p>\n<h2 id=\"2、数据准确性\"><a href=\"#2、数据准确性\" class=\"headerlink\" title=\"2、数据准确性\"></a>2、数据准确性</h2><h3 id=\"2-1-每日数据更新时的数据一致性\"><a href=\"#2-1-每日数据更新时的数据一致性\" class=\"headerlink\" title=\"2.1 每日数据更新时的数据一致性\"></a>2.1 每日数据更新时的数据一致性</h3><h3 id=\"2-2\"><a href=\"#2-2\" class=\"headerlink\" title=\"2.2\"></a>2.2</h3><h2 id=\"3、人工成本过高\"><a href=\"#3、人工成本过高\" class=\"headerlink\" title=\"3、人工成本过高\"></a>3、人工成本过高</h2><h3 id=\"3-1-每天的数据校验、修补，每月的榜单等都是开发者亲自执行，不可避免，耗时耗力\"><a href=\"#3-1-每天的数据校验、修补，每月的榜单等都是开发者亲自执行，不可避免，耗时耗力\" class=\"headerlink\" title=\"3.1 每天的数据校验、修补，每月的榜单等都是开发者亲自执行，不可避免，耗时耗力\"></a>3.1 每天的数据校验、修补，每月的榜单等都是开发者亲自执行，不可避免，耗时耗力</h3><h1 id=\"二、重构方案\"><a href=\"#二、重构方案\" class=\"headerlink\" title=\"二、重构方案\"></a>二、重构方案</h1><h2 id=\"1-水平分表\"><a href=\"#1-水平分表\" class=\"headerlink\" title=\"1.水平分表\"></a>1.水平分表</h2><p>系统绝对并发量没有太高，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈，可以将items_info、live_stream_data、anchor_data表进行水平拆分。</p>\n<h2 id=\"2-垂直分库\"><a href=\"#2-垂直分库\" class=\"headerlink\" title=\"2.垂直分库\"></a>2.垂直分库</h2><p>按照业务归属不同，将不同的表拆分到不同的库中，抽象出单独的业务模块，比如榜单模块。</p>\n<h2 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h2>"},{"title":"2020总结","date":"2021-02-07T01:47:23.000Z","updated":"2021-02-07T01:47:23.000Z","_content":"\n1.收获（成果，总结方法论，可取之处，对于个人和公司成长的帮助）\n\n思考周全，做多手准备\n淘宝需求讨论会上，产品和我保证说，年费会员和月费会员的权益一定是一样的，它们的区别只在于时长不同。我当时信了，并基于这种模式去设计了权益方案。过了三个月，他们又说：年费会员花的钱多，要看更多数据！我愣住了。只好又花了几天来调整业务逻辑。从此我明白，不能过于依赖别人的判断和结论，涉及自己的工作，一定要自己想明白，想透彻，再去做。\n\n<!-- more -->\n\n思维灵活\n当时淘宝有个需求，是搜商品找主播。用户输入一个商品关键词，要找到这个词相关的商品，以及这些商品关联的主播，并根据每个主播对这些商品的销量进行排序。大家可能对这个数据量没有概念，我说个数字：淘宝直播每个月的直播商品记录有250w-400w条，每条记录在mysql中占用约1KB。我们需要对这么大的一个集合进行关键词匹配、分组、统计、排序。现有的技术基础根本无法实现这样的需求，于是我把思路转向了nosql，一问彭总，他说原始数据存在mongoDB里，这不巧了么！经过调整，我成功把接口响应时间从1分钟以上降到3秒钟以内。\n\n不要怕求救\n前两天，我就遇到一个很奇怪的问题，我在nest框架下写的一个Repository始终注入不了，从配置到使用都检查了一遍，也没发现症结所在。这时候珏哥说了一句，把依赖删了重新装下试试。我就一试，诶，跑起来了！有时候问题就是这么奇怪，但是你面临的问题，别人可能都遇到过。不要怕求救。\n趁这个机会，我要感谢两个人：凯哥和珏哥。开始做淘宝项目的时候，有拿不准的方案、解决不了的问题，我就问凯哥，后来用nest框架，有整不明白的我就问珏哥。他们的友善和耐心给了我很大的帮助。谢谢温凯，谢谢王珏！\n\n2.失误（没做好的遗憾的地方，最大的错误，一定要改掉）\n\n遗憾：懒惰，没能坚持做输出\n\n人都是有惰性的，但是在一个需要持续学习的岗位上，懒惰就是原罪。这是最让我后悔的一件事。去年我在技术博客上开了好多坑，有几篇文章就写了个标题；学了新的技术，做了新的东西，也只是简单记录了一下踩到的坑，没有系统的总结。这其实是对自身资源的极大浪费。\n\n3.规划怎么做，目标和计划是什么，怎么做到\n\n目标：持续成长\n身为技术人，最重要的就是技术，这是我们的立命之本。而技术在很多时候，成长比基础更重要，这也是为什么大厂钟爱985/211应届生的原因。因为技术不是一成不变的。公司的持续成长，依赖于每位成员的持续成长。\n今年我要做的，就是重新拾起知识产出，从产出中收获成长。\n\n","source":"_posts/2021/2020总结.md","raw":"---\ntitle: 2020总结\ndate: 2021-02-07 09:47:23\nupdated: 2021-02-07 09:47:23\ntags: 杂谈\n---\n\n1.收获（成果，总结方法论，可取之处，对于个人和公司成长的帮助）\n\n思考周全，做多手准备\n淘宝需求讨论会上，产品和我保证说，年费会员和月费会员的权益一定是一样的，它们的区别只在于时长不同。我当时信了，并基于这种模式去设计了权益方案。过了三个月，他们又说：年费会员花的钱多，要看更多数据！我愣住了。只好又花了几天来调整业务逻辑。从此我明白，不能过于依赖别人的判断和结论，涉及自己的工作，一定要自己想明白，想透彻，再去做。\n\n<!-- more -->\n\n思维灵活\n当时淘宝有个需求，是搜商品找主播。用户输入一个商品关键词，要找到这个词相关的商品，以及这些商品关联的主播，并根据每个主播对这些商品的销量进行排序。大家可能对这个数据量没有概念，我说个数字：淘宝直播每个月的直播商品记录有250w-400w条，每条记录在mysql中占用约1KB。我们需要对这么大的一个集合进行关键词匹配、分组、统计、排序。现有的技术基础根本无法实现这样的需求，于是我把思路转向了nosql，一问彭总，他说原始数据存在mongoDB里，这不巧了么！经过调整，我成功把接口响应时间从1分钟以上降到3秒钟以内。\n\n不要怕求救\n前两天，我就遇到一个很奇怪的问题，我在nest框架下写的一个Repository始终注入不了，从配置到使用都检查了一遍，也没发现症结所在。这时候珏哥说了一句，把依赖删了重新装下试试。我就一试，诶，跑起来了！有时候问题就是这么奇怪，但是你面临的问题，别人可能都遇到过。不要怕求救。\n趁这个机会，我要感谢两个人：凯哥和珏哥。开始做淘宝项目的时候，有拿不准的方案、解决不了的问题，我就问凯哥，后来用nest框架，有整不明白的我就问珏哥。他们的友善和耐心给了我很大的帮助。谢谢温凯，谢谢王珏！\n\n2.失误（没做好的遗憾的地方，最大的错误，一定要改掉）\n\n遗憾：懒惰，没能坚持做输出\n\n人都是有惰性的，但是在一个需要持续学习的岗位上，懒惰就是原罪。这是最让我后悔的一件事。去年我在技术博客上开了好多坑，有几篇文章就写了个标题；学了新的技术，做了新的东西，也只是简单记录了一下踩到的坑，没有系统的总结。这其实是对自身资源的极大浪费。\n\n3.规划怎么做，目标和计划是什么，怎么做到\n\n目标：持续成长\n身为技术人，最重要的就是技术，这是我们的立命之本。而技术在很多时候，成长比基础更重要，这也是为什么大厂钟爱985/211应届生的原因。因为技术不是一成不变的。公司的持续成长，依赖于每位成员的持续成长。\n今年我要做的，就是重新拾起知识产出，从产出中收获成长。\n\n","slug":"2021-2020总结","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrke00172ykubtd4g53j","content":"<p>1.收获（成果，总结方法论，可取之处，对于个人和公司成长的帮助）</p>\n<p>思考周全，做多手准备<br>淘宝需求讨论会上，产品和我保证说，年费会员和月费会员的权益一定是一样的，它们的区别只在于时长不同。我当时信了，并基于这种模式去设计了权益方案。过了三个月，他们又说：年费会员花的钱多，要看更多数据！我愣住了。只好又花了几天来调整业务逻辑。从此我明白，不能过于依赖别人的判断和结论，涉及自己的工作，一定要自己想明白，想透彻，再去做。</p>\n<a id=\"more\"></a>\n\n<p>思维灵活<br>当时淘宝有个需求，是搜商品找主播。用户输入一个商品关键词，要找到这个词相关的商品，以及这些商品关联的主播，并根据每个主播对这些商品的销量进行排序。大家可能对这个数据量没有概念，我说个数字：淘宝直播每个月的直播商品记录有250w-400w条，每条记录在mysql中占用约1KB。我们需要对这么大的一个集合进行关键词匹配、分组、统计、排序。现有的技术基础根本无法实现这样的需求，于是我把思路转向了nosql，一问彭总，他说原始数据存在mongoDB里，这不巧了么！经过调整，我成功把接口响应时间从1分钟以上降到3秒钟以内。</p>\n<p>不要怕求救<br>前两天，我就遇到一个很奇怪的问题，我在nest框架下写的一个Repository始终注入不了，从配置到使用都检查了一遍，也没发现症结所在。这时候珏哥说了一句，把依赖删了重新装下试试。我就一试，诶，跑起来了！有时候问题就是这么奇怪，但是你面临的问题，别人可能都遇到过。不要怕求救。<br>趁这个机会，我要感谢两个人：凯哥和珏哥。开始做淘宝项目的时候，有拿不准的方案、解决不了的问题，我就问凯哥，后来用nest框架，有整不明白的我就问珏哥。他们的友善和耐心给了我很大的帮助。谢谢温凯，谢谢王珏！</p>\n<p>2.失误（没做好的遗憾的地方，最大的错误，一定要改掉）</p>\n<p>遗憾：懒惰，没能坚持做输出</p>\n<p>人都是有惰性的，但是在一个需要持续学习的岗位上，懒惰就是原罪。这是最让我后悔的一件事。去年我在技术博客上开了好多坑，有几篇文章就写了个标题；学了新的技术，做了新的东西，也只是简单记录了一下踩到的坑，没有系统的总结。这其实是对自身资源的极大浪费。</p>\n<p>3.规划怎么做，目标和计划是什么，怎么做到</p>\n<p>目标：持续成长<br>身为技术人，最重要的就是技术，这是我们的立命之本。而技术在很多时候，成长比基础更重要，这也是为什么大厂钟爱985/211应届生的原因。因为技术不是一成不变的。公司的持续成长，依赖于每位成员的持续成长。<br>今年我要做的，就是重新拾起知识产出，从产出中收获成长。</p>\n","site":{"data":{}},"excerpt":"<p>1.收获（成果，总结方法论，可取之处，对于个人和公司成长的帮助）</p>\n<p>思考周全，做多手准备<br>淘宝需求讨论会上，产品和我保证说，年费会员和月费会员的权益一定是一样的，它们的区别只在于时长不同。我当时信了，并基于这种模式去设计了权益方案。过了三个月，他们又说：年费会员花的钱多，要看更多数据！我愣住了。只好又花了几天来调整业务逻辑。从此我明白，不能过于依赖别人的判断和结论，涉及自己的工作，一定要自己想明白，想透彻，再去做。</p>","more":"<p>思维灵活<br>当时淘宝有个需求，是搜商品找主播。用户输入一个商品关键词，要找到这个词相关的商品，以及这些商品关联的主播，并根据每个主播对这些商品的销量进行排序。大家可能对这个数据量没有概念，我说个数字：淘宝直播每个月的直播商品记录有250w-400w条，每条记录在mysql中占用约1KB。我们需要对这么大的一个集合进行关键词匹配、分组、统计、排序。现有的技术基础根本无法实现这样的需求，于是我把思路转向了nosql，一问彭总，他说原始数据存在mongoDB里，这不巧了么！经过调整，我成功把接口响应时间从1分钟以上降到3秒钟以内。</p>\n<p>不要怕求救<br>前两天，我就遇到一个很奇怪的问题，我在nest框架下写的一个Repository始终注入不了，从配置到使用都检查了一遍，也没发现症结所在。这时候珏哥说了一句，把依赖删了重新装下试试。我就一试，诶，跑起来了！有时候问题就是这么奇怪，但是你面临的问题，别人可能都遇到过。不要怕求救。<br>趁这个机会，我要感谢两个人：凯哥和珏哥。开始做淘宝项目的时候，有拿不准的方案、解决不了的问题，我就问凯哥，后来用nest框架，有整不明白的我就问珏哥。他们的友善和耐心给了我很大的帮助。谢谢温凯，谢谢王珏！</p>\n<p>2.失误（没做好的遗憾的地方，最大的错误，一定要改掉）</p>\n<p>遗憾：懒惰，没能坚持做输出</p>\n<p>人都是有惰性的，但是在一个需要持续学习的岗位上，懒惰就是原罪。这是最让我后悔的一件事。去年我在技术博客上开了好多坑，有几篇文章就写了个标题；学了新的技术，做了新的东西，也只是简单记录了一下踩到的坑，没有系统的总结。这其实是对自身资源的极大浪费。</p>\n<p>3.规划怎么做，目标和计划是什么，怎么做到</p>\n<p>目标：持续成长<br>身为技术人，最重要的就是技术，这是我们的立命之本。而技术在很多时候，成长比基础更重要，这也是为什么大厂钟爱985/211应届生的原因。因为技术不是一成不变的。公司的持续成长，依赖于每位成员的持续成长。<br>今年我要做的，就是重新拾起知识产出，从产出中收获成长。</p>"},{"title":"异步中的eval()","date":"2020-01-12T16:00:00.000Z","updated":"2020-01-12T16:00:00.000Z","_content":"\nawait仅在异步方法中有效\n<!-- more -->\n\n```\nconst session = async () => {\n    console.log(111)\n};\n\n// 错误的写法\neval(`await session(extra, data)`);// Uncaught SyntaxError: await is only valid in async function\n\n// 正确的写法\neval(`(async () => { await session(extra, data) })()`);\n```\n","source":"_posts/2020/01/异步中的eval().md","raw":"---\ntitle: 异步中的eval()\ndate: 2020-01-13\nupdated: 2020-01-13\ntags: Node.js\n---\n\nawait仅在异步方法中有效\n<!-- more -->\n\n```\nconst session = async () => {\n    console.log(111)\n};\n\n// 错误的写法\neval(`await session(extra, data)`);// Uncaught SyntaxError: await is only valid in async function\n\n// 正确的写法\neval(`(async () => { await session(extra, data) })()`);\n```\n","slug":"异步中的eval()","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkf00192yku8cbz2c1j","content":"<p>await仅在异步方法中有效</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const session &#x3D; async () &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(111)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 错误的写法</span><br><span class=\"line\">eval(&#96;await session(extra, data)&#96;);&#x2F;&#x2F; Uncaught SyntaxError: await is only valid in async function</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 正确的写法</span><br><span class=\"line\">eval(&#96;(async () &#x3D;&gt; &#123; await session(extra, data) &#125;)()&#96;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>await仅在异步方法中有效</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const session &#x3D; async () &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(111)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 错误的写法</span><br><span class=\"line\">eval(&#96;await session(extra, data)&#96;);&#x2F;&#x2F; Uncaught SyntaxError: await is only valid in async function</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 正确的写法</span><br><span class=\"line\">eval(&#96;(async () &#x3D;&gt; &#123; await session(extra, data) &#125;)()&#96;);</span><br></pre></td></tr></table></figure>"},{"title":"数据库连接池大小应该设多大","date":"2020-03-23T03:03:01.000Z","updated":"2020-03-23T03:03:01.000Z","_content":"\n先说结论：你需要一个小连接池，和一个充满了等待连接的线程的队列。\n\n<!-- more -->\n\n连接池不是越大越好，池的大小表示服务器同时能进行连接数量，但一颗CPU核心同一时刻只能执行一个线程，然后操作系统切换上下文，核心开始执行另一个线程的代码，以此类推。给定一颗CPU核心，其顺序执行A和B永远比通过时间分片“同时”执行A和B要快，这是一条计算机科学的基本法则。一旦线程的数量超过了CPU核心的数量，再增加线程数系统就只会更慢，而不是更快。所以，初步结论：池大小 = CPU核心数。\n  \n如果我们将池大小设为CPU核心数，就会出现这么一种情况：线程是在“阻塞”着，等待硬盘。所以，由于线程总是在I/O上阻塞，我们可以让线程（连接数）比CPU核心多一些，这样能够在同样的时间内完成更多的工作。I/O时间越短，需要多出来的线程越少。只有当阻塞创造了更多的执行机会时，更多的线程数才能发挥出更好的性能。网络耗时和I/O是同一个思路。\n\n下面的公式是由PostgreSQL提供的，不过我们认为可以广泛地应用于大多数数据库产品：\n\n`连接数 = ((核心数 * 2) + 有效磁盘数)`\n\n按这个公式，你的4核i7数据库服务器的连接池大小应该为((4 * 2) + 1) = 9。\n","source":"_posts/2020/03/连接池大小应该设多大.md","raw":"---\ntitle: 数据库连接池大小应该设多大\ndate: 2020-03-23 11:03:01\nupdated: 2020-03-23 11:03:01\ntags: 数据库\n---\n\n先说结论：你需要一个小连接池，和一个充满了等待连接的线程的队列。\n\n<!-- more -->\n\n连接池不是越大越好，池的大小表示服务器同时能进行连接数量，但一颗CPU核心同一时刻只能执行一个线程，然后操作系统切换上下文，核心开始执行另一个线程的代码，以此类推。给定一颗CPU核心，其顺序执行A和B永远比通过时间分片“同时”执行A和B要快，这是一条计算机科学的基本法则。一旦线程的数量超过了CPU核心的数量，再增加线程数系统就只会更慢，而不是更快。所以，初步结论：池大小 = CPU核心数。\n  \n如果我们将池大小设为CPU核心数，就会出现这么一种情况：线程是在“阻塞”着，等待硬盘。所以，由于线程总是在I/O上阻塞，我们可以让线程（连接数）比CPU核心多一些，这样能够在同样的时间内完成更多的工作。I/O时间越短，需要多出来的线程越少。只有当阻塞创造了更多的执行机会时，更多的线程数才能发挥出更好的性能。网络耗时和I/O是同一个思路。\n\n下面的公式是由PostgreSQL提供的，不过我们认为可以广泛地应用于大多数数据库产品：\n\n`连接数 = ((核心数 * 2) + 有效磁盘数)`\n\n按这个公式，你的4核i7数据库服务器的连接池大小应该为((4 * 2) + 1) = 9。\n","slug":"连接池大小应该设多大","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkg001b2yku88ocbeyl","content":"<p>先说结论：你需要一个小连接池，和一个充满了等待连接的线程的队列。</p>\n<a id=\"more\"></a>\n\n<p>连接池不是越大越好，池的大小表示服务器同时能进行连接数量，但一颗CPU核心同一时刻只能执行一个线程，然后操作系统切换上下文，核心开始执行另一个线程的代码，以此类推。给定一颗CPU核心，其顺序执行A和B永远比通过时间分片“同时”执行A和B要快，这是一条计算机科学的基本法则。一旦线程的数量超过了CPU核心的数量，再增加线程数系统就只会更慢，而不是更快。所以，初步结论：池大小 = CPU核心数。</p>\n<p>如果我们将池大小设为CPU核心数，就会出现这么一种情况：线程是在“阻塞”着，等待硬盘。所以，由于线程总是在I/O上阻塞，我们可以让线程（连接数）比CPU核心多一些，这样能够在同样的时间内完成更多的工作。I/O时间越短，需要多出来的线程越少。只有当阻塞创造了更多的执行机会时，更多的线程数才能发挥出更好的性能。网络耗时和I/O是同一个思路。</p>\n<p>下面的公式是由PostgreSQL提供的，不过我们认为可以广泛地应用于大多数数据库产品：</p>\n<p><code>连接数 = ((核心数 * 2) + 有效磁盘数)</code></p>\n<p>按这个公式，你的4核i7数据库服务器的连接池大小应该为((4 * 2) + 1) = 9。</p>\n","site":{"data":{}},"excerpt":"<p>先说结论：你需要一个小连接池，和一个充满了等待连接的线程的队列。</p>","more":"<p>连接池不是越大越好，池的大小表示服务器同时能进行连接数量，但一颗CPU核心同一时刻只能执行一个线程，然后操作系统切换上下文，核心开始执行另一个线程的代码，以此类推。给定一颗CPU核心，其顺序执行A和B永远比通过时间分片“同时”执行A和B要快，这是一条计算机科学的基本法则。一旦线程的数量超过了CPU核心的数量，再增加线程数系统就只会更慢，而不是更快。所以，初步结论：池大小 = CPU核心数。</p>\n<p>如果我们将池大小设为CPU核心数，就会出现这么一种情况：线程是在“阻塞”着，等待硬盘。所以，由于线程总是在I/O上阻塞，我们可以让线程（连接数）比CPU核心多一些，这样能够在同样的时间内完成更多的工作。I/O时间越短，需要多出来的线程越少。只有当阻塞创造了更多的执行机会时，更多的线程数才能发挥出更好的性能。网络耗时和I/O是同一个思路。</p>\n<p>下面的公式是由PostgreSQL提供的，不过我们认为可以广泛地应用于大多数数据库产品：</p>\n<p><code>连接数 = ((核心数 * 2) + 有效磁盘数)</code></p>\n<p>按这个公式，你的4核i7数据库服务器的连接池大小应该为((4 * 2) + 1) = 9。</p>"},{"title":"CentOS下docker安装ss","date":"2020-05-12T18:57:29.000Z","updated":"2020-05-12T18:57:29.000Z","_content":"\n实践记录\n\n<!-- more -->\n\n```bash\n#docker安装\nyum install -y docker\n#启动docker服务\nsystemctl start docker\n#启动Docker服务并设为开机启动\nsystemctl enable --now docker\n#在docker中安装ss服务端\n# -k密码 -m加密方式 -p\n\n#run-A\ndocker run -dt --name ss-server -p 2333:2333 mritd/shadowsocks -s \"-s 0.0.0.0 -p 2333 -m aes-256-gcm -k 123456 --fast-open\" --restart=always\n#run-B kcp\ndocker run -dt --name ss-server -p 2333:2333 -p 2334:2334/udp mritd/shadowsocks -m \"ss-server\" -s \"-s 0.0.0.0 -p 2333 -m aes-256-gcm -k 123456 --fast-open\" -x -e \"kcpserver\" -k \"-t 127.0.0.1:2333 -l :2334 -mode fast2\"\n#kcp加速版\ndocker run -dt --name ss-server -p 2333:2333 -p 2334:2334/udp -e SS_CONFIG=\"-s 0.0.0.0 -p 2333 -m aes-256-gcm -k 123456 --fast-open\" -e KCP_MODULE=\"kcpserver\" -e KCP_CONFIG=\"-t 127.0.0.1:2333 -l :2334 -mode fast2\" -e KCP_FLAG=\"true\" mritd/shadowsocks\n\n#安装完之后查看是否安装成功：　\nyum list installed | grep docker\n#查看docker是否启动成功\nsystemctl status docker\n\n#centos7系统开始，使用firewalld服务替代了iptables服务\n#查看防火墙状态\nsystemctl status firewalld\n#关闭防火墙\nsystemctl stop firewalld\n#关闭iptable\nsystemctl stop iptables\n\n#查看正在运行的容器\ndocker ps\n#查看所有容器（包括停止的）\ndocker ps -a\n#重启docker服务\nsystemctl restart docker\n#运行容器\ndocker start/restart/stop ss-server\n#强制删除容器\ndocker rm ss-server -f\n\n```\n","source":"_posts/2020/05/CentOS下docker安装ss.md","raw":"---\ntitle: CentOS下docker安装ss\ndate: 2020-05-13 02:57:29\nupdated: 2020-05-13 02:57:29\ntags: 代理\n---\n\n实践记录\n\n<!-- more -->\n\n```bash\n#docker安装\nyum install -y docker\n#启动docker服务\nsystemctl start docker\n#启动Docker服务并设为开机启动\nsystemctl enable --now docker\n#在docker中安装ss服务端\n# -k密码 -m加密方式 -p\n\n#run-A\ndocker run -dt --name ss-server -p 2333:2333 mritd/shadowsocks -s \"-s 0.0.0.0 -p 2333 -m aes-256-gcm -k 123456 --fast-open\" --restart=always\n#run-B kcp\ndocker run -dt --name ss-server -p 2333:2333 -p 2334:2334/udp mritd/shadowsocks -m \"ss-server\" -s \"-s 0.0.0.0 -p 2333 -m aes-256-gcm -k 123456 --fast-open\" -x -e \"kcpserver\" -k \"-t 127.0.0.1:2333 -l :2334 -mode fast2\"\n#kcp加速版\ndocker run -dt --name ss-server -p 2333:2333 -p 2334:2334/udp -e SS_CONFIG=\"-s 0.0.0.0 -p 2333 -m aes-256-gcm -k 123456 --fast-open\" -e KCP_MODULE=\"kcpserver\" -e KCP_CONFIG=\"-t 127.0.0.1:2333 -l :2334 -mode fast2\" -e KCP_FLAG=\"true\" mritd/shadowsocks\n\n#安装完之后查看是否安装成功：　\nyum list installed | grep docker\n#查看docker是否启动成功\nsystemctl status docker\n\n#centos7系统开始，使用firewalld服务替代了iptables服务\n#查看防火墙状态\nsystemctl status firewalld\n#关闭防火墙\nsystemctl stop firewalld\n#关闭iptable\nsystemctl stop iptables\n\n#查看正在运行的容器\ndocker ps\n#查看所有容器（包括停止的）\ndocker ps -a\n#重启docker服务\nsystemctl restart docker\n#运行容器\ndocker start/restart/stop ss-server\n#强制删除容器\ndocker rm ss-server -f\n\n```\n","slug":"CentOS下docker安装ss","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkh001d2yku68dog0tz","content":"<p>实践记录</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#docker安装</span></span><br><span class=\"line\">yum install -y docker</span><br><span class=\"line\"><span class=\"comment\">#启动docker服务</span></span><br><span class=\"line\">systemctl start docker</span><br><span class=\"line\"><span class=\"comment\">#启动Docker服务并设为开机启动</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> --now docker</span><br><span class=\"line\"><span class=\"comment\">#在docker中安装ss服务端</span></span><br><span class=\"line\"><span class=\"comment\"># -k密码 -m加密方式 -p</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#run-A</span></span><br><span class=\"line\">docker run -dt --name ss-server -p 2333:2333 mritd/shadowsocks -s <span class=\"string\">&quot;-s 0.0.0.0 -p 2333 -m aes-256-gcm -k 123456 --fast-open&quot;</span> --restart=always</span><br><span class=\"line\"><span class=\"comment\">#run-B kcp</span></span><br><span class=\"line\">docker run -dt --name ss-server -p 2333:2333 -p 2334:2334/udp mritd/shadowsocks -m <span class=\"string\">&quot;ss-server&quot;</span> -s <span class=\"string\">&quot;-s 0.0.0.0 -p 2333 -m aes-256-gcm -k 123456 --fast-open&quot;</span> -x -e <span class=\"string\">&quot;kcpserver&quot;</span> -k <span class=\"string\">&quot;-t 127.0.0.1:2333 -l :2334 -mode fast2&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#kcp加速版</span></span><br><span class=\"line\">docker run -dt --name ss-server -p 2333:2333 -p 2334:2334/udp -e SS_CONFIG=<span class=\"string\">&quot;-s 0.0.0.0 -p 2333 -m aes-256-gcm -k 123456 --fast-open&quot;</span> -e KCP_MODULE=<span class=\"string\">&quot;kcpserver&quot;</span> -e KCP_CONFIG=<span class=\"string\">&quot;-t 127.0.0.1:2333 -l :2334 -mode fast2&quot;</span> -e KCP_FLAG=<span class=\"string\">&quot;true&quot;</span> mritd/shadowsocks</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#安装完之后查看是否安装成功：　</span></span><br><span class=\"line\">yum list installed | grep docker</span><br><span class=\"line\"><span class=\"comment\">#查看docker是否启动成功</span></span><br><span class=\"line\">systemctl status docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#centos7系统开始，使用firewalld服务替代了iptables服务</span></span><br><span class=\"line\"><span class=\"comment\">#查看防火墙状态</span></span><br><span class=\"line\">systemctl status firewalld</span><br><span class=\"line\"><span class=\"comment\">#关闭防火墙</span></span><br><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\"><span class=\"comment\">#关闭iptable</span></span><br><span class=\"line\">systemctl stop iptables</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#查看正在运行的容器</span></span><br><span class=\"line\">docker ps</span><br><span class=\"line\"><span class=\"comment\">#查看所有容器（包括停止的）</span></span><br><span class=\"line\">docker ps -a</span><br><span class=\"line\"><span class=\"comment\">#重启docker服务</span></span><br><span class=\"line\">systemctl restart docker</span><br><span class=\"line\"><span class=\"comment\">#运行容器</span></span><br><span class=\"line\">docker start/restart/stop ss-server</span><br><span class=\"line\"><span class=\"comment\">#强制删除容器</span></span><br><span class=\"line\">docker rm ss-server -f</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>实践记录</p>","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#docker安装</span></span><br><span class=\"line\">yum install -y docker</span><br><span class=\"line\"><span class=\"comment\">#启动docker服务</span></span><br><span class=\"line\">systemctl start docker</span><br><span class=\"line\"><span class=\"comment\">#启动Docker服务并设为开机启动</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> --now docker</span><br><span class=\"line\"><span class=\"comment\">#在docker中安装ss服务端</span></span><br><span class=\"line\"><span class=\"comment\"># -k密码 -m加密方式 -p</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#run-A</span></span><br><span class=\"line\">docker run -dt --name ss-server -p 2333:2333 mritd/shadowsocks -s <span class=\"string\">&quot;-s 0.0.0.0 -p 2333 -m aes-256-gcm -k 123456 --fast-open&quot;</span> --restart=always</span><br><span class=\"line\"><span class=\"comment\">#run-B kcp</span></span><br><span class=\"line\">docker run -dt --name ss-server -p 2333:2333 -p 2334:2334/udp mritd/shadowsocks -m <span class=\"string\">&quot;ss-server&quot;</span> -s <span class=\"string\">&quot;-s 0.0.0.0 -p 2333 -m aes-256-gcm -k 123456 --fast-open&quot;</span> -x -e <span class=\"string\">&quot;kcpserver&quot;</span> -k <span class=\"string\">&quot;-t 127.0.0.1:2333 -l :2334 -mode fast2&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#kcp加速版</span></span><br><span class=\"line\">docker run -dt --name ss-server -p 2333:2333 -p 2334:2334/udp -e SS_CONFIG=<span class=\"string\">&quot;-s 0.0.0.0 -p 2333 -m aes-256-gcm -k 123456 --fast-open&quot;</span> -e KCP_MODULE=<span class=\"string\">&quot;kcpserver&quot;</span> -e KCP_CONFIG=<span class=\"string\">&quot;-t 127.0.0.1:2333 -l :2334 -mode fast2&quot;</span> -e KCP_FLAG=<span class=\"string\">&quot;true&quot;</span> mritd/shadowsocks</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#安装完之后查看是否安装成功：　</span></span><br><span class=\"line\">yum list installed | grep docker</span><br><span class=\"line\"><span class=\"comment\">#查看docker是否启动成功</span></span><br><span class=\"line\">systemctl status docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#centos7系统开始，使用firewalld服务替代了iptables服务</span></span><br><span class=\"line\"><span class=\"comment\">#查看防火墙状态</span></span><br><span class=\"line\">systemctl status firewalld</span><br><span class=\"line\"><span class=\"comment\">#关闭防火墙</span></span><br><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\"><span class=\"comment\">#关闭iptable</span></span><br><span class=\"line\">systemctl stop iptables</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#查看正在运行的容器</span></span><br><span class=\"line\">docker ps</span><br><span class=\"line\"><span class=\"comment\">#查看所有容器（包括停止的）</span></span><br><span class=\"line\">docker ps -a</span><br><span class=\"line\"><span class=\"comment\">#重启docker服务</span></span><br><span class=\"line\">systemctl restart docker</span><br><span class=\"line\"><span class=\"comment\">#运行容器</span></span><br><span class=\"line\">docker start/restart/stop ss-server</span><br><span class=\"line\"><span class=\"comment\">#强制删除容器</span></span><br><span class=\"line\">docker rm ss-server -f</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"为git配置代理","date":"2020-05-21T16:00:00.000Z","updated":"2019-05-21T16:00:00.000Z","_content":"# 一、http通道\n> 各平台的 Shadowsocks 客户端都提供一个本地的 socks5 代理和一个 http 代理，建议使用socks5\n\n<!-- more -->\n\n```\n#地址带引号可能出错\n#不存在https.proxy\ngit config --global http.proxy socks5://127.0.0.1:1086\n```\n\n还有针对 github.com 的单独配置，这更符合工作环境：\n```\n#只对github.com\ngit config --global http.https://github.com.proxy socks5://127.0.0.1:1086\n\n#取消代理\ngit config --global --unset http.https://github.com.proxy\n```\n\n# 二、ssh通道\n打开用户主目录下的 `.ssh/config` 文件，添加以下内容\n```\n# 必须是 github.com\nHost github.com\nHostName github.com\nUser git\nIdentityFile ~/.ssh/id_dsa\n\n# 走 HTTP 代理\nProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=8080\n\n# 走 socks5 代理（如 Shadowsocks）\nProxyCommand nc -v -x 127.0.0.1:1086 %h %p\n# 或\nProxyCommand nc -X 5 -x 127.0.0.1:1086 %h %p\n\n#在windows上，因为这个bash是不带netcat的，也就找到不到nc命令。\n#在win10上，有的msysgit版本集成了connect工具(没有就先安装)，所以在windows上，可以把ssh的config文件设置为：\nProxyCommand connect -S 127.0.0.1:1080 %h %p\n#就可以给ssh加socks代理了。（未测试，有待勘误）\n```\n","source":"_posts/2020/05/为git配置代理.md","raw":"---\ntitle: 为git配置代理\ndate: 2020-05-22\nupdated: 2019-05-22\ntags: 代理\n---\n# 一、http通道\n> 各平台的 Shadowsocks 客户端都提供一个本地的 socks5 代理和一个 http 代理，建议使用socks5\n\n<!-- more -->\n\n```\n#地址带引号可能出错\n#不存在https.proxy\ngit config --global http.proxy socks5://127.0.0.1:1086\n```\n\n还有针对 github.com 的单独配置，这更符合工作环境：\n```\n#只对github.com\ngit config --global http.https://github.com.proxy socks5://127.0.0.1:1086\n\n#取消代理\ngit config --global --unset http.https://github.com.proxy\n```\n\n# 二、ssh通道\n打开用户主目录下的 `.ssh/config` 文件，添加以下内容\n```\n# 必须是 github.com\nHost github.com\nHostName github.com\nUser git\nIdentityFile ~/.ssh/id_dsa\n\n# 走 HTTP 代理\nProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=8080\n\n# 走 socks5 代理（如 Shadowsocks）\nProxyCommand nc -v -x 127.0.0.1:1086 %h %p\n# 或\nProxyCommand nc -X 5 -x 127.0.0.1:1086 %h %p\n\n#在windows上，因为这个bash是不带netcat的，也就找到不到nc命令。\n#在win10上，有的msysgit版本集成了connect工具(没有就先安装)，所以在windows上，可以把ssh的config文件设置为：\nProxyCommand connect -S 127.0.0.1:1080 %h %p\n#就可以给ssh加socks代理了。（未测试，有待勘误）\n```\n","slug":"为git配置代理","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrki001g2ykud0w5541v","content":"<h1 id=\"一、http通道\"><a href=\"#一、http通道\" class=\"headerlink\" title=\"一、http通道\"></a>一、http通道</h1><blockquote>\n<p>各平台的 Shadowsocks 客户端都提供一个本地的 socks5 代理和一个 http 代理，建议使用socks5</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#地址带引号可能出错</span><br><span class=\"line\">#不存在https.proxy</span><br><span class=\"line\">git config --global http.proxy socks5:&#x2F;&#x2F;127.0.0.1:1086</span><br></pre></td></tr></table></figure>\n\n<p>还有针对 github.com 的单独配置，这更符合工作环境：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#只对github.com</span><br><span class=\"line\">git config --global http.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:1086</span><br><span class=\"line\"></span><br><span class=\"line\">#取消代理</span><br><span class=\"line\">git config --global --unset http.https:&#x2F;&#x2F;github.com.proxy</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、ssh通道\"><a href=\"#二、ssh通道\" class=\"headerlink\" title=\"二、ssh通道\"></a>二、ssh通道</h1><p>打开用户主目录下的 <code>.ssh/config</code> 文件，添加以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 必须是 github.com</span><br><span class=\"line\">Host github.com</span><br><span class=\"line\">HostName github.com</span><br><span class=\"line\">User git</span><br><span class=\"line\">IdentityFile ~&#x2F;.ssh&#x2F;id_dsa</span><br><span class=\"line\"></span><br><span class=\"line\"># 走 HTTP 代理</span><br><span class=\"line\">ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport&#x3D;8080</span><br><span class=\"line\"></span><br><span class=\"line\"># 走 socks5 代理（如 Shadowsocks）</span><br><span class=\"line\">ProxyCommand nc -v -x 127.0.0.1:1086 %h %p</span><br><span class=\"line\"># 或</span><br><span class=\"line\">ProxyCommand nc -X 5 -x 127.0.0.1:1086 %h %p</span><br><span class=\"line\"></span><br><span class=\"line\">#在windows上，因为这个bash是不带netcat的，也就找到不到nc命令。</span><br><span class=\"line\">#在win10上，有的msysgit版本集成了connect工具(没有就先安装)，所以在windows上，可以把ssh的config文件设置为：</span><br><span class=\"line\">ProxyCommand connect -S 127.0.0.1:1080 %h %p</span><br><span class=\"line\">#就可以给ssh加socks代理了。（未测试，有待勘误）</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、http通道\"><a href=\"#一、http通道\" class=\"headerlink\" title=\"一、http通道\"></a>一、http通道</h1><blockquote>\n<p>各平台的 Shadowsocks 客户端都提供一个本地的 socks5 代理和一个 http 代理，建议使用socks5</p>\n</blockquote>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#地址带引号可能出错</span><br><span class=\"line\">#不存在https.proxy</span><br><span class=\"line\">git config --global http.proxy socks5:&#x2F;&#x2F;127.0.0.1:1086</span><br></pre></td></tr></table></figure>\n\n<p>还有针对 github.com 的单独配置，这更符合工作环境：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#只对github.com</span><br><span class=\"line\">git config --global http.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:1086</span><br><span class=\"line\"></span><br><span class=\"line\">#取消代理</span><br><span class=\"line\">git config --global --unset http.https:&#x2F;&#x2F;github.com.proxy</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、ssh通道\"><a href=\"#二、ssh通道\" class=\"headerlink\" title=\"二、ssh通道\"></a>二、ssh通道</h1><p>打开用户主目录下的 <code>.ssh/config</code> 文件，添加以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 必须是 github.com</span><br><span class=\"line\">Host github.com</span><br><span class=\"line\">HostName github.com</span><br><span class=\"line\">User git</span><br><span class=\"line\">IdentityFile ~&#x2F;.ssh&#x2F;id_dsa</span><br><span class=\"line\"></span><br><span class=\"line\"># 走 HTTP 代理</span><br><span class=\"line\">ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport&#x3D;8080</span><br><span class=\"line\"></span><br><span class=\"line\"># 走 socks5 代理（如 Shadowsocks）</span><br><span class=\"line\">ProxyCommand nc -v -x 127.0.0.1:1086 %h %p</span><br><span class=\"line\"># 或</span><br><span class=\"line\">ProxyCommand nc -X 5 -x 127.0.0.1:1086 %h %p</span><br><span class=\"line\"></span><br><span class=\"line\">#在windows上，因为这个bash是不带netcat的，也就找到不到nc命令。</span><br><span class=\"line\">#在win10上，有的msysgit版本集成了connect工具(没有就先安装)，所以在windows上，可以把ssh的config文件设置为：</span><br><span class=\"line\">ProxyCommand connect -S 127.0.0.1:1080 %h %p</span><br><span class=\"line\">#就可以给ssh加socks代理了。（未测试，有待勘误）</span><br></pre></td></tr></table></figure>"},{"title":"为npm配置代理","date":"2020-05-21T16:00:00.000Z","updated":"2019-05-21T16:00:00.000Z","_content":"cnpm太不靠谱，终端下程序又不走代理，这时候就需要一些设置。\n\n<!-- more -->\n\n# 针对npm配置的命令行操作\n\n```\n   npm config set <key> <value> [--global]\n   npm config get <key>\n   npm config delete <key>\n   npm config list\n   npm config edit\n   npm get <key>\n   npm set <key> <value> [--global]\n```\n在设置配置属性时属性值默认是被存储于用户配置文件中，如果加上`--global`，则被存储在全局配置文件中。\n\n用户配置文件一般就是用户根目录下的`.npmrc`文件。\n\n如果要查看npm的所有配置属性（包括默认配置），可以使用`npm config ls -l`。\n\n如果要查看npm的各种配置的含义，可以使用`npm help config`。\n\n# 为npm设置代理\n\n```\nnpm config set proxy http://127.0.0.1:1087\nnpm config set https-proxy http://127.0.0.1:1087\n```\n\n如果代理需要认证的话可以这样来设置。\n```\nnpm config set proxy http://username:password@server:port\nnpm config set https-proxy http://username:pawword@server:port\n```\n\n如果代理不支持https的话需要修改npm存放package的网站地址。\n```\nnpm config set registry \"http://registry.npmjs.org/\"\n```\n\n清除npm的代理命令如下：\n```\nnpm config delete http-proxy\nnpm config delete https-proxy\n```\n\n也可以单独为这次npm下载定义代理\n```\nnpm install -g pomelo --proxy http://127.0.0.1:1087\n```\n","source":"_posts/2020/05/为npm配置代理.md","raw":"---\ntitle: 为npm配置代理\ndate: 2020-05-22\nupdated: 2019-05-22\ntags: 代理\n---\ncnpm太不靠谱，终端下程序又不走代理，这时候就需要一些设置。\n\n<!-- more -->\n\n# 针对npm配置的命令行操作\n\n```\n   npm config set <key> <value> [--global]\n   npm config get <key>\n   npm config delete <key>\n   npm config list\n   npm config edit\n   npm get <key>\n   npm set <key> <value> [--global]\n```\n在设置配置属性时属性值默认是被存储于用户配置文件中，如果加上`--global`，则被存储在全局配置文件中。\n\n用户配置文件一般就是用户根目录下的`.npmrc`文件。\n\n如果要查看npm的所有配置属性（包括默认配置），可以使用`npm config ls -l`。\n\n如果要查看npm的各种配置的含义，可以使用`npm help config`。\n\n# 为npm设置代理\n\n```\nnpm config set proxy http://127.0.0.1:1087\nnpm config set https-proxy http://127.0.0.1:1087\n```\n\n如果代理需要认证的话可以这样来设置。\n```\nnpm config set proxy http://username:password@server:port\nnpm config set https-proxy http://username:pawword@server:port\n```\n\n如果代理不支持https的话需要修改npm存放package的网站地址。\n```\nnpm config set registry \"http://registry.npmjs.org/\"\n```\n\n清除npm的代理命令如下：\n```\nnpm config delete http-proxy\nnpm config delete https-proxy\n```\n\n也可以单独为这次npm下载定义代理\n```\nnpm install -g pomelo --proxy http://127.0.0.1:1087\n```\n","slug":"为npm配置代理","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkj001i2yku9tr9au1n","content":"<p>cnpm太不靠谱，终端下程序又不走代理，这时候就需要一些设置。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"针对npm配置的命令行操作\"><a href=\"#针对npm配置的命令行操作\" class=\"headerlink\" title=\"针对npm配置的命令行操作\"></a>针对npm配置的命令行操作</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set &lt;key&gt; &lt;value&gt; [--global]</span><br><span class=\"line\">npm config get &lt;key&gt;</span><br><span class=\"line\">npm config delete &lt;key&gt;</span><br><span class=\"line\">npm config list</span><br><span class=\"line\">npm config edit</span><br><span class=\"line\">npm get &lt;key&gt;</span><br><span class=\"line\">npm set &lt;key&gt; &lt;value&gt; [--global]</span><br></pre></td></tr></table></figure>\n<p>在设置配置属性时属性值默认是被存储于用户配置文件中，如果加上<code>--global</code>，则被存储在全局配置文件中。</p>\n<p>用户配置文件一般就是用户根目录下的<code>.npmrc</code>文件。</p>\n<p>如果要查看npm的所有配置属性（包括默认配置），可以使用<code>npm config ls -l</code>。</p>\n<p>如果要查看npm的各种配置的含义，可以使用<code>npm help config</code>。</p>\n<h1 id=\"为npm设置代理\"><a href=\"#为npm设置代理\" class=\"headerlink\" title=\"为npm设置代理\"></a>为npm设置代理</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set proxy http:&#x2F;&#x2F;127.0.0.1:1087</span><br><span class=\"line\">npm config set https-proxy http:&#x2F;&#x2F;127.0.0.1:1087</span><br></pre></td></tr></table></figure>\n\n<p>如果代理需要认证的话可以这样来设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set proxy http:&#x2F;&#x2F;username:password@server:port</span><br><span class=\"line\">npm config set https-proxy http:&#x2F;&#x2F;username:pawword@server:port</span><br></pre></td></tr></table></figure>\n\n<p>如果代理不支持https的话需要修改npm存放package的网站地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry &quot;http:&#x2F;&#x2F;registry.npmjs.org&#x2F;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>清除npm的代理命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config delete http-proxy</span><br><span class=\"line\">npm config delete https-proxy</span><br></pre></td></tr></table></figure>\n\n<p>也可以单独为这次npm下载定义代理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g pomelo --proxy http:&#x2F;&#x2F;127.0.0.1:1087</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>cnpm太不靠谱，终端下程序又不走代理，这时候就需要一些设置。</p>","more":"<h1 id=\"针对npm配置的命令行操作\"><a href=\"#针对npm配置的命令行操作\" class=\"headerlink\" title=\"针对npm配置的命令行操作\"></a>针对npm配置的命令行操作</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set &lt;key&gt; &lt;value&gt; [--global]</span><br><span class=\"line\">npm config get &lt;key&gt;</span><br><span class=\"line\">npm config delete &lt;key&gt;</span><br><span class=\"line\">npm config list</span><br><span class=\"line\">npm config edit</span><br><span class=\"line\">npm get &lt;key&gt;</span><br><span class=\"line\">npm set &lt;key&gt; &lt;value&gt; [--global]</span><br></pre></td></tr></table></figure>\n<p>在设置配置属性时属性值默认是被存储于用户配置文件中，如果加上<code>--global</code>，则被存储在全局配置文件中。</p>\n<p>用户配置文件一般就是用户根目录下的<code>.npmrc</code>文件。</p>\n<p>如果要查看npm的所有配置属性（包括默认配置），可以使用<code>npm config ls -l</code>。</p>\n<p>如果要查看npm的各种配置的含义，可以使用<code>npm help config</code>。</p>\n<h1 id=\"为npm设置代理\"><a href=\"#为npm设置代理\" class=\"headerlink\" title=\"为npm设置代理\"></a>为npm设置代理</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set proxy http:&#x2F;&#x2F;127.0.0.1:1087</span><br><span class=\"line\">npm config set https-proxy http:&#x2F;&#x2F;127.0.0.1:1087</span><br></pre></td></tr></table></figure>\n\n<p>如果代理需要认证的话可以这样来设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set proxy http:&#x2F;&#x2F;username:password@server:port</span><br><span class=\"line\">npm config set https-proxy http:&#x2F;&#x2F;username:pawword@server:port</span><br></pre></td></tr></table></figure>\n\n<p>如果代理不支持https的话需要修改npm存放package的网站地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry &quot;http:&#x2F;&#x2F;registry.npmjs.org&#x2F;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>清除npm的代理命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config delete http-proxy</span><br><span class=\"line\">npm config delete https-proxy</span><br></pre></td></tr></table></figure>\n\n<p>也可以单独为这次npm下载定义代理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g pomelo --proxy http:&#x2F;&#x2F;127.0.0.1:1087</span><br></pre></td></tr></table></figure>"},{"title":"事件循环 - 宏队列与微队列","date":"2020-05-16T10:16:00.000Z","updated":"2020-05-16T10:16:00.000Z","_content":"JavaScript 事件循环机制分为浏览器和 Node 事件循环机制，两者的实现技术不一样，浏览器 Event Loop 是 HTML 中定义的规范，Node Event Loop 是由 libuv 库实现。这里主要讲的是浏览器部分。Node下的逻辑差不太多。\n\n<!-- more -->\n\n```javascript\nsetTimeout(() => {\n    console.log('我是宏队列1')\n    Promise.resolve(3).then(val => {\n        console.log('我是微队列' + val)\n    })\n}, 0)\nsetTimeout(() => {\n    console.log('我是宏队列2')\n\n}, 0)\nPromise.resolve(1).then(val => {\n    console.log('我是微队列' + val)\n})\nPromise.resolve(2).then(val => {\n    console.log('我是微队列' + val)\n})\n\nconsole.log('我是主线程')\n\n// 执行结果如下：\n// 我是主线程\n// 我是微队列1\n// 我是微队列2\n// 我是宏队列1\n// 我是微队列3\n// 我是宏队列2\n```\n\nJavascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。\n\n## JS 调用栈\n\nJS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。\n\n## 同步任务、异步任务\n\nJavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。\n\n## Event Loop\n\n调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。\n\n## 定时器\n\n定时器会开启一条定时器触发线程来触发计时，定时器会在等待了指定的时间后将事件放入到任务队列中等待读取到主线程执行。\n\n定时器指定的延时毫秒数其实并不准确，因为定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行。\n\n## 宏任务(macro-task)、微任务(micro-task)\n\n除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。JS 引擎首先必须先执行所有的初始化同步任务代码每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行。\n\nmacro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。\n\nmicro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。\n","source":"_posts/2020/05/事件循环 - 宏队列与微队列.md","raw":"---\ntitle: 事件循环 - 宏队列与微队列\ndate: 2020-05-16 18:16\nupdated: 2020-05-16 18:16\ntags: JS\n---\nJavaScript 事件循环机制分为浏览器和 Node 事件循环机制，两者的实现技术不一样，浏览器 Event Loop 是 HTML 中定义的规范，Node Event Loop 是由 libuv 库实现。这里主要讲的是浏览器部分。Node下的逻辑差不太多。\n\n<!-- more -->\n\n```javascript\nsetTimeout(() => {\n    console.log('我是宏队列1')\n    Promise.resolve(3).then(val => {\n        console.log('我是微队列' + val)\n    })\n}, 0)\nsetTimeout(() => {\n    console.log('我是宏队列2')\n\n}, 0)\nPromise.resolve(1).then(val => {\n    console.log('我是微队列' + val)\n})\nPromise.resolve(2).then(val => {\n    console.log('我是微队列' + val)\n})\n\nconsole.log('我是主线程')\n\n// 执行结果如下：\n// 我是主线程\n// 我是微队列1\n// 我是微队列2\n// 我是宏队列1\n// 我是微队列3\n// 我是宏队列2\n```\n\nJavascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。\n\n## JS 调用栈\n\nJS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。\n\n## 同步任务、异步任务\n\nJavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。\n\n## Event Loop\n\n调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。\n\n## 定时器\n\n定时器会开启一条定时器触发线程来触发计时，定时器会在等待了指定的时间后将事件放入到任务队列中等待读取到主线程执行。\n\n定时器指定的延时毫秒数其实并不准确，因为定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行。\n\n## 宏任务(macro-task)、微任务(micro-task)\n\n除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。JS 引擎首先必须先执行所有的初始化同步任务代码每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行。\n\nmacro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。\n\nmicro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。\n","slug":"事件循环 - 宏队列与微队列","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkk001k2yku305h9xct","content":"<p>JavaScript 事件循环机制分为浏览器和 Node 事件循环机制，两者的实现技术不一样，浏览器 Event Loop 是 HTML 中定义的规范，Node Event Loop 是由 libuv 库实现。这里主要讲的是浏览器部分。Node下的逻辑差不太多。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是宏队列1&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">3</span>).then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是微队列&#x27;</span> + val)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是宏队列2&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>).then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是微队列&#x27;</span> + val)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">2</span>).then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是微队列&#x27;</span> + val)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是主线程&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行结果如下：</span></span><br><span class=\"line\"><span class=\"comment\">// 我是主线程</span></span><br><span class=\"line\"><span class=\"comment\">// 我是微队列1</span></span><br><span class=\"line\"><span class=\"comment\">// 我是微队列2</span></span><br><span class=\"line\"><span class=\"comment\">// 我是宏队列1</span></span><br><span class=\"line\"><span class=\"comment\">// 我是微队列3</span></span><br><span class=\"line\"><span class=\"comment\">// 我是宏队列2</span></span><br></pre></td></tr></table></figure>\n\n<p>Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p>\n<h2 id=\"JS-调用栈\"><a href=\"#JS-调用栈\" class=\"headerlink\" title=\"JS 调用栈\"></a>JS 调用栈</h2><p>JS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。</p>\n<h2 id=\"同步任务、异步任务\"><a href=\"#同步任务、异步任务\" class=\"headerlink\" title=\"同步任务、异步任务\"></a>同步任务、异步任务</h2><p>JavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。</p>\n<h2 id=\"Event-Loop\"><a href=\"#Event-Loop\" class=\"headerlink\" title=\"Event Loop\"></a>Event Loop</h2><p>调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。</p>\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><p>定时器会开启一条定时器触发线程来触发计时，定时器会在等待了指定的时间后将事件放入到任务队列中等待读取到主线程执行。</p>\n<p>定时器指定的延时毫秒数其实并不准确，因为定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行。</p>\n<h2 id=\"宏任务-macro-task-、微任务-micro-task\"><a href=\"#宏任务-macro-task-、微任务-micro-task\" class=\"headerlink\" title=\"宏任务(macro-task)、微任务(micro-task)\"></a>宏任务(macro-task)、微任务(micro-task)</h2><p>除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。JS 引擎首先必须先执行所有的初始化同步任务代码每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行。</p>\n<p>macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</p>\n<p>micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。</p>\n","site":{"data":{}},"excerpt":"<p>JavaScript 事件循环机制分为浏览器和 Node 事件循环机制，两者的实现技术不一样，浏览器 Event Loop 是 HTML 中定义的规范，Node Event Loop 是由 libuv 库实现。这里主要讲的是浏览器部分。Node下的逻辑差不太多。</p>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是宏队列1&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">3</span>).then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是微队列&#x27;</span> + val)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是宏队列2&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>).then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是微队列&#x27;</span> + val)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">2</span>).then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是微队列&#x27;</span> + val)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是主线程&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行结果如下：</span></span><br><span class=\"line\"><span class=\"comment\">// 我是主线程</span></span><br><span class=\"line\"><span class=\"comment\">// 我是微队列1</span></span><br><span class=\"line\"><span class=\"comment\">// 我是微队列2</span></span><br><span class=\"line\"><span class=\"comment\">// 我是宏队列1</span></span><br><span class=\"line\"><span class=\"comment\">// 我是微队列3</span></span><br><span class=\"line\"><span class=\"comment\">// 我是宏队列2</span></span><br></pre></td></tr></table></figure>\n\n<p>Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p>\n<h2 id=\"JS-调用栈\"><a href=\"#JS-调用栈\" class=\"headerlink\" title=\"JS 调用栈\"></a>JS 调用栈</h2><p>JS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。</p>\n<h2 id=\"同步任务、异步任务\"><a href=\"#同步任务、异步任务\" class=\"headerlink\" title=\"同步任务、异步任务\"></a>同步任务、异步任务</h2><p>JavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。</p>\n<h2 id=\"Event-Loop\"><a href=\"#Event-Loop\" class=\"headerlink\" title=\"Event Loop\"></a>Event Loop</h2><p>调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。</p>\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><p>定时器会开启一条定时器触发线程来触发计时，定时器会在等待了指定的时间后将事件放入到任务队列中等待读取到主线程执行。</p>\n<p>定时器指定的延时毫秒数其实并不准确，因为定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行。</p>\n<h2 id=\"宏任务-macro-task-、微任务-micro-task\"><a href=\"#宏任务-macro-task-、微任务-micro-task\" class=\"headerlink\" title=\"宏任务(macro-task)、微任务(micro-task)\"></a>宏任务(macro-task)、微任务(micro-task)</h2><p>除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。JS 引擎首先必须先执行所有的初始化同步任务代码每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行。</p>\n<p>macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</p>\n<p>micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。</p>"},{"title":"可选链、双问号","date":"2020-05-16T09:16:00.000Z","updated":"2020-05-16T06:18:00.000Z","_content":"JS 新语法「可选链」「双问号」已在Node.js -v 14.0.0中启用。\n\n<!-- more -->\n\n```javascript\nconst result = response?.settings?.n ?? 100;\n```\n?. 的意思是，如果 ? 左边非否，那么继续读取，否则返回false\n?? 的意思是，如果 ?? 左边的值是 null 或者 undefined，那么就返回右边的值。\n","source":"_posts/2020/05/可选链、双问号.md","raw":"---\ntitle: 可选链、双问号\ndate: 2020-05-16 17:16\nupdated: 2020-05-16 14:18\ntags: JS\n---\nJS 新语法「可选链」「双问号」已在Node.js -v 14.0.0中启用。\n\n<!-- more -->\n\n```javascript\nconst result = response?.settings?.n ?? 100;\n```\n?. 的意思是，如果 ? 左边非否，那么继续读取，否则返回false\n?? 的意思是，如果 ?? 左边的值是 null 或者 undefined，那么就返回右边的值。\n","slug":"可选链、双问号","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkl001n2ykucicwfb9d","content":"<p>JS 新语法「可选链」「双问号」已在Node.js -v 14.0.0中启用。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> result = response?.settings?.n ?? <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n<p>?. 的意思是，如果 ? 左边非否，那么继续读取，否则返回false<br>?? 的意思是，如果 ?? 左边的值是 null 或者 undefined，那么就返回右边的值。</p>\n","site":{"data":{}},"excerpt":"<p>JS 新语法「可选链」「双问号」已在Node.js -v 14.0.0中启用。</p>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> result = response?.settings?.n ?? <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n<p>?. 的意思是，如果 ? 左边非否，那么继续读取，否则返回false<br>?? 的意思是，如果 ?? 左边的值是 null 或者 undefined，那么就返回右边的值。</p>"},{"title":"相对合理的js对象深拷贝方法","date":"2020-05-16T06:48:00.000Z","updated":"2020-05-15T06:48:00.000Z","_content":"如果你不需要循环对象，也不需要保留内置类型，那么你可以使用`JSON.parse(JSON.stringify())`在所有浏览器中获得*最快*的克隆。 \n如果你想要一个合适的结构化克隆，`MessageChannel`是你唯一可靠的跨浏览器选择。 \n\n<!-- more -->\n\n利用信道的结构化克隆算法实现深拷贝（异步）\n```javascript\nfunction structuralClone(obj) {\n    return new Promise(resolve => {\n        const { port1, port2 } = new MessageChannel();\n        port2.onmessage = ev => resolve(ev.data);\n        port1.postMessage(obj);\n    });\n}\n\nconst obj = { a: 1, b: { t: 12 } };\nconst clone = await structuralClone(obj);\n```\n","source":"_posts/2020/05/相对合理的js对象深拷贝方法.md","raw":"---\ntitle: 相对合理的js对象深拷贝方法\ndate: 2020-05-16 14:48\nupdated: 2020-05-15 14:48\ntags: JS\n---\n如果你不需要循环对象，也不需要保留内置类型，那么你可以使用`JSON.parse(JSON.stringify())`在所有浏览器中获得*最快*的克隆。 \n如果你想要一个合适的结构化克隆，`MessageChannel`是你唯一可靠的跨浏览器选择。 \n\n<!-- more -->\n\n利用信道的结构化克隆算法实现深拷贝（异步）\n```javascript\nfunction structuralClone(obj) {\n    return new Promise(resolve => {\n        const { port1, port2 } = new MessageChannel();\n        port2.onmessage = ev => resolve(ev.data);\n        port1.postMessage(obj);\n    });\n}\n\nconst obj = { a: 1, b: { t: 12 } };\nconst clone = await structuralClone(obj);\n```\n","slug":"相对合理的js对象深拷贝方法","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkm001p2ykueign249s","content":"<p>如果你不需要循环对象，也不需要保留内置类型，那么你可以使用<code>JSON.parse(JSON.stringify())</code>在所有浏览器中获得<em>最快</em>的克隆。 <br>如果你想要一个合适的结构化克隆，<code>MessageChannel</code>是你唯一可靠的跨浏览器选择。 </p>\n<a id=\"more\"></a>\n\n<p>利用信道的结构化克隆算法实现深拷贝（异步）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">structuralClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; port1, port2 &#125; = <span class=\"keyword\">new</span> MessageChannel();</span><br><span class=\"line\">        port2.onmessage = <span class=\"function\"><span class=\"params\">ev</span> =&gt;</span> resolve(ev.data);</span><br><span class=\"line\">        port1.postMessage(obj);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: &#123; <span class=\"attr\">t</span>: <span class=\"number\">12</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> clone = <span class=\"keyword\">await</span> structuralClone(obj);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>如果你不需要循环对象，也不需要保留内置类型，那么你可以使用<code>JSON.parse(JSON.stringify())</code>在所有浏览器中获得<em>最快</em>的克隆。 <br>如果你想要一个合适的结构化克隆，<code>MessageChannel</code>是你唯一可靠的跨浏览器选择。 </p>","more":"<p>利用信道的结构化克隆算法实现深拷贝（异步）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">structuralClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; port1, port2 &#125; = <span class=\"keyword\">new</span> MessageChannel();</span><br><span class=\"line\">        port2.onmessage = <span class=\"function\"><span class=\"params\">ev</span> =&gt;</span> resolve(ev.data);</span><br><span class=\"line\">        port1.postMessage(obj);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: &#123; <span class=\"attr\">t</span>: <span class=\"number\">12</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> clone = <span class=\"keyword\">await</span> structuralClone(obj);</span><br></pre></td></tr></table></figure>"},{"title":"短信验证接口的保护方案","date":"2020-05-27T06:54:50.000Z","updated":"2020-05-27T06:54:50.000Z","_content":"和网友们讨论这个话题，整理一下结论\n\n<!-- more -->\n\n1. 增加图形验证码，并确定有效\n2. 校验图形验证码获取和校验的时间间隔 不能太短也不能太长\n3. 校验图形验证码获取和校验时候的 ip 是否一样 一般用户不会频繁切换 ip\n4. 校验 session 存活时间 是否 合理\n5. 校验是否请求了必定会请求的页面（图片，css 等都可以）\n6. 不提示具体验证错误原因\n","source":"_posts/2020/05/短信验证接口的保护方案.md","raw":"---\ntitle: 短信验证接口的保护方案\ndate: 2020-05-27 14:54:50\nupdated: 2020-05-27 14:54:50\ntags: 杂谈\n---\n和网友们讨论这个话题，整理一下结论\n\n<!-- more -->\n\n1. 增加图形验证码，并确定有效\n2. 校验图形验证码获取和校验的时间间隔 不能太短也不能太长\n3. 校验图形验证码获取和校验时候的 ip 是否一样 一般用户不会频繁切换 ip\n4. 校验 session 存活时间 是否 合理\n5. 校验是否请求了必定会请求的页面（图片，css 等都可以）\n6. 不提示具体验证错误原因\n","slug":"短信验证接口的保护方案","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkn001s2yku5hps88pk","content":"<p>和网友们讨论这个话题，整理一下结论</p>\n<a id=\"more\"></a>\n\n<ol>\n<li>增加图形验证码，并确定有效</li>\n<li>校验图形验证码获取和校验的时间间隔 不能太短也不能太长</li>\n<li>校验图形验证码获取和校验时候的 ip 是否一样 一般用户不会频繁切换 ip</li>\n<li>校验 session 存活时间 是否 合理</li>\n<li>校验是否请求了必定会请求的页面（图片，css 等都可以）</li>\n<li>不提示具体验证错误原因</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>和网友们讨论这个话题，整理一下结论</p>","more":"<ol>\n<li>增加图形验证码，并确定有效</li>\n<li>校验图形验证码获取和校验的时间间隔 不能太短也不能太长</li>\n<li>校验图形验证码获取和校验时候的 ip 是否一样 一般用户不会频繁切换 ip</li>\n<li>校验 session 存活时间 是否 合理</li>\n<li>校验是否请求了必定会请求的页面（图片，css 等都可以）</li>\n<li>不提示具体验证错误原因</li>\n</ol>"},{"title":"js事件循环题目","date":"2020-05-21T05:31:57.000Z","updated":"2020-05-21T05:31:57.000Z","_content":"\n学完后，自己出的一道题，考验对js事件循环的理解，可以给面试加上。\n\n<!-- more -->\n\n```javascript\nfunction fun1(a) {\n    console.log(1.1);\n    setTimeout(() => console.log(a), 0);\n}\n\nasync function fun2(a) {\n    console.log(0.1+a);\n    await setTimeout(() => console.log(a), 0);\n    console.log(0.2+a)\n}\n\n(async () => {\n    setTimeout(() => console.log(\"x\"), 0);\n    fun2(2);\n    await fun2(3);\n    await fun1(1);\n    fun2(4);\n})();\n\n```\n\n\n答案：\n\n\n2.1\n3.1\n2.2\n3.2\n1.1\n4.1\n4.2\nx\n2\n3\n1\n4\n","source":"_posts/2020/05/自己出的一道题，考验对js事件循环的理解.md","raw":"---\ntitle: js事件循环题目\ndate: 2020-05-21 13:31:57\nupdated: 2020-05-21 13:31:57\ntags: JS\n---\n\n学完后，自己出的一道题，考验对js事件循环的理解，可以给面试加上。\n\n<!-- more -->\n\n```javascript\nfunction fun1(a) {\n    console.log(1.1);\n    setTimeout(() => console.log(a), 0);\n}\n\nasync function fun2(a) {\n    console.log(0.1+a);\n    await setTimeout(() => console.log(a), 0);\n    console.log(0.2+a)\n}\n\n(async () => {\n    setTimeout(() => console.log(\"x\"), 0);\n    fun2(2);\n    await fun2(3);\n    await fun1(1);\n    fun2(4);\n})();\n\n```\n\n\n答案：\n\n\n2.1\n3.1\n2.2\n3.2\n1.1\n4.1\n4.2\nx\n2\n3\n1\n4\n","slug":"自己出的一道题，考验对js事件循环的理解","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrko001u2ykud6gn3n51","content":"<p>学完后，自己出的一道题，考验对js事件循环的理解，可以给面试加上。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1.1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(a), <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun2</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0.1</span>+a);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(a), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0.2</span>+a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;x&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">    fun2(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> fun2(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> fun1(<span class=\"number\">1</span>);</span><br><span class=\"line\">    fun2(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>答案：</p>\n<p>2.1<br>3.1<br>2.2<br>3.2<br>1.1<br>4.1<br>4.2<br>x<br>2<br>3<br>1<br>4</p>\n","site":{"data":{}},"excerpt":"<p>学完后，自己出的一道题，考验对js事件循环的理解，可以给面试加上。</p>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1.1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(a), <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun2</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0.1</span>+a);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(a), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0.2</span>+a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;x&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">    fun2(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> fun2(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> fun1(<span class=\"number\">1</span>);</span><br><span class=\"line\">    fun2(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>答案：</p>\n<p>2.1<br>3.1<br>2.2<br>3.2<br>1.1<br>4.1<br>4.2<br>x<br>2<br>3<br>1<br>4</p>"},{"title":"记一次客户端上执行表重构发生的接口挂起","date":"2020-05-19T13:02:03.000Z","updated":"2020-05-19T13:02:03.000Z","_content":"前因：我在Navicat上为一张一百多万行的表增加注释。\n\n<!-- more -->\n\n点击保存后一分钟，请求超时，连接被关闭。\n\n本以为只是一个不大的表，很快就会完成，遂不再管它。但是过了半小时，用户反馈网站无法打开。\n使用Postman测试开放接口无响应，但有登录限制的接口正常返回401。这里就已经反映出问题发生在接口内部。\n\n正当束手无策时，数据组发现数据库进程里有一条执行了很久的进程，附带我的注释信息。\n\n---\n\n问题确认了，在增加注释时，mysql会锁住整个表（所有alter操作都会）。\n\n一百多万的数据并不大，本不应至此，但navicat应对数据量大/持续时间长的命令有时会出错，或超时断开连接。所以，这类非select命令尽量使用命令行来执行。\n\n\n经验和教训：\n0.alter线上数据库的操作不要用客户端\n1.大表alter要慎重\n2.Sequelize未配置数据库超时限制\n\n","source":"_posts/2020/05/记一次客户端上执行表重构发生的接口挂起.md","raw":"---\ntitle: 记一次客户端上执行表重构发生的接口挂起\ndate: 2020-05-19 21:02:03\nupdated: 2020-05-19 21:02:03\ntags: 数据库\n---\n前因：我在Navicat上为一张一百多万行的表增加注释。\n\n<!-- more -->\n\n点击保存后一分钟，请求超时，连接被关闭。\n\n本以为只是一个不大的表，很快就会完成，遂不再管它。但是过了半小时，用户反馈网站无法打开。\n使用Postman测试开放接口无响应，但有登录限制的接口正常返回401。这里就已经反映出问题发生在接口内部。\n\n正当束手无策时，数据组发现数据库进程里有一条执行了很久的进程，附带我的注释信息。\n\n---\n\n问题确认了，在增加注释时，mysql会锁住整个表（所有alter操作都会）。\n\n一百多万的数据并不大，本不应至此，但navicat应对数据量大/持续时间长的命令有时会出错，或超时断开连接。所以，这类非select命令尽量使用命令行来执行。\n\n\n经验和教训：\n0.alter线上数据库的操作不要用客户端\n1.大表alter要慎重\n2.Sequelize未配置数据库超时限制\n\n","slug":"记一次客户端上执行表重构发生的接口挂起","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkp001x2ykufy0d43tp","content":"<p>前因：我在Navicat上为一张一百多万行的表增加注释。</p>\n<a id=\"more\"></a>\n\n<p>点击保存后一分钟，请求超时，连接被关闭。</p>\n<p>本以为只是一个不大的表，很快就会完成，遂不再管它。但是过了半小时，用户反馈网站无法打开。<br>使用Postman测试开放接口无响应，但有登录限制的接口正常返回401。这里就已经反映出问题发生在接口内部。</p>\n<p>正当束手无策时，数据组发现数据库进程里有一条执行了很久的进程，附带我的注释信息。</p>\n<hr>\n<p>问题确认了，在增加注释时，mysql会锁住整个表（所有alter操作都会）。</p>\n<p>一百多万的数据并不大，本不应至此，但navicat应对数据量大/持续时间长的命令有时会出错，或超时断开连接。所以，这类非select命令尽量使用命令行来执行。</p>\n<p>经验和教训：<br>0.alter线上数据库的操作不要用客户端<br>1.大表alter要慎重<br>2.Sequelize未配置数据库超时限制</p>\n","site":{"data":{}},"excerpt":"<p>前因：我在Navicat上为一张一百多万行的表增加注释。</p>","more":"<p>点击保存后一分钟，请求超时，连接被关闭。</p>\n<p>本以为只是一个不大的表，很快就会完成，遂不再管它。但是过了半小时，用户反馈网站无法打开。<br>使用Postman测试开放接口无响应，但有登录限制的接口正常返回401。这里就已经反映出问题发生在接口内部。</p>\n<p>正当束手无策时，数据组发现数据库进程里有一条执行了很久的进程，附带我的注释信息。</p>\n<hr>\n<p>问题确认了，在增加注释时，mysql会锁住整个表（所有alter操作都会）。</p>\n<p>一百多万的数据并不大，本不应至此，但navicat应对数据量大/持续时间长的命令有时会出错，或超时断开连接。所以，这类非select命令尽量使用命令行来执行。</p>\n<p>经验和教训：<br>0.alter线上数据库的操作不要用客户端<br>1.大表alter要慎重<br>2.Sequelize未配置数据库超时限制</p>"},{"title":"Koa和Express的区别","date":"2020-04-04T10:31:39.000Z","updated":"2020-04-03T16:00:00.000Z","_content":"\n1. Express 和 Koa 最明显的差别就是 Handler 的处理方法，一个是普通的回调函数，在同一线程上完成当前进程的所有Http请求；一个是利用生成器函数（Generator Function）来作为响应器，co作为底层运行框架，利用Generator特性，实现“协程响应”。\n2. Express有回调，而Koa没有，借助 promise 和 generator 的能力，丢掉了 callback，完美解决异步组合问题和异步异常捕获问题。\n3. Koa新增了一个Context对象，用来代替Express的Request和Response，作为请求的上下文对象。\n4. Express 是 Web Framework，而Koa更像是一个中间件框架，其提供的是一个架子，而几乎所有的功能都需要由第三方中间件完成，比如路由。\n","source":"_posts/2020/04/Koa和Express的区别.md","raw":"---\ntitle: Koa和Express的区别\ndate: 2020-04-04 18:31:39\nupdated: 2020-04-04\ntags: Node.js\n---\n\n1. Express 和 Koa 最明显的差别就是 Handler 的处理方法，一个是普通的回调函数，在同一线程上完成当前进程的所有Http请求；一个是利用生成器函数（Generator Function）来作为响应器，co作为底层运行框架，利用Generator特性，实现“协程响应”。\n2. Express有回调，而Koa没有，借助 promise 和 generator 的能力，丢掉了 callback，完美解决异步组合问题和异步异常捕获问题。\n3. Koa新增了一个Context对象，用来代替Express的Request和Response，作为请求的上下文对象。\n4. Express 是 Web Framework，而Koa更像是一个中间件框架，其提供的是一个架子，而几乎所有的功能都需要由第三方中间件完成，比如路由。\n","slug":"Koa和Express的区别","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkq001z2yku03fwduo3","content":"<ol>\n<li>Express 和 Koa 最明显的差别就是 Handler 的处理方法，一个是普通的回调函数，在同一线程上完成当前进程的所有Http请求；一个是利用生成器函数（Generator Function）来作为响应器，co作为底层运行框架，利用Generator特性，实现“协程响应”。</li>\n<li>Express有回调，而Koa没有，借助 promise 和 generator 的能力，丢掉了 callback，完美解决异步组合问题和异步异常捕获问题。</li>\n<li>Koa新增了一个Context对象，用来代替Express的Request和Response，作为请求的上下文对象。</li>\n<li>Express 是 Web Framework，而Koa更像是一个中间件框架，其提供的是一个架子，而几乎所有的功能都需要由第三方中间件完成，比如路由。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>Express 和 Koa 最明显的差别就是 Handler 的处理方法，一个是普通的回调函数，在同一线程上完成当前进程的所有Http请求；一个是利用生成器函数（Generator Function）来作为响应器，co作为底层运行框架，利用Generator特性，实现“协程响应”。</li>\n<li>Express有回调，而Koa没有，借助 promise 和 generator 的能力，丢掉了 callback，完美解决异步组合问题和异步异常捕获问题。</li>\n<li>Koa新增了一个Context对象，用来代替Express的Request和Response，作为请求的上下文对象。</li>\n<li>Express 是 Web Framework，而Koa更像是一个中间件框架，其提供的是一个架子，而几乎所有的功能都需要由第三方中间件完成，比如路由。</li>\n</ol>\n"},{"title":"MAX() 和 ORDER BY LIMIT 的比较","date":"2020-05-20T05:21:25.000Z","updated":"2020-05-20T05:21:25.000Z","_content":"\n查询某字段的最大值，一般有两种方法：\n\n```\nSELECT MAX(date) date FROM form_name\nSELECT date FROM form_name ORDER BY date LIMIT 1\n```\n\n<!-- more -->\n\n## explain结果：\n| 1 | id | select_type | table | partitions | type | possible_keys | key| key_len | ref | rows | filtered | Extra |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 有索引MAX | 1 | SIMPLE | null | null | null | null | null | null | null | null | null | Select tables optimized away |\n| 有索引LIMIT | 1 | SIMPLE | form_name | null | index | null | ix_ form_name_date | 5 | null | 1 | 100.00 | Using index |\n| 无索引MAX | 1 | SIMPLE | form_name | null | ALL | null | null | null | null | 1216666 | 100.00 | null |\n| 无索引LIMIT | 1 | SIMPLE | form_name | null | index | null | ix_live_stream_date | 5 | null | 1 | 100.00 | Using index |\n最坏的情况，就是没有对 filed 添加索引的情况下。使用 MIN() 或 MAX() 需要单次读取所有的表数据，而使用 ORDER BY LIMII 则首先需要文件排序。\n\n如果数据量超大，那么性能的差异是很明显的。在我的测试机上 ORDER BY LIMIT 往往需要两倍 MIN()/MAX() 的时间。\n\n但是，如果对 field 字段添加了索引，那么差距就不那么明显了。MIN()/MAX() 可以直接从索引中获取最大值和最小值。但 ORDER BY LIMII 仍然需要对索引进行排序。实际的差异可能就微不足道了。\n\n从上面的论述来看，MIN()/MAX() 可能是更好的选择，因为最坏的情况下它更好，最好的情况下差不多。\n\nORDER BY LIMIT 的使用场景，应该用来查询 TOP N 或者 LOWER N 且 N > 1 这种数据。也就是说获取前 N 条数据列表这种非特例的操作。\n","source":"_posts/2020/04/MAX-和-ORDER-BY-LIMIT-的比较.md","raw":"---\ntitle: MAX() 和 ORDER BY LIMIT 的比较\ndate: 2020-05-20 13:21:25\nupdated: 2020-05-20 13:21:25\ntags: 数据库\n---\n\n查询某字段的最大值，一般有两种方法：\n\n```\nSELECT MAX(date) date FROM form_name\nSELECT date FROM form_name ORDER BY date LIMIT 1\n```\n\n<!-- more -->\n\n## explain结果：\n| 1 | id | select_type | table | partitions | type | possible_keys | key| key_len | ref | rows | filtered | Extra |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 有索引MAX | 1 | SIMPLE | null | null | null | null | null | null | null | null | null | Select tables optimized away |\n| 有索引LIMIT | 1 | SIMPLE | form_name | null | index | null | ix_ form_name_date | 5 | null | 1 | 100.00 | Using index |\n| 无索引MAX | 1 | SIMPLE | form_name | null | ALL | null | null | null | null | 1216666 | 100.00 | null |\n| 无索引LIMIT | 1 | SIMPLE | form_name | null | index | null | ix_live_stream_date | 5 | null | 1 | 100.00 | Using index |\n最坏的情况，就是没有对 filed 添加索引的情况下。使用 MIN() 或 MAX() 需要单次读取所有的表数据，而使用 ORDER BY LIMII 则首先需要文件排序。\n\n如果数据量超大，那么性能的差异是很明显的。在我的测试机上 ORDER BY LIMIT 往往需要两倍 MIN()/MAX() 的时间。\n\n但是，如果对 field 字段添加了索引，那么差距就不那么明显了。MIN()/MAX() 可以直接从索引中获取最大值和最小值。但 ORDER BY LIMII 仍然需要对索引进行排序。实际的差异可能就微不足道了。\n\n从上面的论述来看，MIN()/MAX() 可能是更好的选择，因为最坏的情况下它更好，最好的情况下差不多。\n\nORDER BY LIMIT 的使用场景，应该用来查询 TOP N 或者 LOWER N 且 N > 1 这种数据。也就是说获取前 N 条数据列表这种非特例的操作。\n","slug":"MAX-和-ORDER-BY-LIMIT-的比较","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkr00222yku7davb1xo","content":"<p>查询某字段的最大值，一般有两种方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT MAX(date) date FROM form_name</span><br><span class=\"line\">SELECT date FROM form_name ORDER BY date LIMIT 1</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h2 id=\"explain结果：\"><a href=\"#explain结果：\" class=\"headerlink\" title=\"explain结果：\"></a>explain结果：</h2><table>\n<thead>\n<tr>\n<th align=\"center\">1</th>\n<th align=\"center\">id</th>\n<th align=\"center\">select_type</th>\n<th align=\"center\">table</th>\n<th align=\"center\">partitions</th>\n<th align=\"center\">type</th>\n<th align=\"center\">possible_keys</th>\n<th align=\"center\">key</th>\n<th align=\"center\">key_len</th>\n<th align=\"center\">ref</th>\n<th align=\"center\">rows</th>\n<th align=\"center\">filtered</th>\n<th align=\"center\">Extra</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">有索引MAX</td>\n<td align=\"center\">1</td>\n<td align=\"center\">SIMPLE</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">Select tables optimized away</td>\n</tr>\n<tr>\n<td align=\"center\">有索引LIMIT</td>\n<td align=\"center\">1</td>\n<td align=\"center\">SIMPLE</td>\n<td align=\"center\">form_name</td>\n<td align=\"center\">null</td>\n<td align=\"center\">index</td>\n<td align=\"center\">null</td>\n<td align=\"center\">ix_ form_name_date</td>\n<td align=\"center\">5</td>\n<td align=\"center\">null</td>\n<td align=\"center\">1</td>\n<td align=\"center\">100.00</td>\n<td align=\"center\">Using index</td>\n</tr>\n<tr>\n<td align=\"center\">无索引MAX</td>\n<td align=\"center\">1</td>\n<td align=\"center\">SIMPLE</td>\n<td align=\"center\">form_name</td>\n<td align=\"center\">null</td>\n<td align=\"center\">ALL</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">1216666</td>\n<td align=\"center\">100.00</td>\n<td align=\"center\">null</td>\n</tr>\n<tr>\n<td align=\"center\">无索引LIMIT</td>\n<td align=\"center\">1</td>\n<td align=\"center\">SIMPLE</td>\n<td align=\"center\">form_name</td>\n<td align=\"center\">null</td>\n<td align=\"center\">index</td>\n<td align=\"center\">null</td>\n<td align=\"center\">ix_live_stream_date</td>\n<td align=\"center\">5</td>\n<td align=\"center\">null</td>\n<td align=\"center\">1</td>\n<td align=\"center\">100.00</td>\n<td align=\"center\">Using index</td>\n</tr>\n<tr>\n<td align=\"center\">最坏的情况，就是没有对 filed 添加索引的情况下。使用 MIN() 或 MAX() 需要单次读取所有的表数据，而使用 ORDER BY LIMII 则首先需要文件排序。</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>如果数据量超大，那么性能的差异是很明显的。在我的测试机上 ORDER BY LIMIT 往往需要两倍 MIN()/MAX() 的时间。</p>\n<p>但是，如果对 field 字段添加了索引，那么差距就不那么明显了。MIN()/MAX() 可以直接从索引中获取最大值和最小值。但 ORDER BY LIMII 仍然需要对索引进行排序。实际的差异可能就微不足道了。</p>\n<p>从上面的论述来看，MIN()/MAX() 可能是更好的选择，因为最坏的情况下它更好，最好的情况下差不多。</p>\n<p>ORDER BY LIMIT 的使用场景，应该用来查询 TOP N 或者 LOWER N 且 N &gt; 1 这种数据。也就是说获取前 N 条数据列表这种非特例的操作。</p>\n","site":{"data":{}},"excerpt":"<p>查询某字段的最大值，一般有两种方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT MAX(date) date FROM form_name</span><br><span class=\"line\">SELECT date FROM form_name ORDER BY date LIMIT 1</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"explain结果：\"><a href=\"#explain结果：\" class=\"headerlink\" title=\"explain结果：\"></a>explain结果：</h2><table>\n<thead>\n<tr>\n<th align=\"center\">1</th>\n<th align=\"center\">id</th>\n<th align=\"center\">select_type</th>\n<th align=\"center\">table</th>\n<th align=\"center\">partitions</th>\n<th align=\"center\">type</th>\n<th align=\"center\">possible_keys</th>\n<th align=\"center\">key</th>\n<th align=\"center\">key_len</th>\n<th align=\"center\">ref</th>\n<th align=\"center\">rows</th>\n<th align=\"center\">filtered</th>\n<th align=\"center\">Extra</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">有索引MAX</td>\n<td align=\"center\">1</td>\n<td align=\"center\">SIMPLE</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">Select tables optimized away</td>\n</tr>\n<tr>\n<td align=\"center\">有索引LIMIT</td>\n<td align=\"center\">1</td>\n<td align=\"center\">SIMPLE</td>\n<td align=\"center\">form_name</td>\n<td align=\"center\">null</td>\n<td align=\"center\">index</td>\n<td align=\"center\">null</td>\n<td align=\"center\">ix_ form_name_date</td>\n<td align=\"center\">5</td>\n<td align=\"center\">null</td>\n<td align=\"center\">1</td>\n<td align=\"center\">100.00</td>\n<td align=\"center\">Using index</td>\n</tr>\n<tr>\n<td align=\"center\">无索引MAX</td>\n<td align=\"center\">1</td>\n<td align=\"center\">SIMPLE</td>\n<td align=\"center\">form_name</td>\n<td align=\"center\">null</td>\n<td align=\"center\">ALL</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">null</td>\n<td align=\"center\">1216666</td>\n<td align=\"center\">100.00</td>\n<td align=\"center\">null</td>\n</tr>\n<tr>\n<td align=\"center\">无索引LIMIT</td>\n<td align=\"center\">1</td>\n<td align=\"center\">SIMPLE</td>\n<td align=\"center\">form_name</td>\n<td align=\"center\">null</td>\n<td align=\"center\">index</td>\n<td align=\"center\">null</td>\n<td align=\"center\">ix_live_stream_date</td>\n<td align=\"center\">5</td>\n<td align=\"center\">null</td>\n<td align=\"center\">1</td>\n<td align=\"center\">100.00</td>\n<td align=\"center\">Using index</td>\n</tr>\n<tr>\n<td align=\"center\">最坏的情况，就是没有对 filed 添加索引的情况下。使用 MIN() 或 MAX() 需要单次读取所有的表数据，而使用 ORDER BY LIMII 则首先需要文件排序。</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>如果数据量超大，那么性能的差异是很明显的。在我的测试机上 ORDER BY LIMIT 往往需要两倍 MIN()/MAX() 的时间。</p>\n<p>但是，如果对 field 字段添加了索引，那么差距就不那么明显了。MIN()/MAX() 可以直接从索引中获取最大值和最小值。但 ORDER BY LIMII 仍然需要对索引进行排序。实际的差异可能就微不足道了。</p>\n<p>从上面的论述来看，MIN()/MAX() 可能是更好的选择，因为最坏的情况下它更好，最好的情况下差不多。</p>\n<p>ORDER BY LIMIT 的使用场景，应该用来查询 TOP N 或者 LOWER N 且 N &gt; 1 这种数据。也就是说获取前 N 条数据列表这种非特例的操作。</p>"},{"title":"Node.js多线程","date":"2020-04-13T07:17:49.000Z","updated":"2020-04-17T06:42:23.000Z","_content":"\n# 前言\nNode.js 通过提供 cluster、child_process API 创建 **子进程** 的方式来赋予Node.js“多线程”能力。但是这种创建进程的方式会**牺牲共享内存**，并且数据通信必须通过json进行传输。（有一定的局限性和性能问题）\n\n基于此 Node.js V10.5.0 提供了 worker_threads，它比 child_process 或 cluster更轻量级。worker_threads 的出现让 Node.js 拥有**多工作线程**。\n\n与 child_process 或 cluster 不同，worker_threads 可以共享内存，通过传输 ArrayBuffer 实例或共享 SharedArrayBuffer 实例来实现。\n\n<!-- more -->\n\n# 一、child_process（子进程）\nnode的单线程使得在主线程不能进行CPU密集型操作，否则会阻塞主线程。对于CPU密集型操作，在node中通过child_process可以创建独立的子进程，父子进程通过IPC通信，子进程可以是外部应用也可以是node子程序，子进程执行后可以将结果返回给父进程。\n\n## 创建子进程\n\n### 1.spawn ： 子进程中执行的是非node程序，提供一组参数后，执行的结果以流的形式返回。\nspawn同样是用于执行非node应用，且不能直接执行shell，与`execFile`相比，`spawn`执行应用后的结果并不是执行完成后一次性的输出的，而是以流的形式输出。\n\n```javascript\nlet cp = require('child_process');\nlet cat = cp.spawn('cat', ['input.txt']);\nlet sort = cp.spawn('sort');\nlet uniq = cp.spawn('uniq');\n\ncat.stdout.pipe(sort.stdin);\nsort.stdout.pipe(uniq.stdin);\nuniq.stdout.pipe(process.stdout);\nconsole.log(process.stdout);\n```\n\n执行后，最后的结果将输入到process.stdout中。如果input.txt这个文件较大，那么以流的形式输入输出可以明显减小内存的占用，通过设置缓冲区的形式，减小内存占用的同时也可以提高输入输出的效率。\n\n### 2.execFile：子进程中执行的是非node程序，是一个应用，提供一组参数后，执行的结果以回调的形式返回。\n\n````javascript\nchild_process.execFile('echo', ['hello', 'world'], function (err, stdout) {\n    console.log(stdout);// hello world\n});\n````\n\nexecFile类似于执行了名为echo的应用，然后传入参数。execFlie会在process.env.PATH的路径中依次寻找是否有名为'echo'的应用，找到后就会执行。默认的process.env.PATH路径中包含了'usr/local/bin'，而这个'usr/local/bin'目录中就存在了这个名为'echo'的程序，传入hello和world两个参数，执行后返回。\n\n### 3.exec：子进程执行的是非node程序，传入一串shell命令，执行后结果以回调的形式返回。\n\n````javascript\nchild_process.exec('echo hello world', function (err, stdout) {\n    console.log(stdout);// hello world\n});\n````\n\n### 4.fork：子进程执行的是node程序，提供一组参数后，执行的结果以流的形式返回，与`spawn`不同，`fork`生成的子进程只能执行node应用。\n\n在javascript中，在处理大量计算的任务方面，HTML里面通过web work来实现，使得任务脱离了主线程。node中提供了fork方法，通过fork方法在单独的进程中执行node程序，并且通过父子间的IPC通道通信，子进程接受父进程的信息，并将执行后的结果返回给父进程。\n\n在子进程中：\n\n**通过 process.on('message') 和 process.send() 的机制来接收和发送消息。**\n\n在父进程中：\n\n**通过 child.on('message') 和 child.send() 的机制来接收和发送消息。**\n\n具体例子，在child.js中：\n````javascript\nprocess.on('message', function (msg) {\n    process.send(msg)\n})\n````\n在parent.js中：\n````javascript\nlet child_process = require('child_process');\nlet child = child_process.fork('./child');\nchild.on('message', function (msg) {\n    console.log('got a message is', msg);\n});\nchild.send('hello world');\n````\n执行parent.js会在命令行输出：got a message is hello world\n\n### 同步执行的子进程\nexec、execFile、spawn和fork执行的子进程都是默认异步的，子进程的运行不会阻塞主进程。除此之外，child_process模块同样也提供了execFileSync、spawnSync和execSync来实现同步的方式执行子进程。\n\n## 其他方法\n\n### subprocess.disconnect()\n关闭父进程与子进程之间的 IPC 通道，一旦没有其他的连接使其保持活跃，则允许子进程正常退出。\n可以通过在父进程中调用：`child.disconnect()`来实现断开父子间IPC通信。\n当子进程是一个 Node.js 实例时（例如使用 `child_process.fork()` 衍生），也可以在子进程中调用 `process.disconnect()` 方法来关闭 IPC 通道。\n\n### subprocess.kill([signal])\n向子进程发送一个信号。 如果没有给定参数，则进程将会发送 'SIGTERM' 信号。 如果 kill() 成功，则此函数返回 true，否则返回 false。\n\n\n# 二、cluster（集群）\nnode的单线程，以单一进程运行，因此无法利用多核CPU以及其他资源，为了调度多核CPU等资源，node还提供了cluster模块，利用多核CPU的资源，使得可以通过一串node子进程去处理负载任务，同时保证一定的负载均衡性。\n\ncluster 底层就是 child_process，它通过一个**父进程**管理一堆**子进程**的方式来实现集群的功能。master 进程做总控，启动 1 个 agent 和 n 个 worker，agent 来做任务调度，获取任务，并分配给某个空闲的 worker 来做。\n\n官网例子：\n\n```javascript\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n    console.log(`主进程 ${process.pid} 正在运行`);\n\n    // 衍生工作进程。\n    for (let i = 0; i < numCPUs; i++) {\n        cluster.fork();\n    }\n\n    cluster.on('exit', (worker, code, signal) => {\n        console.log(`工作进程 ${worker.process.pid} 已退出，code：${code}，signal：${signal}`);\n    });\n} else {\n    // 工作进程可以共享任何 TCP 连接。\n    // 在本例子中，共享的是 HTTP 服务器。\n    http.createServer((req, res) => {\n        res.writeHead(200);\n        res.end('你好世界\\n');\n    }).listen(8000);\n\n    console.log(`工作进程 ${process.pid} 已启动`);\n}\n```\n\n# 三、worker_threads（工作线程）\n工作线程对于执行 CPU 密集型的 JavaScript 操作非常有用。 它们在 I/O 密集型的工作中用途不大。 Node.js 的内置的异步 I/O 操作比工作线程效率更高。\n\n官方例子：\n\n```javascript\nconst {Worker, isMainThread, parentPort, workerData} = require('worker_threads');\n\nif (isMainThread) {\n    module.exports = function parseJSAsync(script) {\n        return new Promise((resolve, reject) => {\n            const worker = new Worker(__filename, {\n                workerData: script\n            });\n            worker.on('message', resolve);\n            worker.on('error', reject);\n            worker.on('exit', (code) => {\n                if (code !== 0)\n                    reject(new Error(`工作线程使用退出码 ${code} 停止`));\n            });\n        });\n    };\n} else {\n    const {parse} = require('一些 js 解析库');\n    const script = workerData;\n    parentPort.postMessage(parse(script));\n}\n```\n\n## 重要方法\n\n### port.postMessage(value[, transferList])\n - value <any> 传输值（或指针）\n - transferList <Object[]> 传输内存（指针指向的）\n \n将JavaScript值发送到此通道的接收端。值将以与HTML结构化克隆算法兼容的方式进行传输。\n\n特别是，与JSON的显着区别是：\n\n`value`可能包含循环引用。\n`value`可能包含内置JS类型的实例，例如RegExps，BigInts，Maps，Sets等。\n`value`可能包含使用`ArrayBuffers`和`SharedArrayBuffers`的类型化数组。\n`value`可能包含`WebAssembly.Module`实例。\n`value`可能不包含`MessagePort`s以外的本机（C ++支持）对象。\n\n```javascript\nconst { MessageChannel } = require('worker_threads');\nconst { port1, port2 } = new MessageChannel();\n\nport1.on('message', (message) => console.log(message));\n\nconst circularData = {};\ncircularData.foo = circularData;// 循环引用\n// Prints: { foo: [Circular] }\nport2.postMessage(circularData);\n```\n\n`transferList`可能是`ArrayBuffer`和`MessagePort`对象的列表。传输后，它们将不再在通道的发送端使用（即使它们不包含在`value`中）。与子进程不同，当前不支持传输句柄（例如网络套接字）。\n\n如果`value`包含`SharedArrayBuffer`实例，则可以从任一线程访问这些实例。它们不能在`transferList`中列出。\n\n`value`可能包含不在`transferList`中的`ArrayBuffer`实例；在这种情况下，底层内存将被复制而不是移动。\n\n```javascript\nconst { MessageChannel } = require('worker_threads');\nconst { port1, port2 } = new MessageChannel();\n\nport1.on('message', (message) => console.log(message));\n\nconst uint8Array = new Uint8Array([ 1, 2, 3, 4 ]);\n// 这发出了`uint8Array`的副本：\nport2.postMessage(uint8Array);\n// 这不会复制数据，但会导致`uint8Array`无法使用：\nport2.postMessage(uint8Array, [ uint8Array.buffer ]);\n\n//从`.on('message')`接收到的原始副本和副本中都可以访问`sharedUint8Array`的内存：\nconst sharedUint8Array = new Uint8Array(new SharedArrayBuffer(4));\nport2.postMessage(sharedUint8Array);\n\n//这会将新创建的消息端口传输到接收器。\n//例如，这可用于在作为同一父线程的子级的多个`Worker`线程之间创建通信通道。\nconst otherChannel = new MessageChannel();\nport2.postMessage({ port: otherChannel.port1 }, [ otherChannel.port1 ]);\n```\n\n由于对象克隆使用结构化克隆算法，因此不会保留不可枚举的属性，属性访问器和对象原型。特别是，在接收方，`Buffer`对象将作为普通的`Uint8Arrays`读取。\n\n消息对象将被立即克隆，并且可以在发出后进行修改而不会产生副作用。\n\n有关此API背后的序列化和反序列化机制的更多信息，请参见v8模块的序列化API。","source":"_posts/2020/04/Node.js多线程.md","raw":"---\ntitle: Node.js多线程\ndate: 2020-04-13 15:17:49\nupdated: 2020-04-17 14:42:23\ntags: Node.js\n---\n\n# 前言\nNode.js 通过提供 cluster、child_process API 创建 **子进程** 的方式来赋予Node.js“多线程”能力。但是这种创建进程的方式会**牺牲共享内存**，并且数据通信必须通过json进行传输。（有一定的局限性和性能问题）\n\n基于此 Node.js V10.5.0 提供了 worker_threads，它比 child_process 或 cluster更轻量级。worker_threads 的出现让 Node.js 拥有**多工作线程**。\n\n与 child_process 或 cluster 不同，worker_threads 可以共享内存，通过传输 ArrayBuffer 实例或共享 SharedArrayBuffer 实例来实现。\n\n<!-- more -->\n\n# 一、child_process（子进程）\nnode的单线程使得在主线程不能进行CPU密集型操作，否则会阻塞主线程。对于CPU密集型操作，在node中通过child_process可以创建独立的子进程，父子进程通过IPC通信，子进程可以是外部应用也可以是node子程序，子进程执行后可以将结果返回给父进程。\n\n## 创建子进程\n\n### 1.spawn ： 子进程中执行的是非node程序，提供一组参数后，执行的结果以流的形式返回。\nspawn同样是用于执行非node应用，且不能直接执行shell，与`execFile`相比，`spawn`执行应用后的结果并不是执行完成后一次性的输出的，而是以流的形式输出。\n\n```javascript\nlet cp = require('child_process');\nlet cat = cp.spawn('cat', ['input.txt']);\nlet sort = cp.spawn('sort');\nlet uniq = cp.spawn('uniq');\n\ncat.stdout.pipe(sort.stdin);\nsort.stdout.pipe(uniq.stdin);\nuniq.stdout.pipe(process.stdout);\nconsole.log(process.stdout);\n```\n\n执行后，最后的结果将输入到process.stdout中。如果input.txt这个文件较大，那么以流的形式输入输出可以明显减小内存的占用，通过设置缓冲区的形式，减小内存占用的同时也可以提高输入输出的效率。\n\n### 2.execFile：子进程中执行的是非node程序，是一个应用，提供一组参数后，执行的结果以回调的形式返回。\n\n````javascript\nchild_process.execFile('echo', ['hello', 'world'], function (err, stdout) {\n    console.log(stdout);// hello world\n});\n````\n\nexecFile类似于执行了名为echo的应用，然后传入参数。execFlie会在process.env.PATH的路径中依次寻找是否有名为'echo'的应用，找到后就会执行。默认的process.env.PATH路径中包含了'usr/local/bin'，而这个'usr/local/bin'目录中就存在了这个名为'echo'的程序，传入hello和world两个参数，执行后返回。\n\n### 3.exec：子进程执行的是非node程序，传入一串shell命令，执行后结果以回调的形式返回。\n\n````javascript\nchild_process.exec('echo hello world', function (err, stdout) {\n    console.log(stdout);// hello world\n});\n````\n\n### 4.fork：子进程执行的是node程序，提供一组参数后，执行的结果以流的形式返回，与`spawn`不同，`fork`生成的子进程只能执行node应用。\n\n在javascript中，在处理大量计算的任务方面，HTML里面通过web work来实现，使得任务脱离了主线程。node中提供了fork方法，通过fork方法在单独的进程中执行node程序，并且通过父子间的IPC通道通信，子进程接受父进程的信息，并将执行后的结果返回给父进程。\n\n在子进程中：\n\n**通过 process.on('message') 和 process.send() 的机制来接收和发送消息。**\n\n在父进程中：\n\n**通过 child.on('message') 和 child.send() 的机制来接收和发送消息。**\n\n具体例子，在child.js中：\n````javascript\nprocess.on('message', function (msg) {\n    process.send(msg)\n})\n````\n在parent.js中：\n````javascript\nlet child_process = require('child_process');\nlet child = child_process.fork('./child');\nchild.on('message', function (msg) {\n    console.log('got a message is', msg);\n});\nchild.send('hello world');\n````\n执行parent.js会在命令行输出：got a message is hello world\n\n### 同步执行的子进程\nexec、execFile、spawn和fork执行的子进程都是默认异步的，子进程的运行不会阻塞主进程。除此之外，child_process模块同样也提供了execFileSync、spawnSync和execSync来实现同步的方式执行子进程。\n\n## 其他方法\n\n### subprocess.disconnect()\n关闭父进程与子进程之间的 IPC 通道，一旦没有其他的连接使其保持活跃，则允许子进程正常退出。\n可以通过在父进程中调用：`child.disconnect()`来实现断开父子间IPC通信。\n当子进程是一个 Node.js 实例时（例如使用 `child_process.fork()` 衍生），也可以在子进程中调用 `process.disconnect()` 方法来关闭 IPC 通道。\n\n### subprocess.kill([signal])\n向子进程发送一个信号。 如果没有给定参数，则进程将会发送 'SIGTERM' 信号。 如果 kill() 成功，则此函数返回 true，否则返回 false。\n\n\n# 二、cluster（集群）\nnode的单线程，以单一进程运行，因此无法利用多核CPU以及其他资源，为了调度多核CPU等资源，node还提供了cluster模块，利用多核CPU的资源，使得可以通过一串node子进程去处理负载任务，同时保证一定的负载均衡性。\n\ncluster 底层就是 child_process，它通过一个**父进程**管理一堆**子进程**的方式来实现集群的功能。master 进程做总控，启动 1 个 agent 和 n 个 worker，agent 来做任务调度，获取任务，并分配给某个空闲的 worker 来做。\n\n官网例子：\n\n```javascript\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n    console.log(`主进程 ${process.pid} 正在运行`);\n\n    // 衍生工作进程。\n    for (let i = 0; i < numCPUs; i++) {\n        cluster.fork();\n    }\n\n    cluster.on('exit', (worker, code, signal) => {\n        console.log(`工作进程 ${worker.process.pid} 已退出，code：${code}，signal：${signal}`);\n    });\n} else {\n    // 工作进程可以共享任何 TCP 连接。\n    // 在本例子中，共享的是 HTTP 服务器。\n    http.createServer((req, res) => {\n        res.writeHead(200);\n        res.end('你好世界\\n');\n    }).listen(8000);\n\n    console.log(`工作进程 ${process.pid} 已启动`);\n}\n```\n\n# 三、worker_threads（工作线程）\n工作线程对于执行 CPU 密集型的 JavaScript 操作非常有用。 它们在 I/O 密集型的工作中用途不大。 Node.js 的内置的异步 I/O 操作比工作线程效率更高。\n\n官方例子：\n\n```javascript\nconst {Worker, isMainThread, parentPort, workerData} = require('worker_threads');\n\nif (isMainThread) {\n    module.exports = function parseJSAsync(script) {\n        return new Promise((resolve, reject) => {\n            const worker = new Worker(__filename, {\n                workerData: script\n            });\n            worker.on('message', resolve);\n            worker.on('error', reject);\n            worker.on('exit', (code) => {\n                if (code !== 0)\n                    reject(new Error(`工作线程使用退出码 ${code} 停止`));\n            });\n        });\n    };\n} else {\n    const {parse} = require('一些 js 解析库');\n    const script = workerData;\n    parentPort.postMessage(parse(script));\n}\n```\n\n## 重要方法\n\n### port.postMessage(value[, transferList])\n - value <any> 传输值（或指针）\n - transferList <Object[]> 传输内存（指针指向的）\n \n将JavaScript值发送到此通道的接收端。值将以与HTML结构化克隆算法兼容的方式进行传输。\n\n特别是，与JSON的显着区别是：\n\n`value`可能包含循环引用。\n`value`可能包含内置JS类型的实例，例如RegExps，BigInts，Maps，Sets等。\n`value`可能包含使用`ArrayBuffers`和`SharedArrayBuffers`的类型化数组。\n`value`可能包含`WebAssembly.Module`实例。\n`value`可能不包含`MessagePort`s以外的本机（C ++支持）对象。\n\n```javascript\nconst { MessageChannel } = require('worker_threads');\nconst { port1, port2 } = new MessageChannel();\n\nport1.on('message', (message) => console.log(message));\n\nconst circularData = {};\ncircularData.foo = circularData;// 循环引用\n// Prints: { foo: [Circular] }\nport2.postMessage(circularData);\n```\n\n`transferList`可能是`ArrayBuffer`和`MessagePort`对象的列表。传输后，它们将不再在通道的发送端使用（即使它们不包含在`value`中）。与子进程不同，当前不支持传输句柄（例如网络套接字）。\n\n如果`value`包含`SharedArrayBuffer`实例，则可以从任一线程访问这些实例。它们不能在`transferList`中列出。\n\n`value`可能包含不在`transferList`中的`ArrayBuffer`实例；在这种情况下，底层内存将被复制而不是移动。\n\n```javascript\nconst { MessageChannel } = require('worker_threads');\nconst { port1, port2 } = new MessageChannel();\n\nport1.on('message', (message) => console.log(message));\n\nconst uint8Array = new Uint8Array([ 1, 2, 3, 4 ]);\n// 这发出了`uint8Array`的副本：\nport2.postMessage(uint8Array);\n// 这不会复制数据，但会导致`uint8Array`无法使用：\nport2.postMessage(uint8Array, [ uint8Array.buffer ]);\n\n//从`.on('message')`接收到的原始副本和副本中都可以访问`sharedUint8Array`的内存：\nconst sharedUint8Array = new Uint8Array(new SharedArrayBuffer(4));\nport2.postMessage(sharedUint8Array);\n\n//这会将新创建的消息端口传输到接收器。\n//例如，这可用于在作为同一父线程的子级的多个`Worker`线程之间创建通信通道。\nconst otherChannel = new MessageChannel();\nport2.postMessage({ port: otherChannel.port1 }, [ otherChannel.port1 ]);\n```\n\n由于对象克隆使用结构化克隆算法，因此不会保留不可枚举的属性，属性访问器和对象原型。特别是，在接收方，`Buffer`对象将作为普通的`Uint8Arrays`读取。\n\n消息对象将被立即克隆，并且可以在发出后进行修改而不会产生副作用。\n\n有关此API背后的序列化和反序列化机制的更多信息，请参见v8模块的序列化API。","slug":"Node.js多线程","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrks00242yku5xr09ivo","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Node.js 通过提供 cluster、child_process API 创建 <strong>子进程</strong> 的方式来赋予Node.js“多线程”能力。但是这种创建进程的方式会<strong>牺牲共享内存</strong>，并且数据通信必须通过json进行传输。（有一定的局限性和性能问题）</p>\n<p>基于此 Node.js V10.5.0 提供了 worker_threads，它比 child_process 或 cluster更轻量级。worker_threads 的出现让 Node.js 拥有<strong>多工作线程</strong>。</p>\n<p>与 child_process 或 cluster 不同，worker_threads 可以共享内存，通过传输 ArrayBuffer 实例或共享 SharedArrayBuffer 实例来实现。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"一、child-process（子进程）\"><a href=\"#一、child-process（子进程）\" class=\"headerlink\" title=\"一、child_process（子进程）\"></a>一、child_process（子进程）</h1><p>node的单线程使得在主线程不能进行CPU密集型操作，否则会阻塞主线程。对于CPU密集型操作，在node中通过child_process可以创建独立的子进程，父子进程通过IPC通信，子进程可以是外部应用也可以是node子程序，子进程执行后可以将结果返回给父进程。</p>\n<h2 id=\"创建子进程\"><a href=\"#创建子进程\" class=\"headerlink\" title=\"创建子进程\"></a>创建子进程</h2><h3 id=\"1-spawn-：-子进程中执行的是非node程序，提供一组参数后，执行的结果以流的形式返回。\"><a href=\"#1-spawn-：-子进程中执行的是非node程序，提供一组参数后，执行的结果以流的形式返回。\" class=\"headerlink\" title=\"1.spawn ： 子进程中执行的是非node程序，提供一组参数后，执行的结果以流的形式返回。\"></a>1.spawn ： 子进程中执行的是非node程序，提供一组参数后，执行的结果以流的形式返回。</h3><p>spawn同样是用于执行非node应用，且不能直接执行shell，与<code>execFile</code>相比，<code>spawn</code>执行应用后的结果并不是执行完成后一次性的输出的，而是以流的形式输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> cp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;child_process&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = cp.spawn(<span class=\"string\">&#x27;cat&#x27;</span>, [<span class=\"string\">&#x27;input.txt&#x27;</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> sort = cp.spawn(<span class=\"string\">&#x27;sort&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> uniq = cp.spawn(<span class=\"string\">&#x27;uniq&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">cat.stdout.pipe(sort.stdin);</span><br><span class=\"line\">sort.stdout.pipe(uniq.stdin);</span><br><span class=\"line\">uniq.stdout.pipe(process.stdout);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(process.stdout);</span><br></pre></td></tr></table></figure>\n\n<p>执行后，最后的结果将输入到process.stdout中。如果input.txt这个文件较大，那么以流的形式输入输出可以明显减小内存的占用，通过设置缓冲区的形式，减小内存占用的同时也可以提高输入输出的效率。</p>\n<h3 id=\"2-execFile：子进程中执行的是非node程序，是一个应用，提供一组参数后，执行的结果以回调的形式返回。\"><a href=\"#2-execFile：子进程中执行的是非node程序，是一个应用，提供一组参数后，执行的结果以回调的形式返回。\" class=\"headerlink\" title=\"2.execFile：子进程中执行的是非node程序，是一个应用，提供一组参数后，执行的结果以回调的形式返回。\"></a>2.execFile：子进程中执行的是非node程序，是一个应用，提供一组参数后，执行的结果以回调的形式返回。</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child_process.execFile(<span class=\"string\">&#x27;echo&#x27;</span>, [<span class=\"string\">&#x27;hello&#x27;</span>, <span class=\"string\">&#x27;world&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, stdout</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(stdout);<span class=\"comment\">// hello world</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>execFile类似于执行了名为echo的应用，然后传入参数。execFlie会在process.env.PATH的路径中依次寻找是否有名为’echo’的应用，找到后就会执行。默认的process.env.PATH路径中包含了’usr/local/bin’，而这个’usr/local/bin’目录中就存在了这个名为’echo’的程序，传入hello和world两个参数，执行后返回。</p>\n<h3 id=\"3-exec：子进程执行的是非node程序，传入一串shell命令，执行后结果以回调的形式返回。\"><a href=\"#3-exec：子进程执行的是非node程序，传入一串shell命令，执行后结果以回调的形式返回。\" class=\"headerlink\" title=\"3.exec：子进程执行的是非node程序，传入一串shell命令，执行后结果以回调的形式返回。\"></a>3.exec：子进程执行的是非node程序，传入一串shell命令，执行后结果以回调的形式返回。</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child_process.exec(<span class=\"string\">&#x27;echo hello world&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, stdout</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(stdout);<span class=\"comment\">// hello world</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-fork：子进程执行的是node程序，提供一组参数后，执行的结果以流的形式返回，与spawn不同，fork生成的子进程只能执行node应用。\"><a href=\"#4-fork：子进程执行的是node程序，提供一组参数后，执行的结果以流的形式返回，与spawn不同，fork生成的子进程只能执行node应用。\" class=\"headerlink\" title=\"4.fork：子进程执行的是node程序，提供一组参数后，执行的结果以流的形式返回，与spawn不同，fork生成的子进程只能执行node应用。\"></a>4.fork：子进程执行的是node程序，提供一组参数后，执行的结果以流的形式返回，与<code>spawn</code>不同，<code>fork</code>生成的子进程只能执行node应用。</h3><p>在javascript中，在处理大量计算的任务方面，HTML里面通过web work来实现，使得任务脱离了主线程。node中提供了fork方法，通过fork方法在单独的进程中执行node程序，并且通过父子间的IPC通道通信，子进程接受父进程的信息，并将执行后的结果返回给父进程。</p>\n<p>在子进程中：</p>\n<p><strong>通过 process.on(‘message’) 和 process.send() 的机制来接收和发送消息。</strong></p>\n<p>在父进程中：</p>\n<p><strong>通过 child.on(‘message’) 和 child.send() 的机制来接收和发送消息。</strong></p>\n<p>具体例子，在child.js中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.on(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">    process.send(msg)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在parent.js中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> child_process = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;child_process&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> child = child_process.fork(<span class=\"string\">&#x27;./child&#x27;</span>);</span><br><span class=\"line\">child.on(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;got a message is&#x27;</span>, msg);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">child.send(<span class=\"string\">&#x27;hello world&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>执行parent.js会在命令行输出：got a message is hello world</p>\n<h3 id=\"同步执行的子进程\"><a href=\"#同步执行的子进程\" class=\"headerlink\" title=\"同步执行的子进程\"></a>同步执行的子进程</h3><p>exec、execFile、spawn和fork执行的子进程都是默认异步的，子进程的运行不会阻塞主进程。除此之外，child_process模块同样也提供了execFileSync、spawnSync和execSync来实现同步的方式执行子进程。</p>\n<h2 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h2><h3 id=\"subprocess-disconnect\"><a href=\"#subprocess-disconnect\" class=\"headerlink\" title=\"subprocess.disconnect()\"></a>subprocess.disconnect()</h3><p>关闭父进程与子进程之间的 IPC 通道，一旦没有其他的连接使其保持活跃，则允许子进程正常退出。<br>可以通过在父进程中调用：<code>child.disconnect()</code>来实现断开父子间IPC通信。<br>当子进程是一个 Node.js 实例时（例如使用 <code>child_process.fork()</code> 衍生），也可以在子进程中调用 <code>process.disconnect()</code> 方法来关闭 IPC 通道。</p>\n<h3 id=\"subprocess-kill-signal\"><a href=\"#subprocess-kill-signal\" class=\"headerlink\" title=\"subprocess.kill([signal])\"></a>subprocess.kill([signal])</h3><p>向子进程发送一个信号。 如果没有给定参数，则进程将会发送 ‘SIGTERM’ 信号。 如果 kill() 成功，则此函数返回 true，否则返回 false。</p>\n<h1 id=\"二、cluster（集群）\"><a href=\"#二、cluster（集群）\" class=\"headerlink\" title=\"二、cluster（集群）\"></a>二、cluster（集群）</h1><p>node的单线程，以单一进程运行，因此无法利用多核CPU以及其他资源，为了调度多核CPU等资源，node还提供了cluster模块，利用多核CPU的资源，使得可以通过一串node子进程去处理负载任务，同时保证一定的负载均衡性。</p>\n<p>cluster 底层就是 child_process，它通过一个<strong>父进程</strong>管理一堆<strong>子进程</strong>的方式来实现集群的功能。master 进程做总控，启动 1 个 agent 和 n 个 worker，agent 来做任务调度，获取任务，并分配给某个空闲的 worker 来做。</p>\n<p>官网例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cluster = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cluster&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> numCPUs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;os&#x27;</span>).cpus().length;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (cluster.isMaster) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`主进程 <span class=\"subst\">$&#123;process.pid&#125;</span> 正在运行`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 衍生工作进程。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class=\"line\">        cluster.fork();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cluster.on(<span class=\"string\">&#x27;exit&#x27;</span>, <span class=\"function\">(<span class=\"params\">worker, code, signal</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`工作进程 <span class=\"subst\">$&#123;worker.process.pid&#125;</span> 已退出，code：<span class=\"subst\">$&#123;code&#125;</span>，signal：<span class=\"subst\">$&#123;signal&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 工作进程可以共享任何 TCP 连接。</span></span><br><span class=\"line\">    <span class=\"comment\">// 在本例子中，共享的是 HTTP 服务器。</span></span><br><span class=\"line\">    http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        res.writeHead(<span class=\"number\">200</span>);</span><br><span class=\"line\">        res.end(<span class=\"string\">&#x27;你好世界\\n&#x27;</span>);</span><br><span class=\"line\">    &#125;).listen(<span class=\"number\">8000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`工作进程 <span class=\"subst\">$&#123;process.pid&#125;</span> 已启动`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、worker-threads（工作线程）\"><a href=\"#三、worker-threads（工作线程）\" class=\"headerlink\" title=\"三、worker_threads（工作线程）\"></a>三、worker_threads（工作线程）</h1><p>工作线程对于执行 CPU 密集型的 JavaScript 操作非常有用。 它们在 I/O 密集型的工作中用途不大。 Node.js 的内置的异步 I/O 操作比工作线程效率更高。</p>\n<p>官方例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;Worker, isMainThread, parentPort, workerData&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;worker_threads&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (isMainThread) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseJSAsync</span>(<span class=\"params\">script</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> worker = <span class=\"keyword\">new</span> Worker(__filename, &#123;</span><br><span class=\"line\">                workerData: script</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            worker.on(<span class=\"string\">&#x27;message&#x27;</span>, resolve);</span><br><span class=\"line\">            worker.on(<span class=\"string\">&#x27;error&#x27;</span>, reject);</span><br><span class=\"line\">            worker.on(<span class=\"string\">&#x27;exit&#x27;</span>, <span class=\"function\">(<span class=\"params\">code</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (code !== <span class=\"number\">0</span>)</span><br><span class=\"line\">                    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`工作线程使用退出码 <span class=\"subst\">$&#123;code&#125;</span> 停止`</span>));</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;parse&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;一些 js 解析库&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> script = workerData;</span><br><span class=\"line\">    parentPort.postMessage(parse(script));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重要方法\"><a href=\"#重要方法\" class=\"headerlink\" title=\"重要方法\"></a>重要方法</h2><h3 id=\"port-postMessage-value-transferList\"><a href=\"#port-postMessage-value-transferList\" class=\"headerlink\" title=\"port.postMessage(value[, transferList])\"></a>port.postMessage(value[, transferList])</h3><ul>\n<li>value <any> 传输值（或指针）</li>\n<li>transferList &lt;Object[]&gt; 传输内存（指针指向的）</li>\n</ul>\n<p>将JavaScript值发送到此通道的接收端。值将以与HTML结构化克隆算法兼容的方式进行传输。</p>\n<p>特别是，与JSON的显着区别是：</p>\n<p><code>value</code>可能包含循环引用。<br><code>value</code>可能包含内置JS类型的实例，例如RegExps，BigInts，Maps，Sets等。<br><code>value</code>可能包含使用<code>ArrayBuffers</code>和<code>SharedArrayBuffers</code>的类型化数组。<br><code>value</code>可能包含<code>WebAssembly.Module</code>实例。<br><code>value</code>可能不包含<code>MessagePort</code>s以外的本机（C ++支持）对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; MessageChannel &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;worker_threads&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; port1, port2 &#125; = <span class=\"keyword\">new</span> MessageChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">port1.on(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\">(<span class=\"params\">message</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(message));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> circularData = &#123;&#125;;</span><br><span class=\"line\">circularData.foo = circularData;<span class=\"comment\">// 循环引用</span></span><br><span class=\"line\"><span class=\"comment\">// Prints: &#123; foo: [Circular] &#125;</span></span><br><span class=\"line\">port2.postMessage(circularData);</span><br></pre></td></tr></table></figure>\n\n<p><code>transferList</code>可能是<code>ArrayBuffer</code>和<code>MessagePort</code>对象的列表。传输后，它们将不再在通道的发送端使用（即使它们不包含在<code>value</code>中）。与子进程不同，当前不支持传输句柄（例如网络套接字）。</p>\n<p>如果<code>value</code>包含<code>SharedArrayBuffer</code>实例，则可以从任一线程访问这些实例。它们不能在<code>transferList</code>中列出。</p>\n<p><code>value</code>可能包含不在<code>transferList</code>中的<code>ArrayBuffer</code>实例；在这种情况下，底层内存将被复制而不是移动。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; MessageChannel &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;worker_threads&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; port1, port2 &#125; = <span class=\"keyword\">new</span> MessageChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">port1.on(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\">(<span class=\"params\">message</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(message));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> uint8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span> ]);</span><br><span class=\"line\"><span class=\"comment\">// 这发出了`uint8Array`的副本：</span></span><br><span class=\"line\">port2.postMessage(uint8Array);</span><br><span class=\"line\"><span class=\"comment\">// 这不会复制数据，但会导致`uint8Array`无法使用：</span></span><br><span class=\"line\">port2.postMessage(uint8Array, [ uint8Array.buffer ]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从`.on(&#x27;message&#x27;)`接收到的原始副本和副本中都可以访问`sharedUint8Array`的内存：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sharedUint8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(<span class=\"keyword\">new</span> SharedArrayBuffer(<span class=\"number\">4</span>));</span><br><span class=\"line\">port2.postMessage(sharedUint8Array);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这会将新创建的消息端口传输到接收器。</span></span><br><span class=\"line\"><span class=\"comment\">//例如，这可用于在作为同一父线程的子级的多个`Worker`线程之间创建通信通道。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> otherChannel = <span class=\"keyword\">new</span> MessageChannel();</span><br><span class=\"line\">port2.postMessage(&#123; <span class=\"attr\">port</span>: otherChannel.port1 &#125;, [ otherChannel.port1 ]);</span><br></pre></td></tr></table></figure>\n\n<p>由于对象克隆使用结构化克隆算法，因此不会保留不可枚举的属性，属性访问器和对象原型。特别是，在接收方，<code>Buffer</code>对象将作为普通的<code>Uint8Arrays</code>读取。</p>\n<p>消息对象将被立即克隆，并且可以在发出后进行修改而不会产生副作用。</p>\n<p>有关此API背后的序列化和反序列化机制的更多信息，请参见v8模块的序列化API。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Node.js 通过提供 cluster、child_process API 创建 <strong>子进程</strong> 的方式来赋予Node.js“多线程”能力。但是这种创建进程的方式会<strong>牺牲共享内存</strong>，并且数据通信必须通过json进行传输。（有一定的局限性和性能问题）</p>\n<p>基于此 Node.js V10.5.0 提供了 worker_threads，它比 child_process 或 cluster更轻量级。worker_threads 的出现让 Node.js 拥有<strong>多工作线程</strong>。</p>\n<p>与 child_process 或 cluster 不同，worker_threads 可以共享内存，通过传输 ArrayBuffer 实例或共享 SharedArrayBuffer 实例来实现。</p>","more":"<h1 id=\"一、child-process（子进程）\"><a href=\"#一、child-process（子进程）\" class=\"headerlink\" title=\"一、child_process（子进程）\"></a>一、child_process（子进程）</h1><p>node的单线程使得在主线程不能进行CPU密集型操作，否则会阻塞主线程。对于CPU密集型操作，在node中通过child_process可以创建独立的子进程，父子进程通过IPC通信，子进程可以是外部应用也可以是node子程序，子进程执行后可以将结果返回给父进程。</p>\n<h2 id=\"创建子进程\"><a href=\"#创建子进程\" class=\"headerlink\" title=\"创建子进程\"></a>创建子进程</h2><h3 id=\"1-spawn-：-子进程中执行的是非node程序，提供一组参数后，执行的结果以流的形式返回。\"><a href=\"#1-spawn-：-子进程中执行的是非node程序，提供一组参数后，执行的结果以流的形式返回。\" class=\"headerlink\" title=\"1.spawn ： 子进程中执行的是非node程序，提供一组参数后，执行的结果以流的形式返回。\"></a>1.spawn ： 子进程中执行的是非node程序，提供一组参数后，执行的结果以流的形式返回。</h3><p>spawn同样是用于执行非node应用，且不能直接执行shell，与<code>execFile</code>相比，<code>spawn</code>执行应用后的结果并不是执行完成后一次性的输出的，而是以流的形式输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> cp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;child_process&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = cp.spawn(<span class=\"string\">&#x27;cat&#x27;</span>, [<span class=\"string\">&#x27;input.txt&#x27;</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> sort = cp.spawn(<span class=\"string\">&#x27;sort&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> uniq = cp.spawn(<span class=\"string\">&#x27;uniq&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">cat.stdout.pipe(sort.stdin);</span><br><span class=\"line\">sort.stdout.pipe(uniq.stdin);</span><br><span class=\"line\">uniq.stdout.pipe(process.stdout);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(process.stdout);</span><br></pre></td></tr></table></figure>\n\n<p>执行后，最后的结果将输入到process.stdout中。如果input.txt这个文件较大，那么以流的形式输入输出可以明显减小内存的占用，通过设置缓冲区的形式，减小内存占用的同时也可以提高输入输出的效率。</p>\n<h3 id=\"2-execFile：子进程中执行的是非node程序，是一个应用，提供一组参数后，执行的结果以回调的形式返回。\"><a href=\"#2-execFile：子进程中执行的是非node程序，是一个应用，提供一组参数后，执行的结果以回调的形式返回。\" class=\"headerlink\" title=\"2.execFile：子进程中执行的是非node程序，是一个应用，提供一组参数后，执行的结果以回调的形式返回。\"></a>2.execFile：子进程中执行的是非node程序，是一个应用，提供一组参数后，执行的结果以回调的形式返回。</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child_process.execFile(<span class=\"string\">&#x27;echo&#x27;</span>, [<span class=\"string\">&#x27;hello&#x27;</span>, <span class=\"string\">&#x27;world&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, stdout</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(stdout);<span class=\"comment\">// hello world</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>execFile类似于执行了名为echo的应用，然后传入参数。execFlie会在process.env.PATH的路径中依次寻找是否有名为’echo’的应用，找到后就会执行。默认的process.env.PATH路径中包含了’usr/local/bin’，而这个’usr/local/bin’目录中就存在了这个名为’echo’的程序，传入hello和world两个参数，执行后返回。</p>\n<h3 id=\"3-exec：子进程执行的是非node程序，传入一串shell命令，执行后结果以回调的形式返回。\"><a href=\"#3-exec：子进程执行的是非node程序，传入一串shell命令，执行后结果以回调的形式返回。\" class=\"headerlink\" title=\"3.exec：子进程执行的是非node程序，传入一串shell命令，执行后结果以回调的形式返回。\"></a>3.exec：子进程执行的是非node程序，传入一串shell命令，执行后结果以回调的形式返回。</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child_process.exec(<span class=\"string\">&#x27;echo hello world&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, stdout</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(stdout);<span class=\"comment\">// hello world</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-fork：子进程执行的是node程序，提供一组参数后，执行的结果以流的形式返回，与spawn不同，fork生成的子进程只能执行node应用。\"><a href=\"#4-fork：子进程执行的是node程序，提供一组参数后，执行的结果以流的形式返回，与spawn不同，fork生成的子进程只能执行node应用。\" class=\"headerlink\" title=\"4.fork：子进程执行的是node程序，提供一组参数后，执行的结果以流的形式返回，与spawn不同，fork生成的子进程只能执行node应用。\"></a>4.fork：子进程执行的是node程序，提供一组参数后，执行的结果以流的形式返回，与<code>spawn</code>不同，<code>fork</code>生成的子进程只能执行node应用。</h3><p>在javascript中，在处理大量计算的任务方面，HTML里面通过web work来实现，使得任务脱离了主线程。node中提供了fork方法，通过fork方法在单独的进程中执行node程序，并且通过父子间的IPC通道通信，子进程接受父进程的信息，并将执行后的结果返回给父进程。</p>\n<p>在子进程中：</p>\n<p><strong>通过 process.on(‘message’) 和 process.send() 的机制来接收和发送消息。</strong></p>\n<p>在父进程中：</p>\n<p><strong>通过 child.on(‘message’) 和 child.send() 的机制来接收和发送消息。</strong></p>\n<p>具体例子，在child.js中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.on(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">    process.send(msg)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在parent.js中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> child_process = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;child_process&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> child = child_process.fork(<span class=\"string\">&#x27;./child&#x27;</span>);</span><br><span class=\"line\">child.on(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;got a message is&#x27;</span>, msg);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">child.send(<span class=\"string\">&#x27;hello world&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>执行parent.js会在命令行输出：got a message is hello world</p>\n<h3 id=\"同步执行的子进程\"><a href=\"#同步执行的子进程\" class=\"headerlink\" title=\"同步执行的子进程\"></a>同步执行的子进程</h3><p>exec、execFile、spawn和fork执行的子进程都是默认异步的，子进程的运行不会阻塞主进程。除此之外，child_process模块同样也提供了execFileSync、spawnSync和execSync来实现同步的方式执行子进程。</p>\n<h2 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h2><h3 id=\"subprocess-disconnect\"><a href=\"#subprocess-disconnect\" class=\"headerlink\" title=\"subprocess.disconnect()\"></a>subprocess.disconnect()</h3><p>关闭父进程与子进程之间的 IPC 通道，一旦没有其他的连接使其保持活跃，则允许子进程正常退出。<br>可以通过在父进程中调用：<code>child.disconnect()</code>来实现断开父子间IPC通信。<br>当子进程是一个 Node.js 实例时（例如使用 <code>child_process.fork()</code> 衍生），也可以在子进程中调用 <code>process.disconnect()</code> 方法来关闭 IPC 通道。</p>\n<h3 id=\"subprocess-kill-signal\"><a href=\"#subprocess-kill-signal\" class=\"headerlink\" title=\"subprocess.kill([signal])\"></a>subprocess.kill([signal])</h3><p>向子进程发送一个信号。 如果没有给定参数，则进程将会发送 ‘SIGTERM’ 信号。 如果 kill() 成功，则此函数返回 true，否则返回 false。</p>\n<h1 id=\"二、cluster（集群）\"><a href=\"#二、cluster（集群）\" class=\"headerlink\" title=\"二、cluster（集群）\"></a>二、cluster（集群）</h1><p>node的单线程，以单一进程运行，因此无法利用多核CPU以及其他资源，为了调度多核CPU等资源，node还提供了cluster模块，利用多核CPU的资源，使得可以通过一串node子进程去处理负载任务，同时保证一定的负载均衡性。</p>\n<p>cluster 底层就是 child_process，它通过一个<strong>父进程</strong>管理一堆<strong>子进程</strong>的方式来实现集群的功能。master 进程做总控，启动 1 个 agent 和 n 个 worker，agent 来做任务调度，获取任务，并分配给某个空闲的 worker 来做。</p>\n<p>官网例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cluster = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cluster&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> numCPUs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;os&#x27;</span>).cpus().length;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (cluster.isMaster) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`主进程 <span class=\"subst\">$&#123;process.pid&#125;</span> 正在运行`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 衍生工作进程。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class=\"line\">        cluster.fork();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cluster.on(<span class=\"string\">&#x27;exit&#x27;</span>, <span class=\"function\">(<span class=\"params\">worker, code, signal</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`工作进程 <span class=\"subst\">$&#123;worker.process.pid&#125;</span> 已退出，code：<span class=\"subst\">$&#123;code&#125;</span>，signal：<span class=\"subst\">$&#123;signal&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 工作进程可以共享任何 TCP 连接。</span></span><br><span class=\"line\">    <span class=\"comment\">// 在本例子中，共享的是 HTTP 服务器。</span></span><br><span class=\"line\">    http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        res.writeHead(<span class=\"number\">200</span>);</span><br><span class=\"line\">        res.end(<span class=\"string\">&#x27;你好世界\\n&#x27;</span>);</span><br><span class=\"line\">    &#125;).listen(<span class=\"number\">8000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`工作进程 <span class=\"subst\">$&#123;process.pid&#125;</span> 已启动`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、worker-threads（工作线程）\"><a href=\"#三、worker-threads（工作线程）\" class=\"headerlink\" title=\"三、worker_threads（工作线程）\"></a>三、worker_threads（工作线程）</h1><p>工作线程对于执行 CPU 密集型的 JavaScript 操作非常有用。 它们在 I/O 密集型的工作中用途不大。 Node.js 的内置的异步 I/O 操作比工作线程效率更高。</p>\n<p>官方例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;Worker, isMainThread, parentPort, workerData&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;worker_threads&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (isMainThread) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseJSAsync</span>(<span class=\"params\">script</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> worker = <span class=\"keyword\">new</span> Worker(__filename, &#123;</span><br><span class=\"line\">                workerData: script</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            worker.on(<span class=\"string\">&#x27;message&#x27;</span>, resolve);</span><br><span class=\"line\">            worker.on(<span class=\"string\">&#x27;error&#x27;</span>, reject);</span><br><span class=\"line\">            worker.on(<span class=\"string\">&#x27;exit&#x27;</span>, <span class=\"function\">(<span class=\"params\">code</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (code !== <span class=\"number\">0</span>)</span><br><span class=\"line\">                    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`工作线程使用退出码 <span class=\"subst\">$&#123;code&#125;</span> 停止`</span>));</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;parse&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;一些 js 解析库&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> script = workerData;</span><br><span class=\"line\">    parentPort.postMessage(parse(script));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重要方法\"><a href=\"#重要方法\" class=\"headerlink\" title=\"重要方法\"></a>重要方法</h2><h3 id=\"port-postMessage-value-transferList\"><a href=\"#port-postMessage-value-transferList\" class=\"headerlink\" title=\"port.postMessage(value[, transferList])\"></a>port.postMessage(value[, transferList])</h3><ul>\n<li>value <any> 传输值（或指针）</li>\n<li>transferList &lt;Object[]&gt; 传输内存（指针指向的）</li>\n</ul>\n<p>将JavaScript值发送到此通道的接收端。值将以与HTML结构化克隆算法兼容的方式进行传输。</p>\n<p>特别是，与JSON的显着区别是：</p>\n<p><code>value</code>可能包含循环引用。<br><code>value</code>可能包含内置JS类型的实例，例如RegExps，BigInts，Maps，Sets等。<br><code>value</code>可能包含使用<code>ArrayBuffers</code>和<code>SharedArrayBuffers</code>的类型化数组。<br><code>value</code>可能包含<code>WebAssembly.Module</code>实例。<br><code>value</code>可能不包含<code>MessagePort</code>s以外的本机（C ++支持）对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; MessageChannel &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;worker_threads&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; port1, port2 &#125; = <span class=\"keyword\">new</span> MessageChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">port1.on(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\">(<span class=\"params\">message</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(message));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> circularData = &#123;&#125;;</span><br><span class=\"line\">circularData.foo = circularData;<span class=\"comment\">// 循环引用</span></span><br><span class=\"line\"><span class=\"comment\">// Prints: &#123; foo: [Circular] &#125;</span></span><br><span class=\"line\">port2.postMessage(circularData);</span><br></pre></td></tr></table></figure>\n\n<p><code>transferList</code>可能是<code>ArrayBuffer</code>和<code>MessagePort</code>对象的列表。传输后，它们将不再在通道的发送端使用（即使它们不包含在<code>value</code>中）。与子进程不同，当前不支持传输句柄（例如网络套接字）。</p>\n<p>如果<code>value</code>包含<code>SharedArrayBuffer</code>实例，则可以从任一线程访问这些实例。它们不能在<code>transferList</code>中列出。</p>\n<p><code>value</code>可能包含不在<code>transferList</code>中的<code>ArrayBuffer</code>实例；在这种情况下，底层内存将被复制而不是移动。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; MessageChannel &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;worker_threads&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; port1, port2 &#125; = <span class=\"keyword\">new</span> MessageChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">port1.on(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\">(<span class=\"params\">message</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(message));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> uint8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span> ]);</span><br><span class=\"line\"><span class=\"comment\">// 这发出了`uint8Array`的副本：</span></span><br><span class=\"line\">port2.postMessage(uint8Array);</span><br><span class=\"line\"><span class=\"comment\">// 这不会复制数据，但会导致`uint8Array`无法使用：</span></span><br><span class=\"line\">port2.postMessage(uint8Array, [ uint8Array.buffer ]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从`.on(&#x27;message&#x27;)`接收到的原始副本和副本中都可以访问`sharedUint8Array`的内存：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sharedUint8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(<span class=\"keyword\">new</span> SharedArrayBuffer(<span class=\"number\">4</span>));</span><br><span class=\"line\">port2.postMessage(sharedUint8Array);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这会将新创建的消息端口传输到接收器。</span></span><br><span class=\"line\"><span class=\"comment\">//例如，这可用于在作为同一父线程的子级的多个`Worker`线程之间创建通信通道。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> otherChannel = <span class=\"keyword\">new</span> MessageChannel();</span><br><span class=\"line\">port2.postMessage(&#123; <span class=\"attr\">port</span>: otherChannel.port1 &#125;, [ otherChannel.port1 ]);</span><br></pre></td></tr></table></figure>\n\n<p>由于对象克隆使用结构化克隆算法，因此不会保留不可枚举的属性，属性访问器和对象原型。特别是，在接收方，<code>Buffer</code>对象将作为普通的<code>Uint8Arrays</code>读取。</p>\n<p>消息对象将被立即克隆，并且可以在发出后进行修改而不会产生副作用。</p>\n<p>有关此API背后的序列化和反序列化机制的更多信息，请参见v8模块的序列化API。</p>"},{"title":"insert语句添加条件","date":"2020-04-07T18:03:58.000Z","updated":"2020-04-07T18:03:58.000Z","_content":"\ninsert 语句添加 where\n用对虚拟表的查询来添加条件，如果不存在，则插入值(1,'haha',3)\n\n```\ninsert into table_name(id,name,value) \nselect 1,'haha',3 from DUAL\nwhere not EXISTS (select * from table_name where id = 1)\n```\n","source":"_posts/2020/04/insert语句添加条件.md","raw":"---\ntitle: insert语句添加条件\ndate: 2020-04-08 02:03:58\nupdated: 2020-04-08 02:03:58\ntags: 数据库\n---\n\ninsert 语句添加 where\n用对虚拟表的查询来添加条件，如果不存在，则插入值(1,'haha',3)\n\n```\ninsert into table_name(id,name,value) \nselect 1,'haha',3 from DUAL\nwhere not EXISTS (select * from table_name where id = 1)\n```\n","slug":"insert语句添加条件","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkt00272yku4um2ek5z","content":"<p>insert 语句添加 where<br>用对虚拟表的查询来添加条件，如果不存在，则插入值(1,’haha’,3)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into table_name(id,name,value) </span><br><span class=\"line\">select 1,&#39;haha&#39;,3 from DUAL</span><br><span class=\"line\">where not EXISTS (select * from table_name where id &#x3D; 1)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>insert 语句添加 where<br>用对虚拟表的查询来添加条件，如果不存在，则插入值(1,’haha’,3)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into table_name(id,name,value) </span><br><span class=\"line\">select 1,&#39;haha&#39;,3 from DUAL</span><br><span class=\"line\">where not EXISTS (select * from table_name where id &#x3D; 1)</span><br></pre></td></tr></table></figure>\n"},{"title":"阿里Serverless面试记录","date":"2020-04-21T12:01:41.000Z","updated":"2020-04-21T12:01:41.000Z","_content":"\n> 阿里的技术专家认为我的工作经历和岗位比较相符，遂进入内推。虽然我和P7还有亿点差距，但这次面试为我提供了前进的方向，受益匪浅。感谢热忱的前辈们！\n\n<!-- more -->\n\n# 一、技术栈\n### 关键词：\n技术栈、选择原因\n    \n### 答：\n面向aws编程： \nrouter53：域名管理\nAPI Gateway：创建基于 HTTP 的 RESTful API\nLambda：代码运行环境\nS3：提供文件存储\nDynamoDB：非关系型数据库\nCDN加速： Amazon CloudFront \nIAM：身份权限管理\nX-Ray：查看请求和响应的详细信息，并提供用于查看、筛选和获取数据洞察力的工具，以确定问题和发现优化的机会。\nAppSync：构建 GraphQL API。.yml定义数据源、映射模板(关联架构和解析程序)，.graphql构建架构，txt编写解析程序。\nCloudWatch：日志收集，以及基于日志的错误抓取、警报。\n\n### 小结：\n说清楚技术构成，通过说明选择原因来体现技术积累。这些技术不是我拍板的，但其实也有东西可以讲，比如用过dashbird来做服务监控，但是由于和CloudWatch的功能重复以及设计缺陷（不能屏蔽未授权错误）而被放弃。\n\n# 二、JMeter\n### 关键词：\n选择原因、如何使用、扩容问题\n\n### 答：\n因为自己简单写的node工具没有人家成熟的软件好用。讲了一下使用流程、测试目的以及结果，以及对未来数据量的计划，比如使用EC2搭建分布式测试环境。\n\n### 小结：\n表现不错，对技术有深入理解，能体现能力。\n\n# 三、GraphQL\n### 关键词：\n踩过的坑、优缺点\n\n### 答：\n只讲了怎么使用，对N+1问题不了解，回忆不起踩过的坑，讲不出对比RESTful的优缺点。\n\n### 小结：\n对简历上的技能可能遇到的常见问题应该有所准备。\n\n# 四、Serverless原理\n### 关键词：\ndocker、k8s、动态扩容\n\n### 答：\n只知道是基于容器实现的弹性计算集群，但是对上述关键词的具体知识完全不了解。\n\n### 小结：\n虽然Lambda不是开源的东西，但是它的底层原理属于比较常见的技术手段。可以说是这个岗位的核心要求，死的明明白白。\n\n# 五、CLI工具\n### 关键词：\n为什么用bash不用node、做了什么\n\n### 答：\n大部分命令都是shell下运行的，比如sls，用Node也是要写对应的shell命令，画蛇添足了。\n版本号迭代、git tag管理、依赖安装、并行发布、错误中止、拉起警报\n\n### 小结：\n还行。\n\n# 六、开源项目\n因为不了解如何参与开源项目，面试官为我做了讲解。\n\n### 关键词：\n提issue、看issue、提pr\n\n以Koa举例，将你在使用过程中踩过的坑（可以是bug，也可以是难点）在issue中提出。同时可以看看其他人提出的issue，想想为什么别人碰得到你却碰不到，以及这个问题要怎么解决。你可以在本地复现这个问题，如果得以解决，可以把自己的代码提交pull request（注意单元测试）。\n","source":"_posts/2020/04/阿里Serverless面试记录.md","raw":"---\ntitle: 阿里Serverless面试记录\ndate: 2020-04-21 20:01:41\nupdated: 2020-04-21 20:01:41\ntags: 面经\n---\n\n> 阿里的技术专家认为我的工作经历和岗位比较相符，遂进入内推。虽然我和P7还有亿点差距，但这次面试为我提供了前进的方向，受益匪浅。感谢热忱的前辈们！\n\n<!-- more -->\n\n# 一、技术栈\n### 关键词：\n技术栈、选择原因\n    \n### 答：\n面向aws编程： \nrouter53：域名管理\nAPI Gateway：创建基于 HTTP 的 RESTful API\nLambda：代码运行环境\nS3：提供文件存储\nDynamoDB：非关系型数据库\nCDN加速： Amazon CloudFront \nIAM：身份权限管理\nX-Ray：查看请求和响应的详细信息，并提供用于查看、筛选和获取数据洞察力的工具，以确定问题和发现优化的机会。\nAppSync：构建 GraphQL API。.yml定义数据源、映射模板(关联架构和解析程序)，.graphql构建架构，txt编写解析程序。\nCloudWatch：日志收集，以及基于日志的错误抓取、警报。\n\n### 小结：\n说清楚技术构成，通过说明选择原因来体现技术积累。这些技术不是我拍板的，但其实也有东西可以讲，比如用过dashbird来做服务监控，但是由于和CloudWatch的功能重复以及设计缺陷（不能屏蔽未授权错误）而被放弃。\n\n# 二、JMeter\n### 关键词：\n选择原因、如何使用、扩容问题\n\n### 答：\n因为自己简单写的node工具没有人家成熟的软件好用。讲了一下使用流程、测试目的以及结果，以及对未来数据量的计划，比如使用EC2搭建分布式测试环境。\n\n### 小结：\n表现不错，对技术有深入理解，能体现能力。\n\n# 三、GraphQL\n### 关键词：\n踩过的坑、优缺点\n\n### 答：\n只讲了怎么使用，对N+1问题不了解，回忆不起踩过的坑，讲不出对比RESTful的优缺点。\n\n### 小结：\n对简历上的技能可能遇到的常见问题应该有所准备。\n\n# 四、Serverless原理\n### 关键词：\ndocker、k8s、动态扩容\n\n### 答：\n只知道是基于容器实现的弹性计算集群，但是对上述关键词的具体知识完全不了解。\n\n### 小结：\n虽然Lambda不是开源的东西，但是它的底层原理属于比较常见的技术手段。可以说是这个岗位的核心要求，死的明明白白。\n\n# 五、CLI工具\n### 关键词：\n为什么用bash不用node、做了什么\n\n### 答：\n大部分命令都是shell下运行的，比如sls，用Node也是要写对应的shell命令，画蛇添足了。\n版本号迭代、git tag管理、依赖安装、并行发布、错误中止、拉起警报\n\n### 小结：\n还行。\n\n# 六、开源项目\n因为不了解如何参与开源项目，面试官为我做了讲解。\n\n### 关键词：\n提issue、看issue、提pr\n\n以Koa举例，将你在使用过程中踩过的坑（可以是bug，也可以是难点）在issue中提出。同时可以看看其他人提出的issue，想想为什么别人碰得到你却碰不到，以及这个问题要怎么解决。你可以在本地复现这个问题，如果得以解决，可以把自己的代码提交pull request（注意单元测试）。\n","slug":"阿里Serverless面试记录","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkt00292yku4ohcaglo","content":"<blockquote>\n<p>阿里的技术专家认为我的工作经历和岗位比较相符，遂进入内推。虽然我和P7还有亿点差距，但这次面试为我提供了前进的方向，受益匪浅。感谢热忱的前辈们！</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h1 id=\"一、技术栈\"><a href=\"#一、技术栈\" class=\"headerlink\" title=\"一、技术栈\"></a>一、技术栈</h1><h3 id=\"关键词：\"><a href=\"#关键词：\" class=\"headerlink\" title=\"关键词：\"></a>关键词：</h3><p>技术栈、选择原因</p>\n<h3 id=\"答：\"><a href=\"#答：\" class=\"headerlink\" title=\"答：\"></a>答：</h3><p>面向aws编程：<br>router53：域名管理<br>API Gateway：创建基于 HTTP 的 RESTful API<br>Lambda：代码运行环境<br>S3：提供文件存储<br>DynamoDB：非关系型数据库<br>CDN加速： Amazon CloudFront<br>IAM：身份权限管理<br>X-Ray：查看请求和响应的详细信息，并提供用于查看、筛选和获取数据洞察力的工具，以确定问题和发现优化的机会。<br>AppSync：构建 GraphQL API。.yml定义数据源、映射模板(关联架构和解析程序)，.graphql构建架构，txt编写解析程序。<br>CloudWatch：日志收集，以及基于日志的错误抓取、警报。</p>\n<h3 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p>说清楚技术构成，通过说明选择原因来体现技术积累。这些技术不是我拍板的，但其实也有东西可以讲，比如用过dashbird来做服务监控，但是由于和CloudWatch的功能重复以及设计缺陷（不能屏蔽未授权错误）而被放弃。</p>\n<h1 id=\"二、JMeter\"><a href=\"#二、JMeter\" class=\"headerlink\" title=\"二、JMeter\"></a>二、JMeter</h1><h3 id=\"关键词：-1\"><a href=\"#关键词：-1\" class=\"headerlink\" title=\"关键词：\"></a>关键词：</h3><p>选择原因、如何使用、扩容问题</p>\n<h3 id=\"答：-1\"><a href=\"#答：-1\" class=\"headerlink\" title=\"答：\"></a>答：</h3><p>因为自己简单写的node工具没有人家成熟的软件好用。讲了一下使用流程、测试目的以及结果，以及对未来数据量的计划，比如使用EC2搭建分布式测试环境。</p>\n<h3 id=\"小结：-1\"><a href=\"#小结：-1\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p>表现不错，对技术有深入理解，能体现能力。</p>\n<h1 id=\"三、GraphQL\"><a href=\"#三、GraphQL\" class=\"headerlink\" title=\"三、GraphQL\"></a>三、GraphQL</h1><h3 id=\"关键词：-2\"><a href=\"#关键词：-2\" class=\"headerlink\" title=\"关键词：\"></a>关键词：</h3><p>踩过的坑、优缺点</p>\n<h3 id=\"答：-2\"><a href=\"#答：-2\" class=\"headerlink\" title=\"答：\"></a>答：</h3><p>只讲了怎么使用，对N+1问题不了解，回忆不起踩过的坑，讲不出对比RESTful的优缺点。</p>\n<h3 id=\"小结：-2\"><a href=\"#小结：-2\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p>对简历上的技能可能遇到的常见问题应该有所准备。</p>\n<h1 id=\"四、Serverless原理\"><a href=\"#四、Serverless原理\" class=\"headerlink\" title=\"四、Serverless原理\"></a>四、Serverless原理</h1><h3 id=\"关键词：-3\"><a href=\"#关键词：-3\" class=\"headerlink\" title=\"关键词：\"></a>关键词：</h3><p>docker、k8s、动态扩容</p>\n<h3 id=\"答：-3\"><a href=\"#答：-3\" class=\"headerlink\" title=\"答：\"></a>答：</h3><p>只知道是基于容器实现的弹性计算集群，但是对上述关键词的具体知识完全不了解。</p>\n<h3 id=\"小结：-3\"><a href=\"#小结：-3\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p>虽然Lambda不是开源的东西，但是它的底层原理属于比较常见的技术手段。可以说是这个岗位的核心要求，死的明明白白。</p>\n<h1 id=\"五、CLI工具\"><a href=\"#五、CLI工具\" class=\"headerlink\" title=\"五、CLI工具\"></a>五、CLI工具</h1><h3 id=\"关键词：-4\"><a href=\"#关键词：-4\" class=\"headerlink\" title=\"关键词：\"></a>关键词：</h3><p>为什么用bash不用node、做了什么</p>\n<h3 id=\"答：-4\"><a href=\"#答：-4\" class=\"headerlink\" title=\"答：\"></a>答：</h3><p>大部分命令都是shell下运行的，比如sls，用Node也是要写对应的shell命令，画蛇添足了。<br>版本号迭代、git tag管理、依赖安装、并行发布、错误中止、拉起警报</p>\n<h3 id=\"小结：-4\"><a href=\"#小结：-4\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p>还行。</p>\n<h1 id=\"六、开源项目\"><a href=\"#六、开源项目\" class=\"headerlink\" title=\"六、开源项目\"></a>六、开源项目</h1><p>因为不了解如何参与开源项目，面试官为我做了讲解。</p>\n<h3 id=\"关键词：-5\"><a href=\"#关键词：-5\" class=\"headerlink\" title=\"关键词：\"></a>关键词：</h3><p>提issue、看issue、提pr</p>\n<p>以Koa举例，将你在使用过程中踩过的坑（可以是bug，也可以是难点）在issue中提出。同时可以看看其他人提出的issue，想想为什么别人碰得到你却碰不到，以及这个问题要怎么解决。你可以在本地复现这个问题，如果得以解决，可以把自己的代码提交pull request（注意单元测试）。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>阿里的技术专家认为我的工作经历和岗位比较相符，遂进入内推。虽然我和P7还有亿点差距，但这次面试为我提供了前进的方向，受益匪浅。感谢热忱的前辈们！</p>\n</blockquote>","more":"<h1 id=\"一、技术栈\"><a href=\"#一、技术栈\" class=\"headerlink\" title=\"一、技术栈\"></a>一、技术栈</h1><h3 id=\"关键词：\"><a href=\"#关键词：\" class=\"headerlink\" title=\"关键词：\"></a>关键词：</h3><p>技术栈、选择原因</p>\n<h3 id=\"答：\"><a href=\"#答：\" class=\"headerlink\" title=\"答：\"></a>答：</h3><p>面向aws编程：<br>router53：域名管理<br>API Gateway：创建基于 HTTP 的 RESTful API<br>Lambda：代码运行环境<br>S3：提供文件存储<br>DynamoDB：非关系型数据库<br>CDN加速： Amazon CloudFront<br>IAM：身份权限管理<br>X-Ray：查看请求和响应的详细信息，并提供用于查看、筛选和获取数据洞察力的工具，以确定问题和发现优化的机会。<br>AppSync：构建 GraphQL API。.yml定义数据源、映射模板(关联架构和解析程序)，.graphql构建架构，txt编写解析程序。<br>CloudWatch：日志收集，以及基于日志的错误抓取、警报。</p>\n<h3 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p>说清楚技术构成，通过说明选择原因来体现技术积累。这些技术不是我拍板的，但其实也有东西可以讲，比如用过dashbird来做服务监控，但是由于和CloudWatch的功能重复以及设计缺陷（不能屏蔽未授权错误）而被放弃。</p>\n<h1 id=\"二、JMeter\"><a href=\"#二、JMeter\" class=\"headerlink\" title=\"二、JMeter\"></a>二、JMeter</h1><h3 id=\"关键词：-1\"><a href=\"#关键词：-1\" class=\"headerlink\" title=\"关键词：\"></a>关键词：</h3><p>选择原因、如何使用、扩容问题</p>\n<h3 id=\"答：-1\"><a href=\"#答：-1\" class=\"headerlink\" title=\"答：\"></a>答：</h3><p>因为自己简单写的node工具没有人家成熟的软件好用。讲了一下使用流程、测试目的以及结果，以及对未来数据量的计划，比如使用EC2搭建分布式测试环境。</p>\n<h3 id=\"小结：-1\"><a href=\"#小结：-1\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p>表现不错，对技术有深入理解，能体现能力。</p>\n<h1 id=\"三、GraphQL\"><a href=\"#三、GraphQL\" class=\"headerlink\" title=\"三、GraphQL\"></a>三、GraphQL</h1><h3 id=\"关键词：-2\"><a href=\"#关键词：-2\" class=\"headerlink\" title=\"关键词：\"></a>关键词：</h3><p>踩过的坑、优缺点</p>\n<h3 id=\"答：-2\"><a href=\"#答：-2\" class=\"headerlink\" title=\"答：\"></a>答：</h3><p>只讲了怎么使用，对N+1问题不了解，回忆不起踩过的坑，讲不出对比RESTful的优缺点。</p>\n<h3 id=\"小结：-2\"><a href=\"#小结：-2\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p>对简历上的技能可能遇到的常见问题应该有所准备。</p>\n<h1 id=\"四、Serverless原理\"><a href=\"#四、Serverless原理\" class=\"headerlink\" title=\"四、Serverless原理\"></a>四、Serverless原理</h1><h3 id=\"关键词：-3\"><a href=\"#关键词：-3\" class=\"headerlink\" title=\"关键词：\"></a>关键词：</h3><p>docker、k8s、动态扩容</p>\n<h3 id=\"答：-3\"><a href=\"#答：-3\" class=\"headerlink\" title=\"答：\"></a>答：</h3><p>只知道是基于容器实现的弹性计算集群，但是对上述关键词的具体知识完全不了解。</p>\n<h3 id=\"小结：-3\"><a href=\"#小结：-3\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p>虽然Lambda不是开源的东西，但是它的底层原理属于比较常见的技术手段。可以说是这个岗位的核心要求，死的明明白白。</p>\n<h1 id=\"五、CLI工具\"><a href=\"#五、CLI工具\" class=\"headerlink\" title=\"五、CLI工具\"></a>五、CLI工具</h1><h3 id=\"关键词：-4\"><a href=\"#关键词：-4\" class=\"headerlink\" title=\"关键词：\"></a>关键词：</h3><p>为什么用bash不用node、做了什么</p>\n<h3 id=\"答：-4\"><a href=\"#答：-4\" class=\"headerlink\" title=\"答：\"></a>答：</h3><p>大部分命令都是shell下运行的，比如sls，用Node也是要写对应的shell命令，画蛇添足了。<br>版本号迭代、git tag管理、依赖安装、并行发布、错误中止、拉起警报</p>\n<h3 id=\"小结：-4\"><a href=\"#小结：-4\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p>还行。</p>\n<h1 id=\"六、开源项目\"><a href=\"#六、开源项目\" class=\"headerlink\" title=\"六、开源项目\"></a>六、开源项目</h1><p>因为不了解如何参与开源项目，面试官为我做了讲解。</p>\n<h3 id=\"关键词：-5\"><a href=\"#关键词：-5\" class=\"headerlink\" title=\"关键词：\"></a>关键词：</h3><p>提issue、看issue、提pr</p>\n<p>以Koa举例，将你在使用过程中踩过的坑（可以是bug，也可以是难点）在issue中提出。同时可以看看其他人提出的issue，想想为什么别人碰得到你却碰不到，以及这个问题要怎么解决。你可以在本地复现这个问题，如果得以解决，可以把自己的代码提交pull request（注意单元测试）。</p>"},{"title":"EggJS踩坑","date":"2020-06-01T07:16:44.000Z","updated":"2020-06-01T07:16:44.000Z","_content":"\n## 1、无法获取post body\n\n<!-- more -->\n\n背景：调试微信公众平台接口时，微信使用xml传递数据\n\n问题：我在`ctx.request.body`拿不到数据，以为是bodyParser转码失败了，于是尝试了`ctx.request.rawBody`获取转码前的数据，断点测试无果，而header上的`content-length`明确地告诉我是有body的。\n\n原因：egg默认只开启部分post传输格式，xml不在其内。\n\n解决方案：在配置中启用对xml的支持：\n```javascript\n  config.bodyParser = {\n    enableTypes: [\n      'json', 'form', 'text', 'xml',\n    ],\n  };\n```\n\n## 2、还是无法获取post body\n\n问题：无法从 `ctx.req.body` 上获取表单格式的请求参数\n\n原因：egg虽然继承自koa，但是 `ctx.req` 并不恒等于 `ctx.request`，官方文档也没有介绍 `ctx.req` 的写法。\n\n解决方案：永远用 `ctx.request` 而不是 `ctx.req`\n\n## 3、无法获取环境config.${env}.js\negg默认在npm里设置的启动命令：egg-scripts start 使用的是production环境，框架默认未生成production的配置文件。\n所以，如果在local配置中指定端口，将不会起效。\n","source":"_posts/2020/06/EggJS踩坑.md","raw":"---\ntitle: EggJS踩坑\ndate: 2020-06-01 15:16:44\nupdated: 2020-06-01 15:16:44\ntags: Node.js\n---\n\n## 1、无法获取post body\n\n<!-- more -->\n\n背景：调试微信公众平台接口时，微信使用xml传递数据\n\n问题：我在`ctx.request.body`拿不到数据，以为是bodyParser转码失败了，于是尝试了`ctx.request.rawBody`获取转码前的数据，断点测试无果，而header上的`content-length`明确地告诉我是有body的。\n\n原因：egg默认只开启部分post传输格式，xml不在其内。\n\n解决方案：在配置中启用对xml的支持：\n```javascript\n  config.bodyParser = {\n    enableTypes: [\n      'json', 'form', 'text', 'xml',\n    ],\n  };\n```\n\n## 2、还是无法获取post body\n\n问题：无法从 `ctx.req.body` 上获取表单格式的请求参数\n\n原因：egg虽然继承自koa，但是 `ctx.req` 并不恒等于 `ctx.request`，官方文档也没有介绍 `ctx.req` 的写法。\n\n解决方案：永远用 `ctx.request` 而不是 `ctx.req`\n\n## 3、无法获取环境config.${env}.js\negg默认在npm里设置的启动命令：egg-scripts start 使用的是production环境，框架默认未生成production的配置文件。\n所以，如果在local配置中指定端口，将不会起效。\n","slug":"EggJS踩坑","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkv002c2yku4mmieyga","content":"<h2 id=\"1、无法获取post-body\"><a href=\"#1、无法获取post-body\" class=\"headerlink\" title=\"1、无法获取post body\"></a>1、无法获取post body</h2><a id=\"more\"></a>\n\n<p>背景：调试微信公众平台接口时，微信使用xml传递数据</p>\n<p>问题：我在<code>ctx.request.body</code>拿不到数据，以为是bodyParser转码失败了，于是尝试了<code>ctx.request.rawBody</code>获取转码前的数据，断点测试无果，而header上的<code>content-length</code>明确地告诉我是有body的。</p>\n<p>原因：egg默认只开启部分post传输格式，xml不在其内。</p>\n<p>解决方案：在配置中启用对xml的支持：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.bodyParser = &#123;</span><br><span class=\"line\">  enableTypes: [</span><br><span class=\"line\">    <span class=\"string\">&#x27;json&#x27;</span>, <span class=\"string\">&#x27;form&#x27;</span>, <span class=\"string\">&#x27;text&#x27;</span>, <span class=\"string\">&#x27;xml&#x27;</span>,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、还是无法获取post-body\"><a href=\"#2、还是无法获取post-body\" class=\"headerlink\" title=\"2、还是无法获取post body\"></a>2、还是无法获取post body</h2><p>问题：无法从 <code>ctx.req.body</code> 上获取表单格式的请求参数</p>\n<p>原因：egg虽然继承自koa，但是 <code>ctx.req</code> 并不恒等于 <code>ctx.request</code>，官方文档也没有介绍 <code>ctx.req</code> 的写法。</p>\n<p>解决方案：永远用 <code>ctx.request</code> 而不是 <code>ctx.req</code></p>\n<h2 id=\"3、无法获取环境config-env-js\"><a href=\"#3、无法获取环境config-env-js\" class=\"headerlink\" title=\"3、无法获取环境config.${env}.js\"></a>3、无法获取环境config.${env}.js</h2><p>egg默认在npm里设置的启动命令：egg-scripts start 使用的是production环境，框架默认未生成production的配置文件。<br>所以，如果在local配置中指定端口，将不会起效。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1、无法获取post-body\"><a href=\"#1、无法获取post-body\" class=\"headerlink\" title=\"1、无法获取post body\"></a>1、无法获取post body</h2>","more":"<p>背景：调试微信公众平台接口时，微信使用xml传递数据</p>\n<p>问题：我在<code>ctx.request.body</code>拿不到数据，以为是bodyParser转码失败了，于是尝试了<code>ctx.request.rawBody</code>获取转码前的数据，断点测试无果，而header上的<code>content-length</code>明确地告诉我是有body的。</p>\n<p>原因：egg默认只开启部分post传输格式，xml不在其内。</p>\n<p>解决方案：在配置中启用对xml的支持：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.bodyParser = &#123;</span><br><span class=\"line\">  enableTypes: [</span><br><span class=\"line\">    <span class=\"string\">&#x27;json&#x27;</span>, <span class=\"string\">&#x27;form&#x27;</span>, <span class=\"string\">&#x27;text&#x27;</span>, <span class=\"string\">&#x27;xml&#x27;</span>,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、还是无法获取post-body\"><a href=\"#2、还是无法获取post-body\" class=\"headerlink\" title=\"2、还是无法获取post body\"></a>2、还是无法获取post body</h2><p>问题：无法从 <code>ctx.req.body</code> 上获取表单格式的请求参数</p>\n<p>原因：egg虽然继承自koa，但是 <code>ctx.req</code> 并不恒等于 <code>ctx.request</code>，官方文档也没有介绍 <code>ctx.req</code> 的写法。</p>\n<p>解决方案：永远用 <code>ctx.request</code> 而不是 <code>ctx.req</code></p>\n<h2 id=\"3、无法获取环境config-env-js\"><a href=\"#3、无法获取环境config-env-js\" class=\"headerlink\" title=\"3、无法获取环境config.${env}.js\"></a>3、无法获取环境config.${env}.js</h2><p>egg默认在npm里设置的启动命令：egg-scripts start 使用的是production环境，框架默认未生成production的配置文件。<br>所以，如果在local配置中指定端口，将不会起效。</p>"},{"title":"docker踩坑","date":"2020-06-02T08:59:18.000Z","updated":"2020-06-02T08:59:18.000Z","_content":"\n## 1、尝试用docker运行本地新项目，一直启动就关闭。\n\n<!-- more -->\n\n原因：docker必须有前台进程，否则会自动关闭。eggjs的start命令默认有参数 --daemon，\n\n解决方案：将`start`这行里命令里的`--daemon`去掉，即启动eggjs使用`egg-scripts start`就好了。在Docker里eggjs应用要在前台运行。当然，docker自身可以用run -d后台运行。\n\n## 2、容器内应用无法访问宿主机的服务比如mysql。\n\n原因：容器有自己的ip，有别于宿主机。\n\n解决方案：数据库地址填写宿主机的内网ip如 172.** 而不是 127.0.0.1\n\n\n","source":"_posts/2020/06/docker踩坑.md","raw":"---\ntitle: docker踩坑\ndate: 2020-06-02 16:59:18\nupdated: 2020-06-02 16:59:18\ntags: 容器\n---\n\n## 1、尝试用docker运行本地新项目，一直启动就关闭。\n\n<!-- more -->\n\n原因：docker必须有前台进程，否则会自动关闭。eggjs的start命令默认有参数 --daemon，\n\n解决方案：将`start`这行里命令里的`--daemon`去掉，即启动eggjs使用`egg-scripts start`就好了。在Docker里eggjs应用要在前台运行。当然，docker自身可以用run -d后台运行。\n\n## 2、容器内应用无法访问宿主机的服务比如mysql。\n\n原因：容器有自己的ip，有别于宿主机。\n\n解决方案：数据库地址填写宿主机的内网ip如 172.** 而不是 127.0.0.1\n\n\n","slug":"docker踩坑","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkv002e2ykue8qyghnl","content":"<h2 id=\"1、尝试用docker运行本地新项目，一直启动就关闭。\"><a href=\"#1、尝试用docker运行本地新项目，一直启动就关闭。\" class=\"headerlink\" title=\"1、尝试用docker运行本地新项目，一直启动就关闭。\"></a>1、尝试用docker运行本地新项目，一直启动就关闭。</h2><a id=\"more\"></a>\n\n<p>原因：docker必须有前台进程，否则会自动关闭。eggjs的start命令默认有参数 –daemon，</p>\n<p>解决方案：将<code>start</code>这行里命令里的<code>--daemon</code>去掉，即启动eggjs使用<code>egg-scripts start</code>就好了。在Docker里eggjs应用要在前台运行。当然，docker自身可以用run -d后台运行。</p>\n<h2 id=\"2、容器内应用无法访问宿主机的服务比如mysql。\"><a href=\"#2、容器内应用无法访问宿主机的服务比如mysql。\" class=\"headerlink\" title=\"2、容器内应用无法访问宿主机的服务比如mysql。\"></a>2、容器内应用无法访问宿主机的服务比如mysql。</h2><p>原因：容器有自己的ip，有别于宿主机。</p>\n<p>解决方案：数据库地址填写宿主机的内网ip如 172.** 而不是 127.0.0.1</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1、尝试用docker运行本地新项目，一直启动就关闭。\"><a href=\"#1、尝试用docker运行本地新项目，一直启动就关闭。\" class=\"headerlink\" title=\"1、尝试用docker运行本地新项目，一直启动就关闭。\"></a>1、尝试用docker运行本地新项目，一直启动就关闭。</h2>","more":"<p>原因：docker必须有前台进程，否则会自动关闭。eggjs的start命令默认有参数 –daemon，</p>\n<p>解决方案：将<code>start</code>这行里命令里的<code>--daemon</code>去掉，即启动eggjs使用<code>egg-scripts start</code>就好了。在Docker里eggjs应用要在前台运行。当然，docker自身可以用run -d后台运行。</p>\n<h2 id=\"2、容器内应用无法访问宿主机的服务比如mysql。\"><a href=\"#2、容器内应用无法访问宿主机的服务比如mysql。\" class=\"headerlink\" title=\"2、容器内应用无法访问宿主机的服务比如mysql。\"></a>2、容器内应用无法访问宿主机的服务比如mysql。</h2><p>原因：容器有自己的ip，有别于宿主机。</p>\n<p>解决方案：数据库地址填写宿主机的内网ip如 172.** 而不是 127.0.0.1</p>"},{"title":"redis踩坑","date":"2020-06-27T09:04:55.000Z","updated":"2020-06-27T09:04:55.000Z","_content":"## 1、docker无法访问宿主机的redis\n\n<!-- more -->\n\n原因：redis默认配置的host是127.0.0.1，与容器不同网段。\n解决方案：绑定ip增加局域网地址：\n多个ip用空格分开\nbind 127.0.0.1 192.168.3.3\n","source":"_posts/2020/06/redis踩坑.md","raw":"---\ntitle: redis踩坑\ndate: 2020-06-27 17:04:55\nupdated: 2020-06-27 17:04:55\ntags: 数据库\n---\n## 1、docker无法访问宿主机的redis\n\n<!-- more -->\n\n原因：redis默认配置的host是127.0.0.1，与容器不同网段。\n解决方案：绑定ip增加局域网地址：\n多个ip用空格分开\nbind 127.0.0.1 192.168.3.3\n","slug":"redis踩坑","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkw002h2yku0qud0mou","content":"<h2 id=\"1、docker无法访问宿主机的redis\"><a href=\"#1、docker无法访问宿主机的redis\" class=\"headerlink\" title=\"1、docker无法访问宿主机的redis\"></a>1、docker无法访问宿主机的redis</h2><a id=\"more\"></a>\n\n<p>原因：redis默认配置的host是127.0.0.1，与容器不同网段。<br>解决方案：绑定ip增加局域网地址：<br>多个ip用空格分开<br>bind 127.0.0.1 192.168.3.3</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1、docker无法访问宿主机的redis\"><a href=\"#1、docker无法访问宿主机的redis\" class=\"headerlink\" title=\"1、docker无法访问宿主机的redis\"></a>1、docker无法访问宿主机的redis</h2>","more":"<p>原因：redis默认配置的host是127.0.0.1，与容器不同网段。<br>解决方案：绑定ip增加局域网地址：<br>多个ip用空格分开<br>bind 127.0.0.1 192.168.3.3</p>"},{"title":"sequelize踩坑","date":"2020-06-03T07:16:44.000Z","updated":"2020-06-03T07:16:44.000Z","_content":"\n## 1、Egg.JS中sequelize实例无法获取\n<!-- more -->\n\nTypeError: app.Sequelize.query is not a function\n\n正解：\napp.taobaoModel.query()\n\n## 2、解决sequelize的副作用：\n### 2.1 通过include查询造成的不必要的嵌套\n在查询的上层使用col指定查询列\n```\nattributes: {\n  include: [\n    [ col('oneCategory.name'), 'oneCategoryName' ],\n  ],\n  exclude: [ 'createdAt', 'updatedAt', 'deletedAt' ],\n},\ninclude: [\n  {\n    model: app.advModel.ToolCategory,\n    as: 'oneCategory',\n    attributes: [],\n  },\n]\n```\n### 2.2 查询结果为模型实例，需要 `toJson()` 处理\n增加参数 `raw: true`，如果需要使用关联查询include，则同时使用 `nest: true`\n","source":"_posts/2020/06/sequelize踩坑.md","raw":"---\ntitle: sequelize踩坑\ndate: 2020-06-03 15:16:44\nupdated: 2020-06-03 15:16:44\ntags: Node.js\n---\n\n## 1、Egg.JS中sequelize实例无法获取\n<!-- more -->\n\nTypeError: app.Sequelize.query is not a function\n\n正解：\napp.taobaoModel.query()\n\n## 2、解决sequelize的副作用：\n### 2.1 通过include查询造成的不必要的嵌套\n在查询的上层使用col指定查询列\n```\nattributes: {\n  include: [\n    [ col('oneCategory.name'), 'oneCategoryName' ],\n  ],\n  exclude: [ 'createdAt', 'updatedAt', 'deletedAt' ],\n},\ninclude: [\n  {\n    model: app.advModel.ToolCategory,\n    as: 'oneCategory',\n    attributes: [],\n  },\n]\n```\n### 2.2 查询结果为模型实例，需要 `toJson()` 处理\n增加参数 `raw: true`，如果需要使用关联查询include，则同时使用 `nest: true`\n","slug":"sequelize踩坑","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkx002j2ykugp64gfis","content":"<h2 id=\"1、Egg-JS中sequelize实例无法获取\"><a href=\"#1、Egg-JS中sequelize实例无法获取\" class=\"headerlink\" title=\"1、Egg.JS中sequelize实例无法获取\"></a>1、Egg.JS中sequelize实例无法获取</h2><a id=\"more\"></a>\n\n<p>TypeError: app.Sequelize.query is not a function</p>\n<p>正解：<br>app.taobaoModel.query()</p>\n<h2 id=\"2、解决sequelize的副作用：\"><a href=\"#2、解决sequelize的副作用：\" class=\"headerlink\" title=\"2、解决sequelize的副作用：\"></a>2、解决sequelize的副作用：</h2><h3 id=\"2-1-通过include查询造成的不必要的嵌套\"><a href=\"#2-1-通过include查询造成的不必要的嵌套\" class=\"headerlink\" title=\"2.1 通过include查询造成的不必要的嵌套\"></a>2.1 通过include查询造成的不必要的嵌套</h3><p>在查询的上层使用col指定查询列</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attributes: &#123;</span><br><span class=\"line\">  include: [</span><br><span class=\"line\">    [ col(&#39;oneCategory.name&#39;), &#39;oneCategoryName&#39; ],</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  exclude: [ &#39;createdAt&#39;, &#39;updatedAt&#39;, &#39;deletedAt&#39; ],</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">include: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    model: app.advModel.ToolCategory,</span><br><span class=\"line\">    as: &#39;oneCategory&#39;,</span><br><span class=\"line\">    attributes: [],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-查询结果为模型实例，需要-toJson-处理\"><a href=\"#2-2-查询结果为模型实例，需要-toJson-处理\" class=\"headerlink\" title=\"2.2 查询结果为模型实例，需要 toJson() 处理\"></a>2.2 查询结果为模型实例，需要 <code>toJson()</code> 处理</h3><p>增加参数 <code>raw: true</code>，如果需要使用关联查询include，则同时使用 <code>nest: true</code></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1、Egg-JS中sequelize实例无法获取\"><a href=\"#1、Egg-JS中sequelize实例无法获取\" class=\"headerlink\" title=\"1、Egg.JS中sequelize实例无法获取\"></a>1、Egg.JS中sequelize实例无法获取</h2>","more":"<p>TypeError: app.Sequelize.query is not a function</p>\n<p>正解：<br>app.taobaoModel.query()</p>\n<h2 id=\"2、解决sequelize的副作用：\"><a href=\"#2、解决sequelize的副作用：\" class=\"headerlink\" title=\"2、解决sequelize的副作用：\"></a>2、解决sequelize的副作用：</h2><h3 id=\"2-1-通过include查询造成的不必要的嵌套\"><a href=\"#2-1-通过include查询造成的不必要的嵌套\" class=\"headerlink\" title=\"2.1 通过include查询造成的不必要的嵌套\"></a>2.1 通过include查询造成的不必要的嵌套</h3><p>在查询的上层使用col指定查询列</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attributes: &#123;</span><br><span class=\"line\">  include: [</span><br><span class=\"line\">    [ col(&#39;oneCategory.name&#39;), &#39;oneCategoryName&#39; ],</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  exclude: [ &#39;createdAt&#39;, &#39;updatedAt&#39;, &#39;deletedAt&#39; ],</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">include: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    model: app.advModel.ToolCategory,</span><br><span class=\"line\">    as: &#39;oneCategory&#39;,</span><br><span class=\"line\">    attributes: [],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-查询结果为模型实例，需要-toJson-处理\"><a href=\"#2-2-查询结果为模型实例，需要-toJson-处理\" class=\"headerlink\" title=\"2.2 查询结果为模型实例，需要 toJson() 处理\"></a>2.2 查询结果为模型实例，需要 <code>toJson()</code> 处理</h3><p>增加参数 <code>raw: true</code>，如果需要使用关联查询include，则同时使用 <code>nest: true</code></p>"},{"title":"mysql踩坑","date":"2020-07-05T09:06:47.000Z","updated":"2020-07-05T09:06:47.000Z","_content":"\n1. 查询分组后每个组内的数量\ngroup by和count一起用时，count的是分组内成员的数量，而不是分组的数量。\n如果要count所有，可以用子查询。\n2. 查询 group by A,B的条数？可以用count(distinct B) group by A;\n\n<!-- more -->\n","source":"_posts/2020/07/mysql踩坑.md","raw":"---\ntitle: mysql踩坑\ndate: 2020-07-05 17:06:47\nupdated: 2020-07-05 17:06:47\ntags: 数据库\n---\n\n1. 查询分组后每个组内的数量\ngroup by和count一起用时，count的是分组内成员的数量，而不是分组的数量。\n如果要count所有，可以用子查询。\n2. 查询 group by A,B的条数？可以用count(distinct B) group by A;\n\n<!-- more -->\n","slug":"mysql踩坑","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrky002l2ykua2n9ht52","content":"<ol>\n<li>查询分组后每个组内的数量<br>group by和count一起用时，count的是分组内成员的数量，而不是分组的数量。<br>如果要count所有，可以用子查询。</li>\n<li>查询 group by A,B的条数？可以用count(distinct B) group by A;</li>\n</ol>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<ol>\n<li>查询分组后每个组内的数量<br>group by和count一起用时，count的是分组内成员的数量，而不是分组的数量。<br>如果要count所有，可以用子查询。</li>\n<li>查询 group by A,B的条数？可以用count(distinct B) group by A;</li>\n</ol>","more":""},{"title":"Array.prototype.map中的this问题","date":"2020-12-05T10:16:17.000Z","updated":"2020-12-05T10:16:17.000Z","_content":"TypeError: Cannot read property 'ctx' of undefined\n\n<!-- more -->\n\n问题代码：\n```\nclass UserInterestsService extends Service {\n  getInterests(userInterests) {\n    return new Interests(this.ctx, userInterests);\n  }\n  async getUserInterests() {\n    return userInterests.map(this.getInterests);\n  }\n}\n```\n\n问题出在方法getInterests()中，错误内容：TypeError: Cannot read property 'ctx' of undefined\n\n原因：Array.prototype.map()方法将回调的this指向了undefined。\n\n原理：map()方法调用回调的本质是callback.call(thisArg:undefined, ob)，而箭头函数在执行的时候默认不会使用自己的this，而是会和外层的this保持一致。\n\n解决办法：\n1、使用map时增加第二个参数：thisArg: this，执行 `callback` 函数时值被用作`this`。\n2、使用箭头函数作为回调。\n```\nreturn userInterests.map(e => { return this.getInterests(e); });\n```\n","source":"_posts/2020/12/map-中的this问题.md","raw":"---\ntitle: Array.prototype.map中的this问题\ndate: 2020-12-05 18:16:17\nupdated: 2020-12-05 18:16:17\ntags: JS\n---\nTypeError: Cannot read property 'ctx' of undefined\n\n<!-- more -->\n\n问题代码：\n```\nclass UserInterestsService extends Service {\n  getInterests(userInterests) {\n    return new Interests(this.ctx, userInterests);\n  }\n  async getUserInterests() {\n    return userInterests.map(this.getInterests);\n  }\n}\n```\n\n问题出在方法getInterests()中，错误内容：TypeError: Cannot read property 'ctx' of undefined\n\n原因：Array.prototype.map()方法将回调的this指向了undefined。\n\n原理：map()方法调用回调的本质是callback.call(thisArg:undefined, ob)，而箭头函数在执行的时候默认不会使用自己的this，而是会和外层的this保持一致。\n\n解决办法：\n1、使用map时增加第二个参数：thisArg: this，执行 `callback` 函数时值被用作`this`。\n2、使用箭头函数作为回调。\n```\nreturn userInterests.map(e => { return this.getInterests(e); });\n```\n","slug":"map-中的this问题","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrkz002o2yku9lz8h8i7","content":"<p>TypeError: Cannot read property ‘ctx’ of undefined</p>\n<a id=\"more\"></a>\n\n<p>问题代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class UserInterestsService extends Service &#123;</span><br><span class=\"line\">  getInterests(userInterests) &#123;</span><br><span class=\"line\">    return new Interests(this.ctx, userInterests);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  async getUserInterests() &#123;</span><br><span class=\"line\">    return userInterests.map(this.getInterests);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>问题出在方法getInterests()中，错误内容：TypeError: Cannot read property ‘ctx’ of undefined</p>\n<p>原因：Array.prototype.map()方法将回调的this指向了undefined。</p>\n<p>原理：map()方法调用回调的本质是callback.call(thisArg:undefined, ob)，而箭头函数在执行的时候默认不会使用自己的this，而是会和外层的this保持一致。</p>\n<p>解决办法：<br>1、使用map时增加第二个参数：thisArg: this，执行 <code>callback</code> 函数时值被用作<code>this</code>。<br>2、使用箭头函数作为回调。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return userInterests.map(e &#x3D;&gt; &#123; return this.getInterests(e); &#125;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>TypeError: Cannot read property ‘ctx’ of undefined</p>","more":"<p>问题代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class UserInterestsService extends Service &#123;</span><br><span class=\"line\">  getInterests(userInterests) &#123;</span><br><span class=\"line\">    return new Interests(this.ctx, userInterests);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  async getUserInterests() &#123;</span><br><span class=\"line\">    return userInterests.map(this.getInterests);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>问题出在方法getInterests()中，错误内容：TypeError: Cannot read property ‘ctx’ of undefined</p>\n<p>原因：Array.prototype.map()方法将回调的this指向了undefined。</p>\n<p>原理：map()方法调用回调的本质是callback.call(thisArg:undefined, ob)，而箭头函数在执行的时候默认不会使用自己的this，而是会和外层的this保持一致。</p>\n<p>解决办法：<br>1、使用map时增加第二个参数：thisArg: this，执行 <code>callback</code> 函数时值被用作<code>this</code>。<br>2、使用箭头函数作为回调。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return userInterests.map(e &#x3D;&gt; &#123; return this.getInterests(e); &#125;);</span><br></pre></td></tr></table></figure>"},{"title":"当我们查询的时候，到底发生了什么 - MySQL","date":"2020-12-05T10:01:23.000Z","updated":"2020-12-05T10:01:23.000Z","_content":"\n<!-- more -->\n","source":"_posts/2020/12/当我们查询的时候，到底发生了什么-MySQL.md","raw":"---\ntitle: 当我们查询的时候，到底发生了什么 - MySQL\ndate: 2020-12-05 18:01:23\nupdated: 2020-12-05 18:01:23\ntags: 数据库\n---\n\n<!-- more -->\n","slug":"当我们查询的时候，到底发生了什么-MySQL","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrl0002q2yku0s85ge74","content":"<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"","more":""},{"title":"Java虚拟机","date":"2019-03-20T16:17:00.000Z","updated":"2019-03-20T16:17:00.000Z","_content":"# 一、概念\n\n虚拟机：指以软件的方式模拟具有完整硬件系统功能、运行在一个完全隔离环境中的完整计算机系统 ，是物理机的软件实现。常用的虚拟机有VMWare，Visual Box，Java Virtual Machine（Java虚拟机，简称JVM）。\n\n<!-- more -->\n\nJava虚拟机阵营：Sun HotSpot VM、BEA JRockit VM、IBM J9 VM、Azul VM、Apache Harmony、Google Dalvik VM、Microsoft JVM…\n\n# 二、启动流程\n\n{% asset_img 640.webp 启动流程 %}\n\n# 三、基本架构\n\n{% asset_img 2.webp %}\nJava运行时编译源码(.java)成字节码，由jre运行。jre由java虚拟机（jvm）实现。Jvm分析字节码，后解释并执行。\n\n{% asset_img 3.webp %}\nJVM由三个主要的子系统构成：\n1. 类加载器子系统\n2. 运行时数据区（内存）\n3. 执行引擎\n\n# 四、类加载器子系统\n\n{% asset_img 4.webp %}\n类装载包括了加载，连接（验证、准备、解析（可选）），初始化。其中类加载工作由 ClassLoader 及其子类负责。\n\n- 加载：在硬盘上查找并通过IO读入字节码文件\n- 连接：执行校验、准备、解析（可选）步骤\n- 校验：校验字节码文件的正确性\n- 准备：给类的静态变量分配内存，并赋予默认值\n- 解析：将符号引用转为直接引用，类装载器装入类所引用的其他所有类\n{% asset_img 5.webp %}\n- 初始化：对类的静态变量初始化为指定的值，执行静态代码块\n\n# 五、类加载器体系结构\n\n{% asset_img 6.webp %}\n1．启动类加载器：负责加载JRE的核心类库，如jre目标下的rt.jar,charsets.jar等\n2．扩展类加载器：负责加载JRE扩展目录ext中JAR类包\n3．系统类加载器：负责加载ClassPath路径下的类包\n4．用户自定义加载器：负责加载用户自定义路径下的类包\n\n\n# 六、类加载机制（双亲委派）\n\n全盘负责委托机制。全盘负责，当一个ClassLoader加载一个类时，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个ClassLoader载入。\n委托机制：指先委托父类加载器寻找目标类，在找不到的情况下采用自己的路径中查找并载入目标类。\n\n# 七、运行时数据区\n\n{% asset_img 7.webp %}\n\n# 八、堆（Java堆）\n\n虚拟机启动时创建，用于存放对象实例，几乎所有的对象（包含常量池）都在堆上分配内存，当对象无法再该空间申请到内存时将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。可通过 -Xmx –Xms 参数来分别指定最大堆和最小堆。线程共享。\n{% asset_img 8.webp %}\n\n# 九、栈（Java栈）\n\n是java方法执行的内存模型，为虚拟机执行java方法，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）。线程独占。\n{% asset_img 9.webp %}\nJvm对该区域规范了两种异常：\n1. 线程请求的栈深度大于虚拟机栈所允许的深度，将抛出StackOverFlowError异常。\n2. 若虚拟机栈可动态扩展，当无法申请到足够内存空间时将抛出OutOfMemoryError。通过jvm参数–Xss指定栈空间，空间大小决定函数调用的深度。\n\n# 十、本地方法栈\n\n为虚拟机执行native方法，其他规范与java栈类似。不同类型的虚拟机对该区域可自由实现。线程独占。\n\n# 十一、PC寄存器（程序计数器）\n\n用来存储待执行指令的地址。分支，循环，跳转，异常处理，线程恢复等功能都需要依赖pc寄存器。线程独占。\n若线程执行的是一个java方法，则pc寄存器中保存的是待执行指令的地址。若执行的是一个native方法，则pc寄存器中为空。\n\n# 十二、元数据区\n\n元数据区取代了永久代，本质和永久代类似，都是对JVM规范中方法区的实现，区别在于元数据区并不在虚拟机中，而是使用本地内存。元数据区在频繁使用，也会发生OutOfMemory异常。\n\n元数据区的动态扩展，默认–XX:MetaspaceSize值为21MB的高水位线。一旦触及则Full GC将被触发并卸载没有用的类（类对应的类加载器不再存活），然后高水位线将会重置。新的高水位线的值取决于GC后释放的元空间。如果释放的空间少，这个高水位线则上升。如果释放空间过多，则高水位线下降。\n{% asset_img 10.webp %}\n\n# 十三、执行引擎\n\n{% asset_img 11.webp %}\n\n执行引擎读取运行时数据区的字节码并逐个执行\n\n1. 解释器：解释器更快地解释字节码,但执行缓慢,解释一句执行一句。\n2. JIT编译器：JIT编译器消除了解释器的缺点。执行引擎通过解释器转换字节码，当它发现重复的代码时，将使用JIT编译器，它编译整个字节码并将其更改为本地代码。这个本地代码将直接用于重复的方法调用，这提高了系统的性能。\n> JIT的构成组件为：\n中间代码生成器（Intermediate Code Generator）：生成中间代码 。\n代码优化器（Code Optimizer）：负责优化上面生成的中间代码 。\n目标代码生成器（Target Code Generator）：负责生成机器代码或本地代码 。\n分析器（Profiler）：一个特殊组件，负责查找热点（被多次调用的方法）\n3. 垃圾收集器：收集和删除未引用的对象。程序可调用System.gc()触发垃圾收集，但不能保证执行。\n4. 本地方法接口（JNI）：JNI将与本机方法库进行交互，并提供执行引擎所需的本机库。\n5. 本地方法库：执行引擎所需的本机库的集合。\n\n# 十四、垃圾收集（GC：Garbage Collection）\n- 如何识别垃圾，判定对象是否可被回收？\n\n引用计数法：给每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。用对象计数器是否为0来判断对象是否可被回收。缺点：无法解决循环引用的问题。\n\n根搜索算法：也称可达性分析法，通过“GC ROOTs”的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收（可作为GC ROOTs的对象：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象）。\n\n- Java 中的堆是 GC 收集垃圾的主要区域，GC 分为两种：Minor GC、Full GC( 或称为 Major GC)。\n\nMinor GC：新生代（Young Gen）空间不足时触发收集，由于Java 中的大部分对象通常不需长久存活，新生代是GC收集频繁区域，所以采用复制算法。\n\nFull GC：老年代（Old Gen）空间不足或元空间达到高水位线执行收集动作，由于存放大对象及长久存活下的对象，占用内存空间大，回收效率低，所以采用标记-清除算法。\n\n# 十五、GC算法\n\n## 按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。\n\n1.标记-清除算法：分为两阶段“标记”和“清除”。首先标记出哪些对象可被回收，在标记完成之后统一回收所有被标记的对象所占用的内存空间。不足之处：1.无法处理循环引用的问题2.效率不高3.产生大量内存碎片（ps：空间碎片太多可能会导致以后在分配大对象的时候而无法申请到足够的连续内存空间，导致提前触发新一轮gc）\n{% asset_img 12.webp %}\n\n2.标记-整理算法：分为两阶段“标记”和“整理”。首先标记出哪些对象可被回收，在标记完成后，将对象向一端移动，然后直接清理掉边界以外的内存。\n{% asset_img 13.webp %}\n\n3.复制算法：把内存空间划为两个相等的区域，每次只使用其中一个区域。gc时遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。不足之处：1.内存利用率问题2.在对象存活率较高时，其效率会变低。\n{% asset_img 14.webp %}\n\n## 按分区对待可分为：增量收集算法，分代收集算法\n\n1.增量收集:实时垃圾回收算法，即：在应用进行的同时进行垃圾回收，理论上可以解决传统分代方式带来的问题。增量收集把对堆空间划分成一系列内存块，使用时先使用其中一部分，垃圾收集时把之前用掉的部分中的存活对象再放到后面没有用的空间中，这样可以实现一直边使用边收集的效果，避免了传统分代方式整个使用完了再暂停的回收的情况。\n\n2.分代收集:（商用默认）基于对象生命周期划分为新生代、老年代、元空间，对不同生命周期的对象使用不同的算法进行回收。\n{% asset_img 15.webp %}\n\n## 按系统线程可分为：串行收集算法，并行收集算法，并发收集算法\n\n1. 串行收集:使用单线程处理垃圾回收工作，实现容易，效率较高。不足之处：1.无法发挥多处理器的优势 2.需要暂停用户线程\n2. 并行收集:使用多线程处理垃圾回收工作，速度快，效率高。理论上CPU数目越多，越能体现出并行收集器的优势。不足之处：需要暂停用户线程\n3. 并发收集:垃圾线程与用户线程同时工作。系统在垃圾回收时不需要暂停用户线程\n\n# 十六、GC收集器\n垃圾收集算法是内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。\n\n1.Serial 收集器主要针对新生代的收集，是最基本最古老的收集器，它是单线程收集器，工作时必须暂停所有用户线程。该收集器采用复制算法。           \nSerial Old收集器主要针对老年代收集，采用标记-整理算法，实现简单高效，但会停顿。\n{% asset_img 16.webp %}\n\n2.ParNew收集器是Serial的多线程版本，针对新生代采用复制算法使用多线程进行垃圾收集（并行收集器，响应优先）。\n\n3.Parallel Scavenge采用复制算法针对新生代的多线程收集器（并行收集器，吞吐优先）。可控制吞吐量和停顿时间，即吞吐量 = 运行用户代码时间 / (运行用户代码时间+垃圾收集时间)。\nParallel Old收集器是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和标记-整理算法。\n{% asset_img 17.webp %}\n\n4.CMS（Current MarkSweep）收集器针对老年代，是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是标记-清除算法。\n{% asset_img 19.webp %}\n\n5.G1的新生代类似于ParNew，采用复制算法算法，当新生代占用达到一定比例的时候，开始收集。老年代类似于CMS，不同点是采用标记-整理算法。\nG1因此它是一款并行与并发收集器，能充分利用多CPU、多核环境。并且它能建立可预测的停顿时间模型。\n\n{% asset_img 20.webp %}\n{% asset_img 21.webp %}\n与CMS收集器相比G1收集器有以下特点：\n\n1. 空间整合，G1收集器采用标记-整理算法，不会产生内存空间碎片。分配大对象（直接进Humongous区，专门存放短期巨型对象，不用直接进老年代，避免Full GC的大量开销）不会因为无法找到连续空间而提前触发下一次GC。（年青代拷贝、老年代转移对象无空闲分区、巨型对象无连续分区时触发Full GC，开销极大应该避免）\n2. 可预测停顿，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间内，消耗在垃圾收集上的时间不得超过N毫秒，几乎达到Java实时系统（RTSJ）级的垃圾收集器。\n3. G1将Java堆划分为多个大小相等的独立区域（Region），虽保留新生代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。\n\n# 十七、收集器常用组合\n{% asset_img 22.webp %}\n{% asset_img 23.webp %}\n\n# 十八、JVM性能调优思路\n{% asset_img 24.webp %}\n\n# 十九、理解GC日志\n{% asset_img 24.webp %}\n\n```\n[GC [PSYoungGen: 8192K->1000K(9216K)] 16004K->14604K(29696K), 0.0317424 secs] [Times: user=0.06 sys=0.00, real=0.03 secs]\n\n[GC [PSYoungGen: 9192K->1016K(9216K)] 22796K->20780K(29696K), 0.0314567 secs] [Times: user=0.06 sys=0.00, real=0.03 secs]\n\n[Full GC [PSYoungGen: 8192K->8192K(9216K)] [ParOldGen: 20435K->20435K(20480K)] 28627K->28627K(29696K), [Metaspace: 8469K->8469K(1056768K)], 0.1307495 secs] [Times: user=0.50 sys=0.00, real=0.13 secs]\n\n[Full GC [PSYoungGen: 8192K->8192K(9216K)] [ParOldGen: 20437K->20437K(20480K)] 28629K->28629K(29696K), [Metaspace: 8469K->8469K(1056768K)], 0.1240311 secs] [Times: user=0.42 sys=0.00, real=0.12 secs]\n```\n# 二十、常见异常\n```\nStackOverflowError:（栈溢出）\n\nOutOfMemoryError: Java heap space（堆空间不足）\n\nOutOfMemoryError: GC overhead limit exceeded  （GC花费的时间超过 98%, 并且GC回收的内存少于 2%）\n```\n# 二十一、GC参数\n```\n堆栈设置\n\n-Xss:每个线程的栈大小\n\n-Xms:初始堆大小，默认物理内存的1/64\n\n-Xmx:最大堆大小，默认物理内存的1/4\n\n-Xmn:新生代大小\n\n-XX:NewSize:设置新生代初始大小\n\n-XX:NewRatio:默认2表示新生代占年老代的1/2，占整个堆内存的1/3。\n\n-XX:SurvivorRatio:默认8表示一个survivor区占用1/8的Eden内存，即1/10的新生代内存。\n\n-XX:MaxMetaspaceSize:设置元空间最大允许大小，默认不受限制，JVM Metaspace会进行动态扩展。\n\n垃圾回收统计信息\n\n-XX:+PrintGC\n\n-XX:+PrintGCDetails\n\n-XX:+PrintGCTimeStamps\n\n-Xloggc:filename\n\n收集器设置\n\n-XX:+UseSerialGC:设置串行收集器\n\n-XX:+UseParallelGC:设置并行收集器\n\n-XX:+UseParallelOldGC:老年代使用并行回收收集器\n\n-XX:+UseParNewGC:在新生代使用并行收集器\n\n-XX:+UseParalledlOldGC:设置并行老年代收集器\n\n-XX:+UseConcMarkSweepGC:设置CMS并发收集器\n\n-XX:+UseG1GC:设置G1收集器\n\n-XX:ParallelGCThreads:设置用于垃圾回收的线程数\n\n并行收集器设置\n\n-XX:ParallelGCThreads:设置并行收集器收集时使用的CPU数。并行收集线程数。\n\n-XX:MaxGCPauseMillis:设置并行收集最大暂停时间\n\n-XX:GCTimeRatio:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)\n\nCMS收集器设置\n\n-XX:+UseConcMarkSweepGC:设置CMS并发收集器\n\n-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。\n\n-XX:ParallelGCThreads:设置并发收集器新生代收集方式为并行收集时，使用的CPU数。并行收集线程数。\n\n-XX:CMSFullGCsBeforeCompaction:设定进行多少次CMS垃圾回收后，进行一次内存压缩\n\n-XX:+CMSClassUnloadingEnabled:允许对类元数据进行回收\n\n-XX:UseCMSInitiatingOccupancyOnly:表示只在到达阀值的时候，才进行CMS回收\n\n-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况\n\n-XX:ParallelCMSThreads:设定CMS的线程数量\n\n-XX:CMSInitiatingOccupancyFraction:设置CMS收集器在老年代空间被使用多少后触发\n\n-XX:+UseCMSCompactAtFullCollection:设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理\n\nG1收集器设置\n\n-XX:+UseG1GC:使用G1收集器\n\n-XX:ParallelGCThreads:指定GC工作的线程数量\n\n-XX:G1HeapRegionSize:指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区\n\n-XX:GCTimeRatio:吞吐量大小，0-100的整数(默认9)，值为n则系统将花费不超过1/(1+n)的时间用于垃圾收集\n\n-XX:MaxGCPauseMillis:目标暂停时间(默认200ms)\n\n-XX:G1NewSizePercent:新生代内存初始空间(默认整堆5%)\n\n-XX:G1MaxNewSizePercent:新生代内存最大空间\n\n-XX:TargetSurvivorRatio:Survivor填充容量(默认50%)\n\n-XX:MaxTenuringThreshold:最大任期阈值(默认15)\n\n-XX:InitiatingHeapOccupancyPercen:老年代占用空间超过整堆比IHOP阈值(默认45%),超过则执行混合收集\n\n-XX:G1HeapWastePercent:堆废物百分比(默认5%)\n\n-XX:G1MixedGCCountTarget:参数混合周期的最大总次数(默认8)\n```\n\n# 二十二、性能分析和监控工具\n\n- Jps：虚拟机进程状况工具\n- Jstat：虚拟机统计信息监视工具\n- Jinfo：虚拟机配置信息工具\n- Jmap：内存映像工具\n- Jhat：虚拟机堆转储快照分析工具\n- Jstack：堆栈跟踪工具\n- JConsole：java监视与管理控制台\n- VisualVM：故障处理工具\n\n> Learned from 鲁班学院","source":"_posts/2019/Java虚拟机.md","raw":"---\ntitle: Java虚拟机\ndate: 2019-03-21 00:17\nupdated: 2019-03-21 00:17\ntags: Java\n---\n# 一、概念\n\n虚拟机：指以软件的方式模拟具有完整硬件系统功能、运行在一个完全隔离环境中的完整计算机系统 ，是物理机的软件实现。常用的虚拟机有VMWare，Visual Box，Java Virtual Machine（Java虚拟机，简称JVM）。\n\n<!-- more -->\n\nJava虚拟机阵营：Sun HotSpot VM、BEA JRockit VM、IBM J9 VM、Azul VM、Apache Harmony、Google Dalvik VM、Microsoft JVM…\n\n# 二、启动流程\n\n{% asset_img 640.webp 启动流程 %}\n\n# 三、基本架构\n\n{% asset_img 2.webp %}\nJava运行时编译源码(.java)成字节码，由jre运行。jre由java虚拟机（jvm）实现。Jvm分析字节码，后解释并执行。\n\n{% asset_img 3.webp %}\nJVM由三个主要的子系统构成：\n1. 类加载器子系统\n2. 运行时数据区（内存）\n3. 执行引擎\n\n# 四、类加载器子系统\n\n{% asset_img 4.webp %}\n类装载包括了加载，连接（验证、准备、解析（可选）），初始化。其中类加载工作由 ClassLoader 及其子类负责。\n\n- 加载：在硬盘上查找并通过IO读入字节码文件\n- 连接：执行校验、准备、解析（可选）步骤\n- 校验：校验字节码文件的正确性\n- 准备：给类的静态变量分配内存，并赋予默认值\n- 解析：将符号引用转为直接引用，类装载器装入类所引用的其他所有类\n{% asset_img 5.webp %}\n- 初始化：对类的静态变量初始化为指定的值，执行静态代码块\n\n# 五、类加载器体系结构\n\n{% asset_img 6.webp %}\n1．启动类加载器：负责加载JRE的核心类库，如jre目标下的rt.jar,charsets.jar等\n2．扩展类加载器：负责加载JRE扩展目录ext中JAR类包\n3．系统类加载器：负责加载ClassPath路径下的类包\n4．用户自定义加载器：负责加载用户自定义路径下的类包\n\n\n# 六、类加载机制（双亲委派）\n\n全盘负责委托机制。全盘负责，当一个ClassLoader加载一个类时，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个ClassLoader载入。\n委托机制：指先委托父类加载器寻找目标类，在找不到的情况下采用自己的路径中查找并载入目标类。\n\n# 七、运行时数据区\n\n{% asset_img 7.webp %}\n\n# 八、堆（Java堆）\n\n虚拟机启动时创建，用于存放对象实例，几乎所有的对象（包含常量池）都在堆上分配内存，当对象无法再该空间申请到内存时将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。可通过 -Xmx –Xms 参数来分别指定最大堆和最小堆。线程共享。\n{% asset_img 8.webp %}\n\n# 九、栈（Java栈）\n\n是java方法执行的内存模型，为虚拟机执行java方法，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）。线程独占。\n{% asset_img 9.webp %}\nJvm对该区域规范了两种异常：\n1. 线程请求的栈深度大于虚拟机栈所允许的深度，将抛出StackOverFlowError异常。\n2. 若虚拟机栈可动态扩展，当无法申请到足够内存空间时将抛出OutOfMemoryError。通过jvm参数–Xss指定栈空间，空间大小决定函数调用的深度。\n\n# 十、本地方法栈\n\n为虚拟机执行native方法，其他规范与java栈类似。不同类型的虚拟机对该区域可自由实现。线程独占。\n\n# 十一、PC寄存器（程序计数器）\n\n用来存储待执行指令的地址。分支，循环，跳转，异常处理，线程恢复等功能都需要依赖pc寄存器。线程独占。\n若线程执行的是一个java方法，则pc寄存器中保存的是待执行指令的地址。若执行的是一个native方法，则pc寄存器中为空。\n\n# 十二、元数据区\n\n元数据区取代了永久代，本质和永久代类似，都是对JVM规范中方法区的实现，区别在于元数据区并不在虚拟机中，而是使用本地内存。元数据区在频繁使用，也会发生OutOfMemory异常。\n\n元数据区的动态扩展，默认–XX:MetaspaceSize值为21MB的高水位线。一旦触及则Full GC将被触发并卸载没有用的类（类对应的类加载器不再存活），然后高水位线将会重置。新的高水位线的值取决于GC后释放的元空间。如果释放的空间少，这个高水位线则上升。如果释放空间过多，则高水位线下降。\n{% asset_img 10.webp %}\n\n# 十三、执行引擎\n\n{% asset_img 11.webp %}\n\n执行引擎读取运行时数据区的字节码并逐个执行\n\n1. 解释器：解释器更快地解释字节码,但执行缓慢,解释一句执行一句。\n2. JIT编译器：JIT编译器消除了解释器的缺点。执行引擎通过解释器转换字节码，当它发现重复的代码时，将使用JIT编译器，它编译整个字节码并将其更改为本地代码。这个本地代码将直接用于重复的方法调用，这提高了系统的性能。\n> JIT的构成组件为：\n中间代码生成器（Intermediate Code Generator）：生成中间代码 。\n代码优化器（Code Optimizer）：负责优化上面生成的中间代码 。\n目标代码生成器（Target Code Generator）：负责生成机器代码或本地代码 。\n分析器（Profiler）：一个特殊组件，负责查找热点（被多次调用的方法）\n3. 垃圾收集器：收集和删除未引用的对象。程序可调用System.gc()触发垃圾收集，但不能保证执行。\n4. 本地方法接口（JNI）：JNI将与本机方法库进行交互，并提供执行引擎所需的本机库。\n5. 本地方法库：执行引擎所需的本机库的集合。\n\n# 十四、垃圾收集（GC：Garbage Collection）\n- 如何识别垃圾，判定对象是否可被回收？\n\n引用计数法：给每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。用对象计数器是否为0来判断对象是否可被回收。缺点：无法解决循环引用的问题。\n\n根搜索算法：也称可达性分析法，通过“GC ROOTs”的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收（可作为GC ROOTs的对象：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象）。\n\n- Java 中的堆是 GC 收集垃圾的主要区域，GC 分为两种：Minor GC、Full GC( 或称为 Major GC)。\n\nMinor GC：新生代（Young Gen）空间不足时触发收集，由于Java 中的大部分对象通常不需长久存活，新生代是GC收集频繁区域，所以采用复制算法。\n\nFull GC：老年代（Old Gen）空间不足或元空间达到高水位线执行收集动作，由于存放大对象及长久存活下的对象，占用内存空间大，回收效率低，所以采用标记-清除算法。\n\n# 十五、GC算法\n\n## 按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。\n\n1.标记-清除算法：分为两阶段“标记”和“清除”。首先标记出哪些对象可被回收，在标记完成之后统一回收所有被标记的对象所占用的内存空间。不足之处：1.无法处理循环引用的问题2.效率不高3.产生大量内存碎片（ps：空间碎片太多可能会导致以后在分配大对象的时候而无法申请到足够的连续内存空间，导致提前触发新一轮gc）\n{% asset_img 12.webp %}\n\n2.标记-整理算法：分为两阶段“标记”和“整理”。首先标记出哪些对象可被回收，在标记完成后，将对象向一端移动，然后直接清理掉边界以外的内存。\n{% asset_img 13.webp %}\n\n3.复制算法：把内存空间划为两个相等的区域，每次只使用其中一个区域。gc时遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。不足之处：1.内存利用率问题2.在对象存活率较高时，其效率会变低。\n{% asset_img 14.webp %}\n\n## 按分区对待可分为：增量收集算法，分代收集算法\n\n1.增量收集:实时垃圾回收算法，即：在应用进行的同时进行垃圾回收，理论上可以解决传统分代方式带来的问题。增量收集把对堆空间划分成一系列内存块，使用时先使用其中一部分，垃圾收集时把之前用掉的部分中的存活对象再放到后面没有用的空间中，这样可以实现一直边使用边收集的效果，避免了传统分代方式整个使用完了再暂停的回收的情况。\n\n2.分代收集:（商用默认）基于对象生命周期划分为新生代、老年代、元空间，对不同生命周期的对象使用不同的算法进行回收。\n{% asset_img 15.webp %}\n\n## 按系统线程可分为：串行收集算法，并行收集算法，并发收集算法\n\n1. 串行收集:使用单线程处理垃圾回收工作，实现容易，效率较高。不足之处：1.无法发挥多处理器的优势 2.需要暂停用户线程\n2. 并行收集:使用多线程处理垃圾回收工作，速度快，效率高。理论上CPU数目越多，越能体现出并行收集器的优势。不足之处：需要暂停用户线程\n3. 并发收集:垃圾线程与用户线程同时工作。系统在垃圾回收时不需要暂停用户线程\n\n# 十六、GC收集器\n垃圾收集算法是内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。\n\n1.Serial 收集器主要针对新生代的收集，是最基本最古老的收集器，它是单线程收集器，工作时必须暂停所有用户线程。该收集器采用复制算法。           \nSerial Old收集器主要针对老年代收集，采用标记-整理算法，实现简单高效，但会停顿。\n{% asset_img 16.webp %}\n\n2.ParNew收集器是Serial的多线程版本，针对新生代采用复制算法使用多线程进行垃圾收集（并行收集器，响应优先）。\n\n3.Parallel Scavenge采用复制算法针对新生代的多线程收集器（并行收集器，吞吐优先）。可控制吞吐量和停顿时间，即吞吐量 = 运行用户代码时间 / (运行用户代码时间+垃圾收集时间)。\nParallel Old收集器是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和标记-整理算法。\n{% asset_img 17.webp %}\n\n4.CMS（Current MarkSweep）收集器针对老年代，是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是标记-清除算法。\n{% asset_img 19.webp %}\n\n5.G1的新生代类似于ParNew，采用复制算法算法，当新生代占用达到一定比例的时候，开始收集。老年代类似于CMS，不同点是采用标记-整理算法。\nG1因此它是一款并行与并发收集器，能充分利用多CPU、多核环境。并且它能建立可预测的停顿时间模型。\n\n{% asset_img 20.webp %}\n{% asset_img 21.webp %}\n与CMS收集器相比G1收集器有以下特点：\n\n1. 空间整合，G1收集器采用标记-整理算法，不会产生内存空间碎片。分配大对象（直接进Humongous区，专门存放短期巨型对象，不用直接进老年代，避免Full GC的大量开销）不会因为无法找到连续空间而提前触发下一次GC。（年青代拷贝、老年代转移对象无空闲分区、巨型对象无连续分区时触发Full GC，开销极大应该避免）\n2. 可预测停顿，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间内，消耗在垃圾收集上的时间不得超过N毫秒，几乎达到Java实时系统（RTSJ）级的垃圾收集器。\n3. G1将Java堆划分为多个大小相等的独立区域（Region），虽保留新生代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。\n\n# 十七、收集器常用组合\n{% asset_img 22.webp %}\n{% asset_img 23.webp %}\n\n# 十八、JVM性能调优思路\n{% asset_img 24.webp %}\n\n# 十九、理解GC日志\n{% asset_img 24.webp %}\n\n```\n[GC [PSYoungGen: 8192K->1000K(9216K)] 16004K->14604K(29696K), 0.0317424 secs] [Times: user=0.06 sys=0.00, real=0.03 secs]\n\n[GC [PSYoungGen: 9192K->1016K(9216K)] 22796K->20780K(29696K), 0.0314567 secs] [Times: user=0.06 sys=0.00, real=0.03 secs]\n\n[Full GC [PSYoungGen: 8192K->8192K(9216K)] [ParOldGen: 20435K->20435K(20480K)] 28627K->28627K(29696K), [Metaspace: 8469K->8469K(1056768K)], 0.1307495 secs] [Times: user=0.50 sys=0.00, real=0.13 secs]\n\n[Full GC [PSYoungGen: 8192K->8192K(9216K)] [ParOldGen: 20437K->20437K(20480K)] 28629K->28629K(29696K), [Metaspace: 8469K->8469K(1056768K)], 0.1240311 secs] [Times: user=0.42 sys=0.00, real=0.12 secs]\n```\n# 二十、常见异常\n```\nStackOverflowError:（栈溢出）\n\nOutOfMemoryError: Java heap space（堆空间不足）\n\nOutOfMemoryError: GC overhead limit exceeded  （GC花费的时间超过 98%, 并且GC回收的内存少于 2%）\n```\n# 二十一、GC参数\n```\n堆栈设置\n\n-Xss:每个线程的栈大小\n\n-Xms:初始堆大小，默认物理内存的1/64\n\n-Xmx:最大堆大小，默认物理内存的1/4\n\n-Xmn:新生代大小\n\n-XX:NewSize:设置新生代初始大小\n\n-XX:NewRatio:默认2表示新生代占年老代的1/2，占整个堆内存的1/3。\n\n-XX:SurvivorRatio:默认8表示一个survivor区占用1/8的Eden内存，即1/10的新生代内存。\n\n-XX:MaxMetaspaceSize:设置元空间最大允许大小，默认不受限制，JVM Metaspace会进行动态扩展。\n\n垃圾回收统计信息\n\n-XX:+PrintGC\n\n-XX:+PrintGCDetails\n\n-XX:+PrintGCTimeStamps\n\n-Xloggc:filename\n\n收集器设置\n\n-XX:+UseSerialGC:设置串行收集器\n\n-XX:+UseParallelGC:设置并行收集器\n\n-XX:+UseParallelOldGC:老年代使用并行回收收集器\n\n-XX:+UseParNewGC:在新生代使用并行收集器\n\n-XX:+UseParalledlOldGC:设置并行老年代收集器\n\n-XX:+UseConcMarkSweepGC:设置CMS并发收集器\n\n-XX:+UseG1GC:设置G1收集器\n\n-XX:ParallelGCThreads:设置用于垃圾回收的线程数\n\n并行收集器设置\n\n-XX:ParallelGCThreads:设置并行收集器收集时使用的CPU数。并行收集线程数。\n\n-XX:MaxGCPauseMillis:设置并行收集最大暂停时间\n\n-XX:GCTimeRatio:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)\n\nCMS收集器设置\n\n-XX:+UseConcMarkSweepGC:设置CMS并发收集器\n\n-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。\n\n-XX:ParallelGCThreads:设置并发收集器新生代收集方式为并行收集时，使用的CPU数。并行收集线程数。\n\n-XX:CMSFullGCsBeforeCompaction:设定进行多少次CMS垃圾回收后，进行一次内存压缩\n\n-XX:+CMSClassUnloadingEnabled:允许对类元数据进行回收\n\n-XX:UseCMSInitiatingOccupancyOnly:表示只在到达阀值的时候，才进行CMS回收\n\n-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况\n\n-XX:ParallelCMSThreads:设定CMS的线程数量\n\n-XX:CMSInitiatingOccupancyFraction:设置CMS收集器在老年代空间被使用多少后触发\n\n-XX:+UseCMSCompactAtFullCollection:设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理\n\nG1收集器设置\n\n-XX:+UseG1GC:使用G1收集器\n\n-XX:ParallelGCThreads:指定GC工作的线程数量\n\n-XX:G1HeapRegionSize:指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区\n\n-XX:GCTimeRatio:吞吐量大小，0-100的整数(默认9)，值为n则系统将花费不超过1/(1+n)的时间用于垃圾收集\n\n-XX:MaxGCPauseMillis:目标暂停时间(默认200ms)\n\n-XX:G1NewSizePercent:新生代内存初始空间(默认整堆5%)\n\n-XX:G1MaxNewSizePercent:新生代内存最大空间\n\n-XX:TargetSurvivorRatio:Survivor填充容量(默认50%)\n\n-XX:MaxTenuringThreshold:最大任期阈值(默认15)\n\n-XX:InitiatingHeapOccupancyPercen:老年代占用空间超过整堆比IHOP阈值(默认45%),超过则执行混合收集\n\n-XX:G1HeapWastePercent:堆废物百分比(默认5%)\n\n-XX:G1MixedGCCountTarget:参数混合周期的最大总次数(默认8)\n```\n\n# 二十二、性能分析和监控工具\n\n- Jps：虚拟机进程状况工具\n- Jstat：虚拟机统计信息监视工具\n- Jinfo：虚拟机配置信息工具\n- Jmap：内存映像工具\n- Jhat：虚拟机堆转储快照分析工具\n- Jstack：堆栈跟踪工具\n- JConsole：java监视与管理控制台\n- VisualVM：故障处理工具\n\n> Learned from 鲁班学院","slug":"2019-Java虚拟机","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrl800382yku0hrwa13k","content":"<h1 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h1><p>虚拟机：指以软件的方式模拟具有完整硬件系统功能、运行在一个完全隔离环境中的完整计算机系统 ，是物理机的软件实现。常用的虚拟机有VMWare，Visual Box，Java Virtual Machine（Java虚拟机，简称JVM）。</p>\n<a id=\"more\"></a>\n\n<p>Java虚拟机阵营：Sun HotSpot VM、BEA JRockit VM、IBM J9 VM、Azul VM、Apache Harmony、Google Dalvik VM、Microsoft JVM…</p>\n<h1 id=\"二、启动流程\"><a href=\"#二、启动流程\" class=\"headerlink\" title=\"二、启动流程\"></a>二、启动流程</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/640.webp\" class=\"\" title=\"启动流程\">\n\n<h1 id=\"三、基本架构\"><a href=\"#三、基本架构\" class=\"headerlink\" title=\"三、基本架构\"></a>三、基本架构</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.webp\" class=\"\">\n<p>Java运行时编译源码(.java)成字节码，由jre运行。jre由java虚拟机（jvm）实现。Jvm分析字节码，后解释并执行。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/3.webp\" class=\"\">\n<p>JVM由三个主要的子系统构成：</p>\n<ol>\n<li>类加载器子系统</li>\n<li>运行时数据区（内存）</li>\n<li>执行引擎</li>\n</ol>\n<h1 id=\"四、类加载器子系统\"><a href=\"#四、类加载器子系统\" class=\"headerlink\" title=\"四、类加载器子系统\"></a>四、类加载器子系统</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/4.webp\" class=\"\">\n<p>类装载包括了加载，连接（验证、准备、解析（可选）），初始化。其中类加载工作由 ClassLoader 及其子类负责。</p>\n<ul>\n<li>加载：在硬盘上查找并通过IO读入字节码文件</li>\n<li>连接：执行校验、准备、解析（可选）步骤</li>\n<li>校验：校验字节码文件的正确性</li>\n<li>准备：给类的静态变量分配内存，并赋予默认值</li>\n<li>解析：将符号引用转为直接引用，类装载器装入类所引用的其他所有类<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/5.webp\" class=\"\"></li>\n<li>初始化：对类的静态变量初始化为指定的值，执行静态代码块</li>\n</ul>\n<h1 id=\"五、类加载器体系结构\"><a href=\"#五、类加载器体系结构\" class=\"headerlink\" title=\"五、类加载器体系结构\"></a>五、类加载器体系结构</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/6.webp\" class=\"\">\n<p>1．启动类加载器：负责加载JRE的核心类库，如jre目标下的rt.jar,charsets.jar等<br>2．扩展类加载器：负责加载JRE扩展目录ext中JAR类包<br>3．系统类加载器：负责加载ClassPath路径下的类包<br>4．用户自定义加载器：负责加载用户自定义路径下的类包</p>\n<h1 id=\"六、类加载机制（双亲委派）\"><a href=\"#六、类加载机制（双亲委派）\" class=\"headerlink\" title=\"六、类加载机制（双亲委派）\"></a>六、类加载机制（双亲委派）</h1><p>全盘负责委托机制。全盘负责，当一个ClassLoader加载一个类时，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个ClassLoader载入。<br>委托机制：指先委托父类加载器寻找目标类，在找不到的情况下采用自己的路径中查找并载入目标类。</p>\n<h1 id=\"七、运行时数据区\"><a href=\"#七、运行时数据区\" class=\"headerlink\" title=\"七、运行时数据区\"></a>七、运行时数据区</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/7.webp\" class=\"\">\n\n<h1 id=\"八、堆（Java堆）\"><a href=\"#八、堆（Java堆）\" class=\"headerlink\" title=\"八、堆（Java堆）\"></a>八、堆（Java堆）</h1><p>虚拟机启动时创建，用于存放对象实例，几乎所有的对象（包含常量池）都在堆上分配内存，当对象无法再该空间申请到内存时将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。可通过 -Xmx –Xms 参数来分别指定最大堆和最小堆。线程共享。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/8.webp\" class=\"\">\n\n<h1 id=\"九、栈（Java栈）\"><a href=\"#九、栈（Java栈）\" class=\"headerlink\" title=\"九、栈（Java栈）\"></a>九、栈（Java栈）</h1><p>是java方法执行的内存模型，为虚拟机执行java方法，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）。线程独占。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/9.webp\" class=\"\">\n<p>Jvm对该区域规范了两种异常：</p>\n<ol>\n<li>线程请求的栈深度大于虚拟机栈所允许的深度，将抛出StackOverFlowError异常。</li>\n<li>若虚拟机栈可动态扩展，当无法申请到足够内存空间时将抛出OutOfMemoryError。通过jvm参数–Xss指定栈空间，空间大小决定函数调用的深度。</li>\n</ol>\n<h1 id=\"十、本地方法栈\"><a href=\"#十、本地方法栈\" class=\"headerlink\" title=\"十、本地方法栈\"></a>十、本地方法栈</h1><p>为虚拟机执行native方法，其他规范与java栈类似。不同类型的虚拟机对该区域可自由实现。线程独占。</p>\n<h1 id=\"十一、PC寄存器（程序计数器）\"><a href=\"#十一、PC寄存器（程序计数器）\" class=\"headerlink\" title=\"十一、PC寄存器（程序计数器）\"></a>十一、PC寄存器（程序计数器）</h1><p>用来存储待执行指令的地址。分支，循环，跳转，异常处理，线程恢复等功能都需要依赖pc寄存器。线程独占。<br>若线程执行的是一个java方法，则pc寄存器中保存的是待执行指令的地址。若执行的是一个native方法，则pc寄存器中为空。</p>\n<h1 id=\"十二、元数据区\"><a href=\"#十二、元数据区\" class=\"headerlink\" title=\"十二、元数据区\"></a>十二、元数据区</h1><p>元数据区取代了永久代，本质和永久代类似，都是对JVM规范中方法区的实现，区别在于元数据区并不在虚拟机中，而是使用本地内存。元数据区在频繁使用，也会发生OutOfMemory异常。</p>\n<p>元数据区的动态扩展，默认–XX:MetaspaceSize值为21MB的高水位线。一旦触及则Full GC将被触发并卸载没有用的类（类对应的类加载器不再存活），然后高水位线将会重置。新的高水位线的值取决于GC后释放的元空间。如果释放的空间少，这个高水位线则上升。如果释放空间过多，则高水位线下降。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/10.webp\" class=\"\">\n\n<h1 id=\"十三、执行引擎\"><a href=\"#十三、执行引擎\" class=\"headerlink\" title=\"十三、执行引擎\"></a>十三、执行引擎</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/11.webp\" class=\"\">\n\n<p>执行引擎读取运行时数据区的字节码并逐个执行</p>\n<ol>\n<li>解释器：解释器更快地解释字节码,但执行缓慢,解释一句执行一句。</li>\n<li>JIT编译器：JIT编译器消除了解释器的缺点。执行引擎通过解释器转换字节码，当它发现重复的代码时，将使用JIT编译器，它编译整个字节码并将其更改为本地代码。这个本地代码将直接用于重复的方法调用，这提高了系统的性能。<blockquote>\n<p>JIT的构成组件为：<br>中间代码生成器（Intermediate Code Generator）：生成中间代码 。<br>代码优化器（Code Optimizer）：负责优化上面生成的中间代码 。<br>目标代码生成器（Target Code Generator）：负责生成机器代码或本地代码 。<br>分析器（Profiler）：一个特殊组件，负责查找热点（被多次调用的方法）</p>\n</blockquote>\n</li>\n<li>垃圾收集器：收集和删除未引用的对象。程序可调用System.gc()触发垃圾收集，但不能保证执行。</li>\n<li>本地方法接口（JNI）：JNI将与本机方法库进行交互，并提供执行引擎所需的本机库。</li>\n<li>本地方法库：执行引擎所需的本机库的集合。</li>\n</ol>\n<h1 id=\"十四、垃圾收集（GC：Garbage-Collection）\"><a href=\"#十四、垃圾收集（GC：Garbage-Collection）\" class=\"headerlink\" title=\"十四、垃圾收集（GC：Garbage Collection）\"></a>十四、垃圾收集（GC：Garbage Collection）</h1><ul>\n<li>如何识别垃圾，判定对象是否可被回收？</li>\n</ul>\n<p>引用计数法：给每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。用对象计数器是否为0来判断对象是否可被回收。缺点：无法解决循环引用的问题。</p>\n<p>根搜索算法：也称可达性分析法，通过“GC ROOTs”的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收（可作为GC ROOTs的对象：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象）。</p>\n<ul>\n<li>Java 中的堆是 GC 收集垃圾的主要区域，GC 分为两种：Minor GC、Full GC( 或称为 Major GC)。</li>\n</ul>\n<p>Minor GC：新生代（Young Gen）空间不足时触发收集，由于Java 中的大部分对象通常不需长久存活，新生代是GC收集频繁区域，所以采用复制算法。</p>\n<p>Full GC：老年代（Old Gen）空间不足或元空间达到高水位线执行收集动作，由于存放大对象及长久存活下的对象，占用内存空间大，回收效率低，所以采用标记-清除算法。</p>\n<h1 id=\"十五、GC算法\"><a href=\"#十五、GC算法\" class=\"headerlink\" title=\"十五、GC算法\"></a>十五、GC算法</h1><h2 id=\"按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。\"><a href=\"#按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。\" class=\"headerlink\" title=\"按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。\"></a>按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。</h2><p>1.标记-清除算法：分为两阶段“标记”和“清除”。首先标记出哪些对象可被回收，在标记完成之后统一回收所有被标记的对象所占用的内存空间。不足之处：1.无法处理循环引用的问题2.效率不高3.产生大量内存碎片（ps：空间碎片太多可能会导致以后在分配大对象的时候而无法申请到足够的连续内存空间，导致提前触发新一轮gc）</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/12.webp\" class=\"\">\n\n<p>2.标记-整理算法：分为两阶段“标记”和“整理”。首先标记出哪些对象可被回收，在标记完成后，将对象向一端移动，然后直接清理掉边界以外的内存。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/13.webp\" class=\"\">\n\n<p>3.复制算法：把内存空间划为两个相等的区域，每次只使用其中一个区域。gc时遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。不足之处：1.内存利用率问题2.在对象存活率较高时，其效率会变低。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/14.webp\" class=\"\">\n\n<h2 id=\"按分区对待可分为：增量收集算法，分代收集算法\"><a href=\"#按分区对待可分为：增量收集算法，分代收集算法\" class=\"headerlink\" title=\"按分区对待可分为：增量收集算法，分代收集算法\"></a>按分区对待可分为：增量收集算法，分代收集算法</h2><p>1.增量收集:实时垃圾回收算法，即：在应用进行的同时进行垃圾回收，理论上可以解决传统分代方式带来的问题。增量收集把对堆空间划分成一系列内存块，使用时先使用其中一部分，垃圾收集时把之前用掉的部分中的存活对象再放到后面没有用的空间中，这样可以实现一直边使用边收集的效果，避免了传统分代方式整个使用完了再暂停的回收的情况。</p>\n<p>2.分代收集:（商用默认）基于对象生命周期划分为新生代、老年代、元空间，对不同生命周期的对象使用不同的算法进行回收。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/15.webp\" class=\"\">\n\n<h2 id=\"按系统线程可分为：串行收集算法，并行收集算法，并发收集算法\"><a href=\"#按系统线程可分为：串行收集算法，并行收集算法，并发收集算法\" class=\"headerlink\" title=\"按系统线程可分为：串行收集算法，并行收集算法，并发收集算法\"></a>按系统线程可分为：串行收集算法，并行收集算法，并发收集算法</h2><ol>\n<li>串行收集:使用单线程处理垃圾回收工作，实现容易，效率较高。不足之处：1.无法发挥多处理器的优势 2.需要暂停用户线程</li>\n<li>并行收集:使用多线程处理垃圾回收工作，速度快，效率高。理论上CPU数目越多，越能体现出并行收集器的优势。不足之处：需要暂停用户线程</li>\n<li>并发收集:垃圾线程与用户线程同时工作。系统在垃圾回收时不需要暂停用户线程</li>\n</ol>\n<h1 id=\"十六、GC收集器\"><a href=\"#十六、GC收集器\" class=\"headerlink\" title=\"十六、GC收集器\"></a>十六、GC收集器</h1><p>垃圾收集算法是内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。</p>\n<p>1.Serial 收集器主要针对新生代的收集，是最基本最古老的收集器，它是单线程收集器，工作时必须暂停所有用户线程。该收集器采用复制算法。<br>Serial Old收集器主要针对老年代收集，采用标记-整理算法，实现简单高效，但会停顿。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/16.webp\" class=\"\">\n\n<p>2.ParNew收集器是Serial的多线程版本，针对新生代采用复制算法使用多线程进行垃圾收集（并行收集器，响应优先）。</p>\n<p>3.Parallel Scavenge采用复制算法针对新生代的多线程收集器（并行收集器，吞吐优先）。可控制吞吐量和停顿时间，即吞吐量 = 运行用户代码时间 / (运行用户代码时间+垃圾收集时间)。<br>Parallel Old收集器是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和标记-整理算法。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/17.webp\" class=\"\">\n\n<p>4.CMS（Current MarkSweep）收集器针对老年代，是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是标记-清除算法。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/19.webp\" class=\"\">\n\n<p>5.G1的新生代类似于ParNew，采用复制算法算法，当新生代占用达到一定比例的时候，开始收集。老年代类似于CMS，不同点是采用标记-整理算法。<br>G1因此它是一款并行与并发收集器，能充分利用多CPU、多核环境。并且它能建立可预测的停顿时间模型。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/20.webp\" class=\"\">\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/21.webp\" class=\"\">\n<p>与CMS收集器相比G1收集器有以下特点：</p>\n<ol>\n<li>空间整合，G1收集器采用标记-整理算法，不会产生内存空间碎片。分配大对象（直接进Humongous区，专门存放短期巨型对象，不用直接进老年代，避免Full GC的大量开销）不会因为无法找到连续空间而提前触发下一次GC。（年青代拷贝、老年代转移对象无空闲分区、巨型对象无连续分区时触发Full GC，开销极大应该避免）</li>\n<li>可预测停顿，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间内，消耗在垃圾收集上的时间不得超过N毫秒，几乎达到Java实时系统（RTSJ）级的垃圾收集器。</li>\n<li>G1将Java堆划分为多个大小相等的独立区域（Region），虽保留新生代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。</li>\n</ol>\n<h1 id=\"十七、收集器常用组合\"><a href=\"#十七、收集器常用组合\" class=\"headerlink\" title=\"十七、收集器常用组合\"></a>十七、收集器常用组合</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/22.webp\" class=\"\">\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/23.webp\" class=\"\">\n\n<h1 id=\"十八、JVM性能调优思路\"><a href=\"#十八、JVM性能调优思路\" class=\"headerlink\" title=\"十八、JVM性能调优思路\"></a>十八、JVM性能调优思路</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/24.webp\" class=\"\">\n\n<h1 id=\"十九、理解GC日志\"><a href=\"#十九、理解GC日志\" class=\"headerlink\" title=\"十九、理解GC日志\"></a>十九、理解GC日志</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/24.webp\" class=\"\">\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC [PSYoungGen: 8192K-&gt;1000K(9216K)] 16004K-&gt;14604K(29696K), 0.0317424 secs] [Times: user&#x3D;0.06 sys&#x3D;0.00, real&#x3D;0.03 secs]</span><br><span class=\"line\"></span><br><span class=\"line\">[GC [PSYoungGen: 9192K-&gt;1016K(9216K)] 22796K-&gt;20780K(29696K), 0.0314567 secs] [Times: user&#x3D;0.06 sys&#x3D;0.00, real&#x3D;0.03 secs]</span><br><span class=\"line\"></span><br><span class=\"line\">[Full GC [PSYoungGen: 8192K-&gt;8192K(9216K)] [ParOldGen: 20435K-&gt;20435K(20480K)] 28627K-&gt;28627K(29696K), [Metaspace: 8469K-&gt;8469K(1056768K)], 0.1307495 secs] [Times: user&#x3D;0.50 sys&#x3D;0.00, real&#x3D;0.13 secs]</span><br><span class=\"line\"></span><br><span class=\"line\">[Full GC [PSYoungGen: 8192K-&gt;8192K(9216K)] [ParOldGen: 20437K-&gt;20437K(20480K)] 28629K-&gt;28629K(29696K), [Metaspace: 8469K-&gt;8469K(1056768K)], 0.1240311 secs] [Times: user&#x3D;0.42 sys&#x3D;0.00, real&#x3D;0.12 secs]</span><br></pre></td></tr></table></figure>\n<h1 id=\"二十、常见异常\"><a href=\"#二十、常见异常\" class=\"headerlink\" title=\"二十、常见异常\"></a>二十、常见异常</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StackOverflowError:（栈溢出）</span><br><span class=\"line\"></span><br><span class=\"line\">OutOfMemoryError: Java heap space（堆空间不足）</span><br><span class=\"line\"></span><br><span class=\"line\">OutOfMemoryError: GC overhead limit exceeded  （GC花费的时间超过 98%, 并且GC回收的内存少于 2%）</span><br></pre></td></tr></table></figure>\n<h1 id=\"二十一、GC参数\"><a href=\"#二十一、GC参数\" class=\"headerlink\" title=\"二十一、GC参数\"></a>二十一、GC参数</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">堆栈设置</span><br><span class=\"line\"></span><br><span class=\"line\">-Xss:每个线程的栈大小</span><br><span class=\"line\"></span><br><span class=\"line\">-Xms:初始堆大小，默认物理内存的1&#x2F;64</span><br><span class=\"line\"></span><br><span class=\"line\">-Xmx:最大堆大小，默认物理内存的1&#x2F;4</span><br><span class=\"line\"></span><br><span class=\"line\">-Xmn:新生代大小</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:NewSize:设置新生代初始大小</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:NewRatio:默认2表示新生代占年老代的1&#x2F;2，占整个堆内存的1&#x2F;3。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:SurvivorRatio:默认8表示一个survivor区占用1&#x2F;8的Eden内存，即1&#x2F;10的新生代内存。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MaxMetaspaceSize:设置元空间最大允许大小，默认不受限制，JVM Metaspace会进行动态扩展。</span><br><span class=\"line\"></span><br><span class=\"line\">垃圾回收统计信息</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+PrintGC</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+PrintGCDetails</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+PrintGCTimeStamps</span><br><span class=\"line\"></span><br><span class=\"line\">-Xloggc:filename</span><br><span class=\"line\"></span><br><span class=\"line\">收集器设置</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseSerialGC:设置串行收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseParallelGC:设置并行收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseParallelOldGC:老年代使用并行回收收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseParNewGC:在新生代使用并行收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseParalledlOldGC:设置并行老年代收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseConcMarkSweepGC:设置CMS并发收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseG1GC:设置G1收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:ParallelGCThreads:设置用于垃圾回收的线程数</span><br><span class=\"line\"></span><br><span class=\"line\">并行收集器设置</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:ParallelGCThreads:设置并行收集器收集时使用的CPU数。并行收集线程数。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MaxGCPauseMillis:设置并行收集最大暂停时间</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:GCTimeRatio:设置垃圾回收时间占程序运行时间的百分比。公式为1&#x2F;(1+n)</span><br><span class=\"line\"></span><br><span class=\"line\">CMS收集器设置</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseConcMarkSweepGC:设置CMS并发收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:ParallelGCThreads:设置并发收集器新生代收集方式为并行收集时，使用的CPU数。并行收集线程数。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:CMSFullGCsBeforeCompaction:设定进行多少次CMS垃圾回收后，进行一次内存压缩</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+CMSClassUnloadingEnabled:允许对类元数据进行回收</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:UseCMSInitiatingOccupancyOnly:表示只在到达阀值的时候，才进行CMS回收</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:ParallelCMSThreads:设定CMS的线程数量</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:CMSInitiatingOccupancyFraction:设置CMS收集器在老年代空间被使用多少后触发</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseCMSCompactAtFullCollection:设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理</span><br><span class=\"line\"></span><br><span class=\"line\">G1收集器设置</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseG1GC:使用G1收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:ParallelGCThreads:指定GC工作的线程数量</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:G1HeapRegionSize:指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:GCTimeRatio:吞吐量大小，0-100的整数(默认9)，值为n则系统将花费不超过1&#x2F;(1+n)的时间用于垃圾收集</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MaxGCPauseMillis:目标暂停时间(默认200ms)</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:G1NewSizePercent:新生代内存初始空间(默认整堆5%)</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:G1MaxNewSizePercent:新生代内存最大空间</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:TargetSurvivorRatio:Survivor填充容量(默认50%)</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MaxTenuringThreshold:最大任期阈值(默认15)</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:InitiatingHeapOccupancyPercen:老年代占用空间超过整堆比IHOP阈值(默认45%),超过则执行混合收集</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:G1HeapWastePercent:堆废物百分比(默认5%)</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:G1MixedGCCountTarget:参数混合周期的最大总次数(默认8)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二十二、性能分析和监控工具\"><a href=\"#二十二、性能分析和监控工具\" class=\"headerlink\" title=\"二十二、性能分析和监控工具\"></a>二十二、性能分析和监控工具</h1><ul>\n<li>Jps：虚拟机进程状况工具</li>\n<li>Jstat：虚拟机统计信息监视工具</li>\n<li>Jinfo：虚拟机配置信息工具</li>\n<li>Jmap：内存映像工具</li>\n<li>Jhat：虚拟机堆转储快照分析工具</li>\n<li>Jstack：堆栈跟踪工具</li>\n<li>JConsole：java监视与管理控制台</li>\n<li>VisualVM：故障处理工具</li>\n</ul>\n<blockquote>\n<p>Learned from 鲁班学院</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h1><p>虚拟机：指以软件的方式模拟具有完整硬件系统功能、运行在一个完全隔离环境中的完整计算机系统 ，是物理机的软件实现。常用的虚拟机有VMWare，Visual Box，Java Virtual Machine（Java虚拟机，简称JVM）。</p>","more":"<p>Java虚拟机阵营：Sun HotSpot VM、BEA JRockit VM、IBM J9 VM、Azul VM、Apache Harmony、Google Dalvik VM、Microsoft JVM…</p>\n<h1 id=\"二、启动流程\"><a href=\"#二、启动流程\" class=\"headerlink\" title=\"二、启动流程\"></a>二、启动流程</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/640.webp\" class=\"\" title=\"启动流程\">\n\n<h1 id=\"三、基本架构\"><a href=\"#三、基本架构\" class=\"headerlink\" title=\"三、基本架构\"></a>三、基本架构</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.webp\" class=\"\">\n<p>Java运行时编译源码(.java)成字节码，由jre运行。jre由java虚拟机（jvm）实现。Jvm分析字节码，后解释并执行。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/3.webp\" class=\"\">\n<p>JVM由三个主要的子系统构成：</p>\n<ol>\n<li>类加载器子系统</li>\n<li>运行时数据区（内存）</li>\n<li>执行引擎</li>\n</ol>\n<h1 id=\"四、类加载器子系统\"><a href=\"#四、类加载器子系统\" class=\"headerlink\" title=\"四、类加载器子系统\"></a>四、类加载器子系统</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/4.webp\" class=\"\">\n<p>类装载包括了加载，连接（验证、准备、解析（可选）），初始化。其中类加载工作由 ClassLoader 及其子类负责。</p>\n<ul>\n<li>加载：在硬盘上查找并通过IO读入字节码文件</li>\n<li>连接：执行校验、准备、解析（可选）步骤</li>\n<li>校验：校验字节码文件的正确性</li>\n<li>准备：给类的静态变量分配内存，并赋予默认值</li>\n<li>解析：将符号引用转为直接引用，类装载器装入类所引用的其他所有类<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/5.webp\" class=\"\"></li>\n<li>初始化：对类的静态变量初始化为指定的值，执行静态代码块</li>\n</ul>\n<h1 id=\"五、类加载器体系结构\"><a href=\"#五、类加载器体系结构\" class=\"headerlink\" title=\"五、类加载器体系结构\"></a>五、类加载器体系结构</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/6.webp\" class=\"\">\n<p>1．启动类加载器：负责加载JRE的核心类库，如jre目标下的rt.jar,charsets.jar等<br>2．扩展类加载器：负责加载JRE扩展目录ext中JAR类包<br>3．系统类加载器：负责加载ClassPath路径下的类包<br>4．用户自定义加载器：负责加载用户自定义路径下的类包</p>\n<h1 id=\"六、类加载机制（双亲委派）\"><a href=\"#六、类加载机制（双亲委派）\" class=\"headerlink\" title=\"六、类加载机制（双亲委派）\"></a>六、类加载机制（双亲委派）</h1><p>全盘负责委托机制。全盘负责，当一个ClassLoader加载一个类时，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个ClassLoader载入。<br>委托机制：指先委托父类加载器寻找目标类，在找不到的情况下采用自己的路径中查找并载入目标类。</p>\n<h1 id=\"七、运行时数据区\"><a href=\"#七、运行时数据区\" class=\"headerlink\" title=\"七、运行时数据区\"></a>七、运行时数据区</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/7.webp\" class=\"\">\n\n<h1 id=\"八、堆（Java堆）\"><a href=\"#八、堆（Java堆）\" class=\"headerlink\" title=\"八、堆（Java堆）\"></a>八、堆（Java堆）</h1><p>虚拟机启动时创建，用于存放对象实例，几乎所有的对象（包含常量池）都在堆上分配内存，当对象无法再该空间申请到内存时将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。可通过 -Xmx –Xms 参数来分别指定最大堆和最小堆。线程共享。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/8.webp\" class=\"\">\n\n<h1 id=\"九、栈（Java栈）\"><a href=\"#九、栈（Java栈）\" class=\"headerlink\" title=\"九、栈（Java栈）\"></a>九、栈（Java栈）</h1><p>是java方法执行的内存模型，为虚拟机执行java方法，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）。线程独占。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/9.webp\" class=\"\">\n<p>Jvm对该区域规范了两种异常：</p>\n<ol>\n<li>线程请求的栈深度大于虚拟机栈所允许的深度，将抛出StackOverFlowError异常。</li>\n<li>若虚拟机栈可动态扩展，当无法申请到足够内存空间时将抛出OutOfMemoryError。通过jvm参数–Xss指定栈空间，空间大小决定函数调用的深度。</li>\n</ol>\n<h1 id=\"十、本地方法栈\"><a href=\"#十、本地方法栈\" class=\"headerlink\" title=\"十、本地方法栈\"></a>十、本地方法栈</h1><p>为虚拟机执行native方法，其他规范与java栈类似。不同类型的虚拟机对该区域可自由实现。线程独占。</p>\n<h1 id=\"十一、PC寄存器（程序计数器）\"><a href=\"#十一、PC寄存器（程序计数器）\" class=\"headerlink\" title=\"十一、PC寄存器（程序计数器）\"></a>十一、PC寄存器（程序计数器）</h1><p>用来存储待执行指令的地址。分支，循环，跳转，异常处理，线程恢复等功能都需要依赖pc寄存器。线程独占。<br>若线程执行的是一个java方法，则pc寄存器中保存的是待执行指令的地址。若执行的是一个native方法，则pc寄存器中为空。</p>\n<h1 id=\"十二、元数据区\"><a href=\"#十二、元数据区\" class=\"headerlink\" title=\"十二、元数据区\"></a>十二、元数据区</h1><p>元数据区取代了永久代，本质和永久代类似，都是对JVM规范中方法区的实现，区别在于元数据区并不在虚拟机中，而是使用本地内存。元数据区在频繁使用，也会发生OutOfMemory异常。</p>\n<p>元数据区的动态扩展，默认–XX:MetaspaceSize值为21MB的高水位线。一旦触及则Full GC将被触发并卸载没有用的类（类对应的类加载器不再存活），然后高水位线将会重置。新的高水位线的值取决于GC后释放的元空间。如果释放的空间少，这个高水位线则上升。如果释放空间过多，则高水位线下降。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/10.webp\" class=\"\">\n\n<h1 id=\"十三、执行引擎\"><a href=\"#十三、执行引擎\" class=\"headerlink\" title=\"十三、执行引擎\"></a>十三、执行引擎</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/11.webp\" class=\"\">\n\n<p>执行引擎读取运行时数据区的字节码并逐个执行</p>\n<ol>\n<li>解释器：解释器更快地解释字节码,但执行缓慢,解释一句执行一句。</li>\n<li>JIT编译器：JIT编译器消除了解释器的缺点。执行引擎通过解释器转换字节码，当它发现重复的代码时，将使用JIT编译器，它编译整个字节码并将其更改为本地代码。这个本地代码将直接用于重复的方法调用，这提高了系统的性能。<blockquote>\n<p>JIT的构成组件为：<br>中间代码生成器（Intermediate Code Generator）：生成中间代码 。<br>代码优化器（Code Optimizer）：负责优化上面生成的中间代码 。<br>目标代码生成器（Target Code Generator）：负责生成机器代码或本地代码 。<br>分析器（Profiler）：一个特殊组件，负责查找热点（被多次调用的方法）</p>\n</blockquote>\n</li>\n<li>垃圾收集器：收集和删除未引用的对象。程序可调用System.gc()触发垃圾收集，但不能保证执行。</li>\n<li>本地方法接口（JNI）：JNI将与本机方法库进行交互，并提供执行引擎所需的本机库。</li>\n<li>本地方法库：执行引擎所需的本机库的集合。</li>\n</ol>\n<h1 id=\"十四、垃圾收集（GC：Garbage-Collection）\"><a href=\"#十四、垃圾收集（GC：Garbage-Collection）\" class=\"headerlink\" title=\"十四、垃圾收集（GC：Garbage Collection）\"></a>十四、垃圾收集（GC：Garbage Collection）</h1><ul>\n<li>如何识别垃圾，判定对象是否可被回收？</li>\n</ul>\n<p>引用计数法：给每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。用对象计数器是否为0来判断对象是否可被回收。缺点：无法解决循环引用的问题。</p>\n<p>根搜索算法：也称可达性分析法，通过“GC ROOTs”的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收（可作为GC ROOTs的对象：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象）。</p>\n<ul>\n<li>Java 中的堆是 GC 收集垃圾的主要区域，GC 分为两种：Minor GC、Full GC( 或称为 Major GC)。</li>\n</ul>\n<p>Minor GC：新生代（Young Gen）空间不足时触发收集，由于Java 中的大部分对象通常不需长久存活，新生代是GC收集频繁区域，所以采用复制算法。</p>\n<p>Full GC：老年代（Old Gen）空间不足或元空间达到高水位线执行收集动作，由于存放大对象及长久存活下的对象，占用内存空间大，回收效率低，所以采用标记-清除算法。</p>\n<h1 id=\"十五、GC算法\"><a href=\"#十五、GC算法\" class=\"headerlink\" title=\"十五、GC算法\"></a>十五、GC算法</h1><h2 id=\"按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。\"><a href=\"#按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。\" class=\"headerlink\" title=\"按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。\"></a>按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。</h2><p>1.标记-清除算法：分为两阶段“标记”和“清除”。首先标记出哪些对象可被回收，在标记完成之后统一回收所有被标记的对象所占用的内存空间。不足之处：1.无法处理循环引用的问题2.效率不高3.产生大量内存碎片（ps：空间碎片太多可能会导致以后在分配大对象的时候而无法申请到足够的连续内存空间，导致提前触发新一轮gc）</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/12.webp\" class=\"\">\n\n<p>2.标记-整理算法：分为两阶段“标记”和“整理”。首先标记出哪些对象可被回收，在标记完成后，将对象向一端移动，然后直接清理掉边界以外的内存。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/13.webp\" class=\"\">\n\n<p>3.复制算法：把内存空间划为两个相等的区域，每次只使用其中一个区域。gc时遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。不足之处：1.内存利用率问题2.在对象存活率较高时，其效率会变低。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/14.webp\" class=\"\">\n\n<h2 id=\"按分区对待可分为：增量收集算法，分代收集算法\"><a href=\"#按分区对待可分为：增量收集算法，分代收集算法\" class=\"headerlink\" title=\"按分区对待可分为：增量收集算法，分代收集算法\"></a>按分区对待可分为：增量收集算法，分代收集算法</h2><p>1.增量收集:实时垃圾回收算法，即：在应用进行的同时进行垃圾回收，理论上可以解决传统分代方式带来的问题。增量收集把对堆空间划分成一系列内存块，使用时先使用其中一部分，垃圾收集时把之前用掉的部分中的存活对象再放到后面没有用的空间中，这样可以实现一直边使用边收集的效果，避免了传统分代方式整个使用完了再暂停的回收的情况。</p>\n<p>2.分代收集:（商用默认）基于对象生命周期划分为新生代、老年代、元空间，对不同生命周期的对象使用不同的算法进行回收。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/15.webp\" class=\"\">\n\n<h2 id=\"按系统线程可分为：串行收集算法，并行收集算法，并发收集算法\"><a href=\"#按系统线程可分为：串行收集算法，并行收集算法，并发收集算法\" class=\"headerlink\" title=\"按系统线程可分为：串行收集算法，并行收集算法，并发收集算法\"></a>按系统线程可分为：串行收集算法，并行收集算法，并发收集算法</h2><ol>\n<li>串行收集:使用单线程处理垃圾回收工作，实现容易，效率较高。不足之处：1.无法发挥多处理器的优势 2.需要暂停用户线程</li>\n<li>并行收集:使用多线程处理垃圾回收工作，速度快，效率高。理论上CPU数目越多，越能体现出并行收集器的优势。不足之处：需要暂停用户线程</li>\n<li>并发收集:垃圾线程与用户线程同时工作。系统在垃圾回收时不需要暂停用户线程</li>\n</ol>\n<h1 id=\"十六、GC收集器\"><a href=\"#十六、GC收集器\" class=\"headerlink\" title=\"十六、GC收集器\"></a>十六、GC收集器</h1><p>垃圾收集算法是内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。</p>\n<p>1.Serial 收集器主要针对新生代的收集，是最基本最古老的收集器，它是单线程收集器，工作时必须暂停所有用户线程。该收集器采用复制算法。<br>Serial Old收集器主要针对老年代收集，采用标记-整理算法，实现简单高效，但会停顿。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/16.webp\" class=\"\">\n\n<p>2.ParNew收集器是Serial的多线程版本，针对新生代采用复制算法使用多线程进行垃圾收集（并行收集器，响应优先）。</p>\n<p>3.Parallel Scavenge采用复制算法针对新生代的多线程收集器（并行收集器，吞吐优先）。可控制吞吐量和停顿时间，即吞吐量 = 运行用户代码时间 / (运行用户代码时间+垃圾收集时间)。<br>Parallel Old收集器是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和标记-整理算法。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/17.webp\" class=\"\">\n\n<p>4.CMS（Current MarkSweep）收集器针对老年代，是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是标记-清除算法。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/19.webp\" class=\"\">\n\n<p>5.G1的新生代类似于ParNew，采用复制算法算法，当新生代占用达到一定比例的时候，开始收集。老年代类似于CMS，不同点是采用标记-整理算法。<br>G1因此它是一款并行与并发收集器，能充分利用多CPU、多核环境。并且它能建立可预测的停顿时间模型。</p>\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/20.webp\" class=\"\">\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/21.webp\" class=\"\">\n<p>与CMS收集器相比G1收集器有以下特点：</p>\n<ol>\n<li>空间整合，G1收集器采用标记-整理算法，不会产生内存空间碎片。分配大对象（直接进Humongous区，专门存放短期巨型对象，不用直接进老年代，避免Full GC的大量开销）不会因为无法找到连续空间而提前触发下一次GC。（年青代拷贝、老年代转移对象无空闲分区、巨型对象无连续分区时触发Full GC，开销极大应该避免）</li>\n<li>可预测停顿，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间内，消耗在垃圾收集上的时间不得超过N毫秒，几乎达到Java实时系统（RTSJ）级的垃圾收集器。</li>\n<li>G1将Java堆划分为多个大小相等的独立区域（Region），虽保留新生代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。</li>\n</ol>\n<h1 id=\"十七、收集器常用组合\"><a href=\"#十七、收集器常用组合\" class=\"headerlink\" title=\"十七、收集器常用组合\"></a>十七、收集器常用组合</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/22.webp\" class=\"\">\n<img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/23.webp\" class=\"\">\n\n<h1 id=\"十八、JVM性能调优思路\"><a href=\"#十八、JVM性能调优思路\" class=\"headerlink\" title=\"十八、JVM性能调优思路\"></a>十八、JVM性能调优思路</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/24.webp\" class=\"\">\n\n<h1 id=\"十九、理解GC日志\"><a href=\"#十九、理解GC日志\" class=\"headerlink\" title=\"十九、理解GC日志\"></a>十九、理解GC日志</h1><img src=\"/2019/03/21/2019-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/24.webp\" class=\"\">\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC [PSYoungGen: 8192K-&gt;1000K(9216K)] 16004K-&gt;14604K(29696K), 0.0317424 secs] [Times: user&#x3D;0.06 sys&#x3D;0.00, real&#x3D;0.03 secs]</span><br><span class=\"line\"></span><br><span class=\"line\">[GC [PSYoungGen: 9192K-&gt;1016K(9216K)] 22796K-&gt;20780K(29696K), 0.0314567 secs] [Times: user&#x3D;0.06 sys&#x3D;0.00, real&#x3D;0.03 secs]</span><br><span class=\"line\"></span><br><span class=\"line\">[Full GC [PSYoungGen: 8192K-&gt;8192K(9216K)] [ParOldGen: 20435K-&gt;20435K(20480K)] 28627K-&gt;28627K(29696K), [Metaspace: 8469K-&gt;8469K(1056768K)], 0.1307495 secs] [Times: user&#x3D;0.50 sys&#x3D;0.00, real&#x3D;0.13 secs]</span><br><span class=\"line\"></span><br><span class=\"line\">[Full GC [PSYoungGen: 8192K-&gt;8192K(9216K)] [ParOldGen: 20437K-&gt;20437K(20480K)] 28629K-&gt;28629K(29696K), [Metaspace: 8469K-&gt;8469K(1056768K)], 0.1240311 secs] [Times: user&#x3D;0.42 sys&#x3D;0.00, real&#x3D;0.12 secs]</span><br></pre></td></tr></table></figure>\n<h1 id=\"二十、常见异常\"><a href=\"#二十、常见异常\" class=\"headerlink\" title=\"二十、常见异常\"></a>二十、常见异常</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StackOverflowError:（栈溢出）</span><br><span class=\"line\"></span><br><span class=\"line\">OutOfMemoryError: Java heap space（堆空间不足）</span><br><span class=\"line\"></span><br><span class=\"line\">OutOfMemoryError: GC overhead limit exceeded  （GC花费的时间超过 98%, 并且GC回收的内存少于 2%）</span><br></pre></td></tr></table></figure>\n<h1 id=\"二十一、GC参数\"><a href=\"#二十一、GC参数\" class=\"headerlink\" title=\"二十一、GC参数\"></a>二十一、GC参数</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">堆栈设置</span><br><span class=\"line\"></span><br><span class=\"line\">-Xss:每个线程的栈大小</span><br><span class=\"line\"></span><br><span class=\"line\">-Xms:初始堆大小，默认物理内存的1&#x2F;64</span><br><span class=\"line\"></span><br><span class=\"line\">-Xmx:最大堆大小，默认物理内存的1&#x2F;4</span><br><span class=\"line\"></span><br><span class=\"line\">-Xmn:新生代大小</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:NewSize:设置新生代初始大小</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:NewRatio:默认2表示新生代占年老代的1&#x2F;2，占整个堆内存的1&#x2F;3。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:SurvivorRatio:默认8表示一个survivor区占用1&#x2F;8的Eden内存，即1&#x2F;10的新生代内存。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MaxMetaspaceSize:设置元空间最大允许大小，默认不受限制，JVM Metaspace会进行动态扩展。</span><br><span class=\"line\"></span><br><span class=\"line\">垃圾回收统计信息</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+PrintGC</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+PrintGCDetails</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+PrintGCTimeStamps</span><br><span class=\"line\"></span><br><span class=\"line\">-Xloggc:filename</span><br><span class=\"line\"></span><br><span class=\"line\">收集器设置</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseSerialGC:设置串行收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseParallelGC:设置并行收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseParallelOldGC:老年代使用并行回收收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseParNewGC:在新生代使用并行收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseParalledlOldGC:设置并行老年代收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseConcMarkSweepGC:设置CMS并发收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseG1GC:设置G1收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:ParallelGCThreads:设置用于垃圾回收的线程数</span><br><span class=\"line\"></span><br><span class=\"line\">并行收集器设置</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:ParallelGCThreads:设置并行收集器收集时使用的CPU数。并行收集线程数。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MaxGCPauseMillis:设置并行收集最大暂停时间</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:GCTimeRatio:设置垃圾回收时间占程序运行时间的百分比。公式为1&#x2F;(1+n)</span><br><span class=\"line\"></span><br><span class=\"line\">CMS收集器设置</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseConcMarkSweepGC:设置CMS并发收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:ParallelGCThreads:设置并发收集器新生代收集方式为并行收集时，使用的CPU数。并行收集线程数。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:CMSFullGCsBeforeCompaction:设定进行多少次CMS垃圾回收后，进行一次内存压缩</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+CMSClassUnloadingEnabled:允许对类元数据进行回收</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:UseCMSInitiatingOccupancyOnly:表示只在到达阀值的时候，才进行CMS回收</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:ParallelCMSThreads:设定CMS的线程数量</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:CMSInitiatingOccupancyFraction:设置CMS收集器在老年代空间被使用多少后触发</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseCMSCompactAtFullCollection:设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理</span><br><span class=\"line\"></span><br><span class=\"line\">G1收集器设置</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseG1GC:使用G1收集器</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:ParallelGCThreads:指定GC工作的线程数量</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:G1HeapRegionSize:指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:GCTimeRatio:吞吐量大小，0-100的整数(默认9)，值为n则系统将花费不超过1&#x2F;(1+n)的时间用于垃圾收集</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MaxGCPauseMillis:目标暂停时间(默认200ms)</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:G1NewSizePercent:新生代内存初始空间(默认整堆5%)</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:G1MaxNewSizePercent:新生代内存最大空间</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:TargetSurvivorRatio:Survivor填充容量(默认50%)</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MaxTenuringThreshold:最大任期阈值(默认15)</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:InitiatingHeapOccupancyPercen:老年代占用空间超过整堆比IHOP阈值(默认45%),超过则执行混合收集</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:G1HeapWastePercent:堆废物百分比(默认5%)</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:G1MixedGCCountTarget:参数混合周期的最大总次数(默认8)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二十二、性能分析和监控工具\"><a href=\"#二十二、性能分析和监控工具\" class=\"headerlink\" title=\"二十二、性能分析和监控工具\"></a>二十二、性能分析和监控工具</h1><ul>\n<li>Jps：虚拟机进程状况工具</li>\n<li>Jstat：虚拟机统计信息监视工具</li>\n<li>Jinfo：虚拟机配置信息工具</li>\n<li>Jmap：内存映像工具</li>\n<li>Jhat：虚拟机堆转储快照分析工具</li>\n<li>Jstack：堆栈跟踪工具</li>\n<li>JConsole：java监视与管理控制台</li>\n<li>VisualVM：故障处理工具</li>\n</ul>\n<blockquote>\n<p>Learned from 鲁班学院</p>\n</blockquote>"},{"title":"Java高级开发必会的50个性能优化的细节","date":"2019-03-17T15:23:29.000Z","updated":"2019-03-17T15:23:29.000Z","_content":"\n> 作者：陶邦仁\n> https://my.oschina.net/xianggao/blog/77224\n\n在JAVA程序中，性能问题的大部分原因并不在于JAVA语言，而是程序本身。养成良好的编码习惯非常重要，能够显著地提升程序性能。\n\n<!-- more -->\n\n### 1. 尽量在合适的场合使用单例\n\n使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：\n\n第一，控制资源的使用，通过线程同步来控制资源的并发访问；\n\n第二，控制实例的产生，以达到节约资源的目的；\n\n第三，控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。\n\n### 2. 尽量避免随意使用静态变量\n\n要知道，当某个对象被定义为static变量所引用，那么GC通常是不会回收这个对象所占有的内存，如\n```\npublic class A{ \n   private static B b = new B(); \n}\n```\n此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。\n\n### 3. 尽量避免过多过常的创建Java对象\n\n尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。\n\n### 4. 尽量使用final修饰符\n\n带有 final 修饰符的类是不可派生的。在JAVA核心API中，有许多应用 final 的例子，例如`java.lang.String`，为 String 类指定 final 防止了使用者覆盖 length() 方法。另外，如果一个类是final的，则该类所有方法都是 final 的。java编译器会寻找机会内联（inline）所有的 final 方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。\n\n如：让访问实例内变量的 getter/setter 方法变成final：\n\n简单的 getter/setter 方法应该被置成 final，这会告诉编译器，这个方法不会被重载，所以，可以变成“inlined”,例子：\n```\nclass MAF { \n     public void setSize (int size) { \n          _size = size; \n     } \n     private int _size; \n}\n```\n更正\n```\nclass DAF_fixed { \n     final public void setSize (int size) { \n          _size = size; \n     } \n     private int _size; \n}\n```\n### 5. 尽量使用局部变量\n\n调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。其他变量，如静态变量，实例变量等，都在堆（Heap）中创建，速度较慢。\n\n### 6. 尽量处理好包装类型和基本类型两者的使用场所\n\n虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。\n\n### 7. 慎用synchronized，尽量减小synchronize的方法\n\n都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize 方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以 synchronize 的方法尽量小，并且应尽量使用方法同步代替代码块同步。\n\n### 9. 尽量不要使用finalize方法\n\n实际上，将资源清理放在 finalize 方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收 Young 代内存时，大都会引起应用程序暂停，所以再选择使用 finalize 方法进行资源清理，会导致GC负担更大，程序运行效率更差。\n\n### 10. 尽量使用基本数据类型代替对象\n```\nString str = \"hello\";\n```\n上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；\n```\nString str = new String(\"hello\");\n```\n此时程序除创建字符串外，str所引用的 String 对象底层还包含一个 char[] 数组，这个 char[] 数组依次存放了h,e,l,l,o\n\n### 11. 多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList\n\nHashTable、Vector等使用了同步机制，降低了性能。\n\n### 12. 尽量合理的创建HashMap\n\n当你要创建一个比较大的hashMap时，充分利用这个构造函数\n```\npublic HashMap(int initialCapacity, float loadFactor);\n```\n避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中 initialCapacity 只有16，而 loadFactor 是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的 Hashtable，Vectors 也是一样的道理。\n\n### 13. 尽量减少对变量的重复计算\n\n如：\n```\nfor(int i=0;i<list.size();i++)\n```\n应该改为\n```\nfor(int i=0,len=list.size();i<len;i++)\n```\n并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。\n\n### 14. 尽量避免不必要的创建\n\n如：\n```\nA a = new A();\n\nif(i==1){list.add(a);}\n```\n应该改为\n```\nif(i==1){\n\n  A a = new A();\n\n  list.add(a);\n\n}\n```\n### 15. 尽量在finally块中释放资源\n\n程序中使用到的资源应当被释放，以避免资源泄漏。这最好在 finally 块中去做。不管程序执行的结果如何，finally 块总是会执行的，以确保资源的正确关闭。\n\n### 16. 尽量使用移位来代替'a/b'的操作\n\n`/`是一个代价很高的操作，使用移位的操作将会更快和更有效\n\n如\n```\nint num = a / 4;\n\nint num = a / 8;\n```\n应该改为\n```\nint num = a >> 2;\n\nint num = a >> 3;\n```\n但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解\n\n### 17.尽量使用移位来代替'a*b'的操作\n\n同样的，对于'*'操作，使用移位的操作将会更快和更有效\n\n如\n```\nint num = a * 4;\n\nint num = a * 8;\n```\n应该改为\n```\nint num = a << 2;\n\nint num = a << 3;\n```\n### 18. 尽量确定StringBuffer的容量\n\nStringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。 \n\n如：\n```\nStringBuffer buffer = new StringBuffer(1000);\n```\n### 19. 尽量早释放无用对象的引用\n\n大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。\n\n例如：\n```Java\nPublic void test(){ \n\n  Object obj = new Object(); \n\n  …… \n\n  Obj=null; \n\n}\n```\n上面这个就没必要了，随着方法 test() 的执行完成，程序中obj引用变量的作用域就结束了。但是如果是改成下面：\n```\nPublic void test(){ \n\n  Object obj = new Object(); \n\n  …… \n\n  Obj=null; \n\n  //执行耗时，耗内存操作；或调用耗时，耗内存的方法\n\n  …… \n\n}\n```\n这时候就有必要将obj赋值为 null，可以尽早的释放对 Object 对象的引用。\n\n### 20. 尽量避免使用二维数组\n\n二维数据占用的内存空间比一维数组多得多，大概10倍以上。\n\n### 21. 尽量避免使用split\n\n除非是必须的，否则应该避免使用 split，split 由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需要频繁的调用split，可以考虑使用 apache 的`StringUtils.split(string,char)`，频繁split的可以缓存结果。\n\n### 22. ArrayList & LinkedList\n\n一个是线性表，一个是链表，一句话，随机查询尽量使用 ArrayList，ArrayList 优于 LinkedList，LinkedList 还要移动指针，添加删除的操作 LinkedList 优于 ArrayList，ArrayList 还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2者得数据结构，对症下药。\n\n### 23. 尽量使用 System.arraycopy() 代替通过来循环复制数组\n\n`System.arraycopy()`要比通过循环来复制数组快的多。\n\n### 24. 尽量缓存经常使用的对象\n\n尽可能将经常使用的对象进行缓存，可以使用数组，或 HashMap 的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如 EhCache，Oscache 进行缓存，他们基本都实现了 FIFO/FLU 等缓存算法。\n\n### 25. 尽量避免非常大的内存分配\n\n有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。\n\n### 26. 慎用异常\n\n当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。\n\n如果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常。幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。\n\n### 27. 尽量重用对象\n\n特别是 String 对象的使用中，出现字符串连接情况时应使用 StringBuffer 代替，由于系统不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理。因此生成过多的对象将会给程序的性能带来很大的影响。\n\n### 28. 不要重复初始化变量\n\n默认情况下，调用类的构造函数时，java会把变量初始化成确定的值，所有的对象被设置成 null，整数变量设置成0，float 和 double 变量设置成0.0，逻辑值设置成 false。当一个类从另一个类派生时，这一点尤其应该注意，因为用 new 关键字创建一个对象时，构造函数链中的所有构造函数都会被自动调用。 \n这里有个注意，给成员变量设置初始值但需要调用其他方法的时候，最好放在一个方法比如 initXXX() 中，因为直接调用某方法赋值可能会因为类尚未初始化而抛空指针异常，如：`public int state = this.getState()`;\n\n### 29. 在 java+Oracle 的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。\n\n### 30. 在java编程过程中，进行数据库连接，I/O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。\n\n### 31. 过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。\n\n### 32. 在使用同步机制时，应尽量使用方法同步代替代码块同步。\n\n### 33. 不要在循环中使用Try/Catch语句，应把Try/Catch放在循环最外层\n\nError是获取系统错误的类，或者说是虚拟机错误的类。不是所有的错误 Exception 都能获取到的，虚拟机报错 Exception 就获取不到，必须用 Error 获取。\n\n### 34. 通过 StringBuffer 的构造函数来设定他的初始化容量，可以明显提升性能\n\nStringBuffer 的默认容量为16，当 StringBuffer 的容量达到最大容量时，她会将自身容量增加到当前的2倍+2，也就是 2*n+2。无论何时，只要 StringBuffer 到达她的最大容量，她就不得不创建一个新的对象数组，然后复制旧的对象数组，这会浪费很多时间。所以给 StringBuffer 设置一个合理的初始化容量值，是很有必要的！  \n\n### 35. 合理使用java.util.Vector\n\nVector 与 StringBuffer 类似，每次扩展容量时，所有现有元素都要赋值到新的存储空间中。Vector 的默认存储能力为10个元素，扩容加倍。 \nvector.add(index,obj) 这个方法可以将元素obj插入到 index 位置，但 index 以及之后的元素依次都要向下移动一个位置（将其索引加 1）。 除非必要，否则对性能不利。同样规则适用于 remove(int index) 方法，移除此向量中指定位置的元素。将所有后续元素左移（将其索引减 1）。返回此向量中移除的元素。所以删除vector最后一个元素要比删除第1个元素开销低很多。删除所有元素最好用 removeAllElements() 方法。 \n如果要删除 vector 里的一个元素可以使用 vector.remove(obj)；而不必自己检索元素位置，再删除，如`int index = indexOf(obj);vector.remove(index)`； \n\n### 38. 不用new关键字创建对象的实例 \n用new关键词创建类的实例时，构造函数链中的所有构造函数都会被自动调用。但如果一个对象实现了 Cloneable 接口，我们可以调用她的 clone() 方法。clone() 方法不会调用任何类构造函数。 \n下面是Factory模式的一个典型实现：\n```\npublic static Credit getNewCredit() \n{ \n    return new Credit(); \n}\n```\n改进后的代码使用 clone() 方法：\n```\nprivate static Credit BaseCredit = new Credit(); \npublic static Credit getNewCredit() \n{ \n    return (Credit)BaseCredit.clone(); \n}\n```\n### 39. 不要将数组声明为：public static final\n\n### 40. HaspMap的遍历：\n```\nMap<String, String[]> paraMap = new HashMap<String, String[]>(); \nfor( Entry<String, String[]> entry : paraMap.entrySet() ) \n{ \n    String appFieldDefId = entry.getKey(); \n    String[] values = entry.getValue(); \n}\n```\n利用散列值取出相应的 Entry 做比较得到结果，取得 entry 的值之后直接取 key 和 value。 \n\n### 41. array(数组)和 ArrayList 的使用\n\narray 数组效率最高，但容量固定，无法动态改变，ArrayList 容量可以动态增长，但牺牲了效率。  \n\n### 42. 单线程应尽量使用 HashMap, ArrayList，除非必要，否则不推荐使用 HashTable,Vector，她们使用了同步机制，而降低了性能。\n\n### 43. StringBuffer,StringBuilder 的区别在于：\n\njava.lang.StringBuffer 线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。StringBuilder 与该类相比，通常应该优先使用 StringBuilder 类，因为她支持所有相同的操作，但由于她不执行同步，所以速度更快。为了获得更好的性能，在构造 StringBuffer 或 StringBuilder 时应尽量指定她的容量。当然如果不超过16个字符时就不用了。 相同情况下，使用StringBuilder比使用 StringBuffer 仅能获得10%~15%的性能提升，但却要冒多线程不安全的风险。综合考虑还是建议使用 StringBuffer。\n\n### 44. 尽量使用基本数据类型代替对象。  \n\n### 45. 使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。 \n\n### 46. 考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。她会被更快地调用，因为她不需要一个虚拟函数导向表。这同事也是一个很好的实践，因为她告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。 \n\n### 47. 应尽可能避免使用内在的GET,SET方法。 \n\n### 48.避免枚举，浮点数的使用。 \n\n以下举几个实用优化的例子：\n\n### 一、避免在循环条件中使用复杂表达式\n\n在不做编译优化的情况下，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。例子：\n```\nimport java.util.Vector; \nclass CEL { \n     void method (Vector vector) { \n         for (int i = 0; i < vector.size (); i++)   // Violation \n             ; // ... \n     } \n}\n```\n更正：\n```\nclass CEL_fixed { \n     void method (Vector vector) { \n         int size = vector.size () \n         for (int i = 0; i < size; i++) \n             ; // ... \n     } \n}\n```\n### 二、为'Vectors' 和 'Hashtables'定义初始大小 \nJVM 为 Vector 扩充大小的时候需要重新创建一个更大的数组，将原原先数组中的内容复制过来，最后，原先的数组再被回收。可见 Vector 容量的扩大是一个颇费时间的事。\n\n通常，默认的10个元素大小是不够的。你最好能准确的估计你所需要的最佳大小。例子：\n```\nimport java.util.Vector; \npublic class DIC { \n     public void addObjects (Object[] o) { \n         // if length > 10, Vector needs to expand \n         for (int i = 0; i< o.length;i++) {    \n             v.add(o);    // capacity before it can add more elements. \n         } \n     } \n     public Vector v = new Vector();   // no initialCapacity. \n}\n```\n更正：\n\n自己设定初始大小。\n```\npublic Vector v = new Vector(20);  \npublic Hashtable hash = new Hashtable(10);\n```\n### 三、在 finally 块中关闭 Stream\n\n程序中使用到的资源应当被释放，以避免资源泄漏。这最好在 finally 块中去做。不管程序执行的结果如何， finally 块总是会执行的，以确保资源的正确关闭。\n\n### 四、使用'System.arraycopy ()'代替通过来循环复制数组,例子：\n```\npublic class IRB \n{ \n     void method () { \n         int[] array1 = new int [100]; \n         for (int i = 0; i < array1.length; i++) { \n             array1 [i] = i; \n         } \n         int[] array2 = new int [100]; \n         for (int i = 0; i < array2.length; i++) { \n             array2 [i] = array1 [i]; // Violation \n         } \n     } \n}\n```\n更正：\n```\npublic class IRB \n{ \n     void method () { \n         int[] array1 = new int [100]; \n         for (int i = 0; i < array1.length; i++) { \n             array1 [i] = i; \n         } \n         int[] array2 = new int [100]; \n         System.arraycopy(array1, 0, array2, 0, 100); \n     } \n}\n```\n### 五、让访问实例内变量的getter/setter方法变成”final”\n\n简单的 getter/setter 方法应该被置成 final，这会告诉编译器，这个方法不会被重载，所以，可以变成”inlined”,例子：\n```\nclass MAF { \n     public void setSize (int size) { \n          _size = size; \n     } \n     private int _size; \n}\n```\n更正：\n```\nclass DAF_fixed { \n     final public void setSize (int size) { \n          _size = size; \n     } \n     private int _size; \n}\n```\n### 六、对于常量字符串，用'String' 代替 'StringBuffer' \n\n常量字符串并不需要动态改变长度。\n\n例子：\n```\npublic class USC { \n     String method () { \n         StringBuffer s = new StringBuffer (\"Hello\"); \n         String t = s + \"World!\"; \n         return t; \n     } \n}\n```\n更正：\n\n把StringBuffer换成String，如果确定这个String不会再变的话，这将会减少运行开销提高性能。\n\n### 七、在字符串相加的时候，使用 ' ' 代替 \" \"，如果该字符串只有一个字符的话\n\n例子：\n```\npublic class STR { \n     public void method(String s) { \n         String string = s + \"d\"   // violation. \n         string = \"abc\" + \"d\"      // violation. \n     } \n}\n```\n更正：\n\n将一个字符的字符串替换成' '\n```\npublic class STR { \n     public void method(String s) { \n         String string = s + 'd' \n         string = \"abc\" + 'd'   \n     } \n}\n```\n以上仅是Java方面编程时的性能优化，性能优化大部分都是在时间、效率、代码结构层次等方面的权衡，各有利弊，不要把上面内容当成教条，或许有些对我们实际工作适用，有些不适用，还望根据实际工作场景进行取舍吧，活学活用，变通为宜。\n","source":"_posts/2019/Java高级开发必会的50个性能优化的细节.md","raw":"---\ntitle: Java高级开发必会的50个性能优化的细节\ndate: 2019-03-17 23:23:29\nupdated: 2019-03-17 23:23:29\ntags: Java\n---\n\n> 作者：陶邦仁\n> https://my.oschina.net/xianggao/blog/77224\n\n在JAVA程序中，性能问题的大部分原因并不在于JAVA语言，而是程序本身。养成良好的编码习惯非常重要，能够显著地提升程序性能。\n\n<!-- more -->\n\n### 1. 尽量在合适的场合使用单例\n\n使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：\n\n第一，控制资源的使用，通过线程同步来控制资源的并发访问；\n\n第二，控制实例的产生，以达到节约资源的目的；\n\n第三，控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。\n\n### 2. 尽量避免随意使用静态变量\n\n要知道，当某个对象被定义为static变量所引用，那么GC通常是不会回收这个对象所占有的内存，如\n```\npublic class A{ \n   private static B b = new B(); \n}\n```\n此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。\n\n### 3. 尽量避免过多过常的创建Java对象\n\n尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。\n\n### 4. 尽量使用final修饰符\n\n带有 final 修饰符的类是不可派生的。在JAVA核心API中，有许多应用 final 的例子，例如`java.lang.String`，为 String 类指定 final 防止了使用者覆盖 length() 方法。另外，如果一个类是final的，则该类所有方法都是 final 的。java编译器会寻找机会内联（inline）所有的 final 方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。\n\n如：让访问实例内变量的 getter/setter 方法变成final：\n\n简单的 getter/setter 方法应该被置成 final，这会告诉编译器，这个方法不会被重载，所以，可以变成“inlined”,例子：\n```\nclass MAF { \n     public void setSize (int size) { \n          _size = size; \n     } \n     private int _size; \n}\n```\n更正\n```\nclass DAF_fixed { \n     final public void setSize (int size) { \n          _size = size; \n     } \n     private int _size; \n}\n```\n### 5. 尽量使用局部变量\n\n调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。其他变量，如静态变量，实例变量等，都在堆（Heap）中创建，速度较慢。\n\n### 6. 尽量处理好包装类型和基本类型两者的使用场所\n\n虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。\n\n### 7. 慎用synchronized，尽量减小synchronize的方法\n\n都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize 方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以 synchronize 的方法尽量小，并且应尽量使用方法同步代替代码块同步。\n\n### 9. 尽量不要使用finalize方法\n\n实际上，将资源清理放在 finalize 方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收 Young 代内存时，大都会引起应用程序暂停，所以再选择使用 finalize 方法进行资源清理，会导致GC负担更大，程序运行效率更差。\n\n### 10. 尽量使用基本数据类型代替对象\n```\nString str = \"hello\";\n```\n上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；\n```\nString str = new String(\"hello\");\n```\n此时程序除创建字符串外，str所引用的 String 对象底层还包含一个 char[] 数组，这个 char[] 数组依次存放了h,e,l,l,o\n\n### 11. 多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList\n\nHashTable、Vector等使用了同步机制，降低了性能。\n\n### 12. 尽量合理的创建HashMap\n\n当你要创建一个比较大的hashMap时，充分利用这个构造函数\n```\npublic HashMap(int initialCapacity, float loadFactor);\n```\n避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中 initialCapacity 只有16，而 loadFactor 是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的 Hashtable，Vectors 也是一样的道理。\n\n### 13. 尽量减少对变量的重复计算\n\n如：\n```\nfor(int i=0;i<list.size();i++)\n```\n应该改为\n```\nfor(int i=0,len=list.size();i<len;i++)\n```\n并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。\n\n### 14. 尽量避免不必要的创建\n\n如：\n```\nA a = new A();\n\nif(i==1){list.add(a);}\n```\n应该改为\n```\nif(i==1){\n\n  A a = new A();\n\n  list.add(a);\n\n}\n```\n### 15. 尽量在finally块中释放资源\n\n程序中使用到的资源应当被释放，以避免资源泄漏。这最好在 finally 块中去做。不管程序执行的结果如何，finally 块总是会执行的，以确保资源的正确关闭。\n\n### 16. 尽量使用移位来代替'a/b'的操作\n\n`/`是一个代价很高的操作，使用移位的操作将会更快和更有效\n\n如\n```\nint num = a / 4;\n\nint num = a / 8;\n```\n应该改为\n```\nint num = a >> 2;\n\nint num = a >> 3;\n```\n但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解\n\n### 17.尽量使用移位来代替'a*b'的操作\n\n同样的，对于'*'操作，使用移位的操作将会更快和更有效\n\n如\n```\nint num = a * 4;\n\nint num = a * 8;\n```\n应该改为\n```\nint num = a << 2;\n\nint num = a << 3;\n```\n### 18. 尽量确定StringBuffer的容量\n\nStringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。 \n\n如：\n```\nStringBuffer buffer = new StringBuffer(1000);\n```\n### 19. 尽量早释放无用对象的引用\n\n大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。\n\n例如：\n```Java\nPublic void test(){ \n\n  Object obj = new Object(); \n\n  …… \n\n  Obj=null; \n\n}\n```\n上面这个就没必要了，随着方法 test() 的执行完成，程序中obj引用变量的作用域就结束了。但是如果是改成下面：\n```\nPublic void test(){ \n\n  Object obj = new Object(); \n\n  …… \n\n  Obj=null; \n\n  //执行耗时，耗内存操作；或调用耗时，耗内存的方法\n\n  …… \n\n}\n```\n这时候就有必要将obj赋值为 null，可以尽早的释放对 Object 对象的引用。\n\n### 20. 尽量避免使用二维数组\n\n二维数据占用的内存空间比一维数组多得多，大概10倍以上。\n\n### 21. 尽量避免使用split\n\n除非是必须的，否则应该避免使用 split，split 由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需要频繁的调用split，可以考虑使用 apache 的`StringUtils.split(string,char)`，频繁split的可以缓存结果。\n\n### 22. ArrayList & LinkedList\n\n一个是线性表，一个是链表，一句话，随机查询尽量使用 ArrayList，ArrayList 优于 LinkedList，LinkedList 还要移动指针，添加删除的操作 LinkedList 优于 ArrayList，ArrayList 还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2者得数据结构，对症下药。\n\n### 23. 尽量使用 System.arraycopy() 代替通过来循环复制数组\n\n`System.arraycopy()`要比通过循环来复制数组快的多。\n\n### 24. 尽量缓存经常使用的对象\n\n尽可能将经常使用的对象进行缓存，可以使用数组，或 HashMap 的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如 EhCache，Oscache 进行缓存，他们基本都实现了 FIFO/FLU 等缓存算法。\n\n### 25. 尽量避免非常大的内存分配\n\n有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。\n\n### 26. 慎用异常\n\n当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。\n\n如果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常。幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。\n\n### 27. 尽量重用对象\n\n特别是 String 对象的使用中，出现字符串连接情况时应使用 StringBuffer 代替，由于系统不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理。因此生成过多的对象将会给程序的性能带来很大的影响。\n\n### 28. 不要重复初始化变量\n\n默认情况下，调用类的构造函数时，java会把变量初始化成确定的值，所有的对象被设置成 null，整数变量设置成0，float 和 double 变量设置成0.0，逻辑值设置成 false。当一个类从另一个类派生时，这一点尤其应该注意，因为用 new 关键字创建一个对象时，构造函数链中的所有构造函数都会被自动调用。 \n这里有个注意，给成员变量设置初始值但需要调用其他方法的时候，最好放在一个方法比如 initXXX() 中，因为直接调用某方法赋值可能会因为类尚未初始化而抛空指针异常，如：`public int state = this.getState()`;\n\n### 29. 在 java+Oracle 的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。\n\n### 30. 在java编程过程中，进行数据库连接，I/O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。\n\n### 31. 过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。\n\n### 32. 在使用同步机制时，应尽量使用方法同步代替代码块同步。\n\n### 33. 不要在循环中使用Try/Catch语句，应把Try/Catch放在循环最外层\n\nError是获取系统错误的类，或者说是虚拟机错误的类。不是所有的错误 Exception 都能获取到的，虚拟机报错 Exception 就获取不到，必须用 Error 获取。\n\n### 34. 通过 StringBuffer 的构造函数来设定他的初始化容量，可以明显提升性能\n\nStringBuffer 的默认容量为16，当 StringBuffer 的容量达到最大容量时，她会将自身容量增加到当前的2倍+2，也就是 2*n+2。无论何时，只要 StringBuffer 到达她的最大容量，她就不得不创建一个新的对象数组，然后复制旧的对象数组，这会浪费很多时间。所以给 StringBuffer 设置一个合理的初始化容量值，是很有必要的！  \n\n### 35. 合理使用java.util.Vector\n\nVector 与 StringBuffer 类似，每次扩展容量时，所有现有元素都要赋值到新的存储空间中。Vector 的默认存储能力为10个元素，扩容加倍。 \nvector.add(index,obj) 这个方法可以将元素obj插入到 index 位置，但 index 以及之后的元素依次都要向下移动一个位置（将其索引加 1）。 除非必要，否则对性能不利。同样规则适用于 remove(int index) 方法，移除此向量中指定位置的元素。将所有后续元素左移（将其索引减 1）。返回此向量中移除的元素。所以删除vector最后一个元素要比删除第1个元素开销低很多。删除所有元素最好用 removeAllElements() 方法。 \n如果要删除 vector 里的一个元素可以使用 vector.remove(obj)；而不必自己检索元素位置，再删除，如`int index = indexOf(obj);vector.remove(index)`； \n\n### 38. 不用new关键字创建对象的实例 \n用new关键词创建类的实例时，构造函数链中的所有构造函数都会被自动调用。但如果一个对象实现了 Cloneable 接口，我们可以调用她的 clone() 方法。clone() 方法不会调用任何类构造函数。 \n下面是Factory模式的一个典型实现：\n```\npublic static Credit getNewCredit() \n{ \n    return new Credit(); \n}\n```\n改进后的代码使用 clone() 方法：\n```\nprivate static Credit BaseCredit = new Credit(); \npublic static Credit getNewCredit() \n{ \n    return (Credit)BaseCredit.clone(); \n}\n```\n### 39. 不要将数组声明为：public static final\n\n### 40. HaspMap的遍历：\n```\nMap<String, String[]> paraMap = new HashMap<String, String[]>(); \nfor( Entry<String, String[]> entry : paraMap.entrySet() ) \n{ \n    String appFieldDefId = entry.getKey(); \n    String[] values = entry.getValue(); \n}\n```\n利用散列值取出相应的 Entry 做比较得到结果，取得 entry 的值之后直接取 key 和 value。 \n\n### 41. array(数组)和 ArrayList 的使用\n\narray 数组效率最高，但容量固定，无法动态改变，ArrayList 容量可以动态增长，但牺牲了效率。  \n\n### 42. 单线程应尽量使用 HashMap, ArrayList，除非必要，否则不推荐使用 HashTable,Vector，她们使用了同步机制，而降低了性能。\n\n### 43. StringBuffer,StringBuilder 的区别在于：\n\njava.lang.StringBuffer 线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。StringBuilder 与该类相比，通常应该优先使用 StringBuilder 类，因为她支持所有相同的操作，但由于她不执行同步，所以速度更快。为了获得更好的性能，在构造 StringBuffer 或 StringBuilder 时应尽量指定她的容量。当然如果不超过16个字符时就不用了。 相同情况下，使用StringBuilder比使用 StringBuffer 仅能获得10%~15%的性能提升，但却要冒多线程不安全的风险。综合考虑还是建议使用 StringBuffer。\n\n### 44. 尽量使用基本数据类型代替对象。  \n\n### 45. 使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。 \n\n### 46. 考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。她会被更快地调用，因为她不需要一个虚拟函数导向表。这同事也是一个很好的实践，因为她告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。 \n\n### 47. 应尽可能避免使用内在的GET,SET方法。 \n\n### 48.避免枚举，浮点数的使用。 \n\n以下举几个实用优化的例子：\n\n### 一、避免在循环条件中使用复杂表达式\n\n在不做编译优化的情况下，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。例子：\n```\nimport java.util.Vector; \nclass CEL { \n     void method (Vector vector) { \n         for (int i = 0; i < vector.size (); i++)   // Violation \n             ; // ... \n     } \n}\n```\n更正：\n```\nclass CEL_fixed { \n     void method (Vector vector) { \n         int size = vector.size () \n         for (int i = 0; i < size; i++) \n             ; // ... \n     } \n}\n```\n### 二、为'Vectors' 和 'Hashtables'定义初始大小 \nJVM 为 Vector 扩充大小的时候需要重新创建一个更大的数组，将原原先数组中的内容复制过来，最后，原先的数组再被回收。可见 Vector 容量的扩大是一个颇费时间的事。\n\n通常，默认的10个元素大小是不够的。你最好能准确的估计你所需要的最佳大小。例子：\n```\nimport java.util.Vector; \npublic class DIC { \n     public void addObjects (Object[] o) { \n         // if length > 10, Vector needs to expand \n         for (int i = 0; i< o.length;i++) {    \n             v.add(o);    // capacity before it can add more elements. \n         } \n     } \n     public Vector v = new Vector();   // no initialCapacity. \n}\n```\n更正：\n\n自己设定初始大小。\n```\npublic Vector v = new Vector(20);  \npublic Hashtable hash = new Hashtable(10);\n```\n### 三、在 finally 块中关闭 Stream\n\n程序中使用到的资源应当被释放，以避免资源泄漏。这最好在 finally 块中去做。不管程序执行的结果如何， finally 块总是会执行的，以确保资源的正确关闭。\n\n### 四、使用'System.arraycopy ()'代替通过来循环复制数组,例子：\n```\npublic class IRB \n{ \n     void method () { \n         int[] array1 = new int [100]; \n         for (int i = 0; i < array1.length; i++) { \n             array1 [i] = i; \n         } \n         int[] array2 = new int [100]; \n         for (int i = 0; i < array2.length; i++) { \n             array2 [i] = array1 [i]; // Violation \n         } \n     } \n}\n```\n更正：\n```\npublic class IRB \n{ \n     void method () { \n         int[] array1 = new int [100]; \n         for (int i = 0; i < array1.length; i++) { \n             array1 [i] = i; \n         } \n         int[] array2 = new int [100]; \n         System.arraycopy(array1, 0, array2, 0, 100); \n     } \n}\n```\n### 五、让访问实例内变量的getter/setter方法变成”final”\n\n简单的 getter/setter 方法应该被置成 final，这会告诉编译器，这个方法不会被重载，所以，可以变成”inlined”,例子：\n```\nclass MAF { \n     public void setSize (int size) { \n          _size = size; \n     } \n     private int _size; \n}\n```\n更正：\n```\nclass DAF_fixed { \n     final public void setSize (int size) { \n          _size = size; \n     } \n     private int _size; \n}\n```\n### 六、对于常量字符串，用'String' 代替 'StringBuffer' \n\n常量字符串并不需要动态改变长度。\n\n例子：\n```\npublic class USC { \n     String method () { \n         StringBuffer s = new StringBuffer (\"Hello\"); \n         String t = s + \"World!\"; \n         return t; \n     } \n}\n```\n更正：\n\n把StringBuffer换成String，如果确定这个String不会再变的话，这将会减少运行开销提高性能。\n\n### 七、在字符串相加的时候，使用 ' ' 代替 \" \"，如果该字符串只有一个字符的话\n\n例子：\n```\npublic class STR { \n     public void method(String s) { \n         String string = s + \"d\"   // violation. \n         string = \"abc\" + \"d\"      // violation. \n     } \n}\n```\n更正：\n\n将一个字符的字符串替换成' '\n```\npublic class STR { \n     public void method(String s) { \n         String string = s + 'd' \n         string = \"abc\" + 'd'   \n     } \n}\n```\n以上仅是Java方面编程时的性能优化，性能优化大部分都是在时间、效率、代码结构层次等方面的权衡，各有利弊，不要把上面内容当成教条，或许有些对我们实际工作适用，有些不适用，还望根据实际工作场景进行取舍吧，活学活用，变通为宜。\n","slug":"2019-Java高级开发必会的50个性能优化的细节","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrl800392yku00rs7l11","content":"<blockquote>\n<p>作者：陶邦仁<br><a href=\"https://my.oschina.net/xianggao/blog/77224\">https://my.oschina.net/xianggao/blog/77224</a></p>\n</blockquote>\n<p>在JAVA程序中，性能问题的大部分原因并不在于JAVA语言，而是程序本身。养成良好的编码习惯非常重要，能够显著地提升程序性能。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-尽量在合适的场合使用单例\"><a href=\"#1-尽量在合适的场合使用单例\" class=\"headerlink\" title=\"1. 尽量在合适的场合使用单例\"></a>1. 尽量在合适的场合使用单例</h3><p>使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p>\n<p>第一，控制资源的使用，通过线程同步来控制资源的并发访问；</p>\n<p>第二，控制实例的产生，以达到节约资源的目的；</p>\n<p>第三，控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</p>\n<h3 id=\"2-尽量避免随意使用静态变量\"><a href=\"#2-尽量避免随意使用静态变量\" class=\"headerlink\" title=\"2. 尽量避免随意使用静态变量\"></a>2. 尽量避免随意使用静态变量</h3><p>要知道，当某个对象被定义为static变量所引用，那么GC通常是不会回收这个对象所占有的内存，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class A&#123; </span><br><span class=\"line\">   private static B b &#x3D; new B(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。</p>\n<h3 id=\"3-尽量避免过多过常的创建Java对象\"><a href=\"#3-尽量避免过多过常的创建Java对象\" class=\"headerlink\" title=\"3. 尽量避免过多过常的创建Java对象\"></a>3. 尽量避免过多过常的创建Java对象</h3><p>尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。</p>\n<h3 id=\"4-尽量使用final修饰符\"><a href=\"#4-尽量使用final修饰符\" class=\"headerlink\" title=\"4. 尽量使用final修饰符\"></a>4. 尽量使用final修饰符</h3><p>带有 final 修饰符的类是不可派生的。在JAVA核心API中，有许多应用 final 的例子，例如<code>java.lang.String</code>，为 String 类指定 final 防止了使用者覆盖 length() 方法。另外，如果一个类是final的，则该类所有方法都是 final 的。java编译器会寻找机会内联（inline）所有的 final 方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。</p>\n<p>如：让访问实例内变量的 getter/setter 方法变成final：</p>\n<p>简单的 getter/setter 方法应该被置成 final，这会告诉编译器，这个方法不会被重载，所以，可以变成“inlined”,例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MAF &#123; </span><br><span class=\"line\">     public void setSize (int size) &#123; </span><br><span class=\"line\">          _size &#x3D; size; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     private int _size; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class DAF_fixed &#123; </span><br><span class=\"line\">     final public void setSize (int size) &#123; </span><br><span class=\"line\">          _size &#x3D; size; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     private int _size; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-尽量使用局部变量\"><a href=\"#5-尽量使用局部变量\" class=\"headerlink\" title=\"5. 尽量使用局部变量\"></a>5. 尽量使用局部变量</h3><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。其他变量，如静态变量，实例变量等，都在堆（Heap）中创建，速度较慢。</p>\n<h3 id=\"6-尽量处理好包装类型和基本类型两者的使用场所\"><a href=\"#6-尽量处理好包装类型和基本类型两者的使用场所\" class=\"headerlink\" title=\"6. 尽量处理好包装类型和基本类型两者的使用场所\"></a>6. 尽量处理好包装类型和基本类型两者的使用场所</h3><p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。</p>\n<h3 id=\"7-慎用synchronized，尽量减小synchronize的方法\"><a href=\"#7-慎用synchronized，尽量减小synchronize的方法\" class=\"headerlink\" title=\"7. 慎用synchronized，尽量减小synchronize的方法\"></a>7. 慎用synchronized，尽量减小synchronize的方法</h3><p>都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize 方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以 synchronize 的方法尽量小，并且应尽量使用方法同步代替代码块同步。</p>\n<h3 id=\"9-尽量不要使用finalize方法\"><a href=\"#9-尽量不要使用finalize方法\" class=\"headerlink\" title=\"9. 尽量不要使用finalize方法\"></a>9. 尽量不要使用finalize方法</h3><p>实际上，将资源清理放在 finalize 方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收 Young 代内存时，大都会引起应用程序暂停，所以再选择使用 finalize 方法进行资源清理，会导致GC负担更大，程序运行效率更差。</p>\n<h3 id=\"10-尽量使用基本数据类型代替对象\"><a href=\"#10-尽量使用基本数据类型代替对象\" class=\"headerlink\" title=\"10. 尽量使用基本数据类型代替对象\"></a>10. 尽量使用基本数据类型代替对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str &#x3D; &quot;hello&quot;;</span><br></pre></td></tr></table></figure>\n<p>上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str &#x3D; new String(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>\n<p>此时程序除创建字符串外，str所引用的 String 对象底层还包含一个 char[] 数组，这个 char[] 数组依次存放了h,e,l,l,o</p>\n<h3 id=\"11-多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList\"><a href=\"#11-多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList\" class=\"headerlink\" title=\"11. 多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList\"></a>11. 多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList</h3><p>HashTable、Vector等使用了同步机制，降低了性能。</p>\n<h3 id=\"12-尽量合理的创建HashMap\"><a href=\"#12-尽量合理的创建HashMap\" class=\"headerlink\" title=\"12. 尽量合理的创建HashMap\"></a>12. 尽量合理的创建HashMap</h3><p>当你要创建一个比较大的hashMap时，充分利用这个构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public HashMap(int initialCapacity, float loadFactor);</span><br></pre></td></tr></table></figure>\n<p>避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中 initialCapacity 只有16，而 loadFactor 是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的 Hashtable，Vectors 也是一样的道理。</p>\n<h3 id=\"13-尽量减少对变量的重复计算\"><a href=\"#13-尽量减少对变量的重复计算\" class=\"headerlink\" title=\"13. 尽量减少对变量的重复计算\"></a>13. 尽量减少对变量的重复计算</h3><p>如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i&#x3D;0;i&lt;list.size();i++)</span><br></pre></td></tr></table></figure>\n<p>应该改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i&#x3D;0,len&#x3D;list.size();i&lt;len;i++)</span><br></pre></td></tr></table></figure>\n<p>并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。</p>\n<h3 id=\"14-尽量避免不必要的创建\"><a href=\"#14-尽量避免不必要的创建\" class=\"headerlink\" title=\"14. 尽量避免不必要的创建\"></a>14. 尽量避免不必要的创建</h3><p>如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a &#x3D; new A();</span><br><span class=\"line\"></span><br><span class=\"line\">if(i&#x3D;&#x3D;1)&#123;list.add(a);&#125;</span><br></pre></td></tr></table></figure>\n<p>应该改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(i&#x3D;&#x3D;1)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  A a &#x3D; new A();</span><br><span class=\"line\"></span><br><span class=\"line\">  list.add(a);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"15-尽量在finally块中释放资源\"><a href=\"#15-尽量在finally块中释放资源\" class=\"headerlink\" title=\"15. 尽量在finally块中释放资源\"></a>15. 尽量在finally块中释放资源</h3><p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在 finally 块中去做。不管程序执行的结果如何，finally 块总是会执行的，以确保资源的正确关闭。</p>\n<h3 id=\"16-尽量使用移位来代替’a-b’的操作\"><a href=\"#16-尽量使用移位来代替’a-b’的操作\" class=\"headerlink\" title=\"16. 尽量使用移位来代替’a/b’的操作\"></a>16. 尽量使用移位来代替’a/b’的操作</h3><p><code>/</code>是一个代价很高的操作，使用移位的操作将会更快和更有效</p>\n<p>如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int num &#x3D; a &#x2F; 4;</span><br><span class=\"line\"></span><br><span class=\"line\">int num &#x3D; a &#x2F; 8;</span><br></pre></td></tr></table></figure>\n<p>应该改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int num &#x3D; a &gt;&gt; 2;</span><br><span class=\"line\"></span><br><span class=\"line\">int num &#x3D; a &gt;&gt; 3;</span><br></pre></td></tr></table></figure>\n<p>但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解</p>\n<h3 id=\"17-尽量使用移位来代替’a-b’的操作\"><a href=\"#17-尽量使用移位来代替’a-b’的操作\" class=\"headerlink\" title=\"17.尽量使用移位来代替’a*b’的操作\"></a>17.尽量使用移位来代替’a*b’的操作</h3><p>同样的，对于’*’操作，使用移位的操作将会更快和更有效</p>\n<p>如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int num &#x3D; a * 4;</span><br><span class=\"line\"></span><br><span class=\"line\">int num &#x3D; a * 8;</span><br></pre></td></tr></table></figure>\n<p>应该改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int num &#x3D; a &lt;&lt; 2;</span><br><span class=\"line\"></span><br><span class=\"line\">int num &#x3D; a &lt;&lt; 3;</span><br></pre></td></tr></table></figure>\n<h3 id=\"18-尽量确定StringBuffer的容量\"><a href=\"#18-尽量确定StringBuffer的容量\" class=\"headerlink\" title=\"18. 尽量确定StringBuffer的容量\"></a>18. 尽量确定StringBuffer的容量</h3><p>StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。 </p>\n<p>如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuffer buffer &#x3D; new StringBuffer(1000);</span><br></pre></td></tr></table></figure>\n<h3 id=\"19-尽量早释放无用对象的引用\"><a href=\"#19-尽量早释放无用对象的引用\" class=\"headerlink\" title=\"19. 尽量早释放无用对象的引用\"></a>19. 尽量早释放无用对象的引用</h3><p>大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Public <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">  Object obj = <span class=\"keyword\">new</span> Object(); </span><br><span class=\"line\"></span><br><span class=\"line\">  …… </span><br><span class=\"line\"></span><br><span class=\"line\">  Obj=<span class=\"keyword\">null</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这个就没必要了，随着方法 test() 的执行完成，程序中obj引用变量的作用域就结束了。但是如果是改成下面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Public void test()&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">  Object obj &#x3D; new Object(); </span><br><span class=\"line\"></span><br><span class=\"line\">  …… </span><br><span class=\"line\"></span><br><span class=\"line\">  Obj&#x3D;null; </span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F;执行耗时，耗内存操作；或调用耗时，耗内存的方法</span><br><span class=\"line\"></span><br><span class=\"line\">  …… </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候就有必要将obj赋值为 null，可以尽早的释放对 Object 对象的引用。</p>\n<h3 id=\"20-尽量避免使用二维数组\"><a href=\"#20-尽量避免使用二维数组\" class=\"headerlink\" title=\"20. 尽量避免使用二维数组\"></a>20. 尽量避免使用二维数组</h3><p>二维数据占用的内存空间比一维数组多得多，大概10倍以上。</p>\n<h3 id=\"21-尽量避免使用split\"><a href=\"#21-尽量避免使用split\" class=\"headerlink\" title=\"21. 尽量避免使用split\"></a>21. 尽量避免使用split</h3><p>除非是必须的，否则应该避免使用 split，split 由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需要频繁的调用split，可以考虑使用 apache 的<code>StringUtils.split(string,char)</code>，频繁split的可以缓存结果。</p>\n<h3 id=\"22-ArrayList-amp-LinkedList\"><a href=\"#22-ArrayList-amp-LinkedList\" class=\"headerlink\" title=\"22. ArrayList &amp; LinkedList\"></a>22. ArrayList &amp; LinkedList</h3><p>一个是线性表，一个是链表，一句话，随机查询尽量使用 ArrayList，ArrayList 优于 LinkedList，LinkedList 还要移动指针，添加删除的操作 LinkedList 优于 ArrayList，ArrayList 还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2者得数据结构，对症下药。</p>\n<h3 id=\"23-尽量使用-System-arraycopy-代替通过来循环复制数组\"><a href=\"#23-尽量使用-System-arraycopy-代替通过来循环复制数组\" class=\"headerlink\" title=\"23. 尽量使用 System.arraycopy() 代替通过来循环复制数组\"></a>23. 尽量使用 System.arraycopy() 代替通过来循环复制数组</h3><p><code>System.arraycopy()</code>要比通过循环来复制数组快的多。</p>\n<h3 id=\"24-尽量缓存经常使用的对象\"><a href=\"#24-尽量缓存经常使用的对象\" class=\"headerlink\" title=\"24. 尽量缓存经常使用的对象\"></a>24. 尽量缓存经常使用的对象</h3><p>尽可能将经常使用的对象进行缓存，可以使用数组，或 HashMap 的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如 EhCache，Oscache 进行缓存，他们基本都实现了 FIFO/FLU 等缓存算法。</p>\n<h3 id=\"25-尽量避免非常大的内存分配\"><a href=\"#25-尽量避免非常大的内存分配\" class=\"headerlink\" title=\"25. 尽量避免非常大的内存分配\"></a>25. 尽量避免非常大的内存分配</h3><p>有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。</p>\n<h3 id=\"26-慎用异常\"><a href=\"#26-慎用异常\" class=\"headerlink\" title=\"26. 慎用异常\"></a>26. 慎用异常</h3><p>当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。</p>\n<p>如果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常。幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。</p>\n<h3 id=\"27-尽量重用对象\"><a href=\"#27-尽量重用对象\" class=\"headerlink\" title=\"27. 尽量重用对象\"></a>27. 尽量重用对象</h3><p>特别是 String 对象的使用中，出现字符串连接情况时应使用 StringBuffer 代替，由于系统不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理。因此生成过多的对象将会给程序的性能带来很大的影响。</p>\n<h3 id=\"28-不要重复初始化变量\"><a href=\"#28-不要重复初始化变量\" class=\"headerlink\" title=\"28. 不要重复初始化变量\"></a>28. 不要重复初始化变量</h3><p>默认情况下，调用类的构造函数时，java会把变量初始化成确定的值，所有的对象被设置成 null，整数变量设置成0，float 和 double 变量设置成0.0，逻辑值设置成 false。当一个类从另一个类派生时，这一点尤其应该注意，因为用 new 关键字创建一个对象时，构造函数链中的所有构造函数都会被自动调用。<br>这里有个注意，给成员变量设置初始值但需要调用其他方法的时候，最好放在一个方法比如 initXXX() 中，因为直接调用某方法赋值可能会因为类尚未初始化而抛空指针异常，如：<code>public int state = this.getState()</code>;</p>\n<h3 id=\"29-在-java-Oracle-的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。\"><a href=\"#29-在-java-Oracle-的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。\" class=\"headerlink\" title=\"29. 在 java+Oracle 的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。\"></a>29. 在 java+Oracle 的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。</h3><h3 id=\"30-在java编程过程中，进行数据库连接，I-O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。\"><a href=\"#30-在java编程过程中，进行数据库连接，I-O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。\" class=\"headerlink\" title=\"30. 在java编程过程中，进行数据库连接，I/O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。\"></a>30. 在java编程过程中，进行数据库连接，I/O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。</h3><h3 id=\"31-过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。\"><a href=\"#31-过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。\" class=\"headerlink\" title=\"31. 过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。\"></a>31. 过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。</h3><h3 id=\"32-在使用同步机制时，应尽量使用方法同步代替代码块同步。\"><a href=\"#32-在使用同步机制时，应尽量使用方法同步代替代码块同步。\" class=\"headerlink\" title=\"32. 在使用同步机制时，应尽量使用方法同步代替代码块同步。\"></a>32. 在使用同步机制时，应尽量使用方法同步代替代码块同步。</h3><h3 id=\"33-不要在循环中使用Try-Catch语句，应把Try-Catch放在循环最外层\"><a href=\"#33-不要在循环中使用Try-Catch语句，应把Try-Catch放在循环最外层\" class=\"headerlink\" title=\"33. 不要在循环中使用Try/Catch语句，应把Try/Catch放在循环最外层\"></a>33. 不要在循环中使用Try/Catch语句，应把Try/Catch放在循环最外层</h3><p>Error是获取系统错误的类，或者说是虚拟机错误的类。不是所有的错误 Exception 都能获取到的，虚拟机报错 Exception 就获取不到，必须用 Error 获取。</p>\n<h3 id=\"34-通过-StringBuffer-的构造函数来设定他的初始化容量，可以明显提升性能\"><a href=\"#34-通过-StringBuffer-的构造函数来设定他的初始化容量，可以明显提升性能\" class=\"headerlink\" title=\"34. 通过 StringBuffer 的构造函数来设定他的初始化容量，可以明显提升性能\"></a>34. 通过 StringBuffer 的构造函数来设定他的初始化容量，可以明显提升性能</h3><p>StringBuffer 的默认容量为16，当 StringBuffer 的容量达到最大容量时，她会将自身容量增加到当前的2倍+2，也就是 2*n+2。无论何时，只要 StringBuffer 到达她的最大容量，她就不得不创建一个新的对象数组，然后复制旧的对象数组，这会浪费很多时间。所以给 StringBuffer 设置一个合理的初始化容量值，是很有必要的！  </p>\n<h3 id=\"35-合理使用java-util-Vector\"><a href=\"#35-合理使用java-util-Vector\" class=\"headerlink\" title=\"35. 合理使用java.util.Vector\"></a>35. 合理使用java.util.Vector</h3><p>Vector 与 StringBuffer 类似，每次扩展容量时，所有现有元素都要赋值到新的存储空间中。Vector 的默认存储能力为10个元素，扩容加倍。<br>vector.add(index,obj) 这个方法可以将元素obj插入到 index 位置，但 index 以及之后的元素依次都要向下移动一个位置（将其索引加 1）。 除非必要，否则对性能不利。同样规则适用于 remove(int index) 方法，移除此向量中指定位置的元素。将所有后续元素左移（将其索引减 1）。返回此向量中移除的元素。所以删除vector最后一个元素要比删除第1个元素开销低很多。删除所有元素最好用 removeAllElements() 方法。<br>如果要删除 vector 里的一个元素可以使用 vector.remove(obj)；而不必自己检索元素位置，再删除，如<code>int index = indexOf(obj);vector.remove(index)</code>； </p>\n<h3 id=\"38-不用new关键字创建对象的实例\"><a href=\"#38-不用new关键字创建对象的实例\" class=\"headerlink\" title=\"38. 不用new关键字创建对象的实例\"></a>38. 不用new关键字创建对象的实例</h3><p>用new关键词创建类的实例时，构造函数链中的所有构造函数都会被自动调用。但如果一个对象实现了 Cloneable 接口，我们可以调用她的 clone() 方法。clone() 方法不会调用任何类构造函数。<br>下面是Factory模式的一个典型实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Credit getNewCredit() </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    return new Credit(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>改进后的代码使用 clone() 方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Credit BaseCredit &#x3D; new Credit(); </span><br><span class=\"line\">public static Credit getNewCredit() </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    return (Credit)BaseCredit.clone(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"39-不要将数组声明为：public-static-final\"><a href=\"#39-不要将数组声明为：public-static-final\" class=\"headerlink\" title=\"39. 不要将数组声明为：public static final\"></a>39. 不要将数组声明为：public static final</h3><h3 id=\"40-HaspMap的遍历：\"><a href=\"#40-HaspMap的遍历：\" class=\"headerlink\" title=\"40. HaspMap的遍历：\"></a>40. HaspMap的遍历：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String[]&gt; paraMap &#x3D; new HashMap&lt;String, String[]&gt;(); </span><br><span class=\"line\">for( Entry&lt;String, String[]&gt; entry : paraMap.entrySet() ) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    String appFieldDefId &#x3D; entry.getKey(); </span><br><span class=\"line\">    String[] values &#x3D; entry.getValue(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>利用散列值取出相应的 Entry 做比较得到结果，取得 entry 的值之后直接取 key 和 value。 </p>\n<h3 id=\"41-array-数组-和-ArrayList-的使用\"><a href=\"#41-array-数组-和-ArrayList-的使用\" class=\"headerlink\" title=\"41. array(数组)和 ArrayList 的使用\"></a>41. array(数组)和 ArrayList 的使用</h3><p>array 数组效率最高，但容量固定，无法动态改变，ArrayList 容量可以动态增长，但牺牲了效率。  </p>\n<h3 id=\"42-单线程应尽量使用-HashMap-ArrayList，除非必要，否则不推荐使用-HashTable-Vector，她们使用了同步机制，而降低了性能。\"><a href=\"#42-单线程应尽量使用-HashMap-ArrayList，除非必要，否则不推荐使用-HashTable-Vector，她们使用了同步机制，而降低了性能。\" class=\"headerlink\" title=\"42. 单线程应尽量使用 HashMap, ArrayList，除非必要，否则不推荐使用 HashTable,Vector，她们使用了同步机制，而降低了性能。\"></a>42. 单线程应尽量使用 HashMap, ArrayList，除非必要，否则不推荐使用 HashTable,Vector，她们使用了同步机制，而降低了性能。</h3><h3 id=\"43-StringBuffer-StringBuilder-的区别在于：\"><a href=\"#43-StringBuffer-StringBuilder-的区别在于：\" class=\"headerlink\" title=\"43. StringBuffer,StringBuilder 的区别在于：\"></a>43. StringBuffer,StringBuilder 的区别在于：</h3><p>java.lang.StringBuffer 线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。StringBuilder 与该类相比，通常应该优先使用 StringBuilder 类，因为她支持所有相同的操作，但由于她不执行同步，所以速度更快。为了获得更好的性能，在构造 StringBuffer 或 StringBuilder 时应尽量指定她的容量。当然如果不超过16个字符时就不用了。 相同情况下，使用StringBuilder比使用 StringBuffer 仅能获得10%~15%的性能提升，但却要冒多线程不安全的风险。综合考虑还是建议使用 StringBuffer。</p>\n<h3 id=\"44-尽量使用基本数据类型代替对象。\"><a href=\"#44-尽量使用基本数据类型代替对象。\" class=\"headerlink\" title=\"44. 尽量使用基本数据类型代替对象。\"></a>44. 尽量使用基本数据类型代替对象。</h3><h3 id=\"45-使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。\"><a href=\"#45-使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。\" class=\"headerlink\" title=\"45. 使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。\"></a>45. 使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。</h3><h3 id=\"46-考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。她会被更快地调用，因为她不需要一个虚拟函数导向表。这同事也是一个很好的实践，因为她告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。\"><a href=\"#46-考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。她会被更快地调用，因为她不需要一个虚拟函数导向表。这同事也是一个很好的实践，因为她告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。\" class=\"headerlink\" title=\"46. 考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。她会被更快地调用，因为她不需要一个虚拟函数导向表。这同事也是一个很好的实践，因为她告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。\"></a>46. 考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。她会被更快地调用，因为她不需要一个虚拟函数导向表。这同事也是一个很好的实践，因为她告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。</h3><h3 id=\"47-应尽可能避免使用内在的GET-SET方法。\"><a href=\"#47-应尽可能避免使用内在的GET-SET方法。\" class=\"headerlink\" title=\"47. 应尽可能避免使用内在的GET,SET方法。\"></a>47. 应尽可能避免使用内在的GET,SET方法。</h3><h3 id=\"48-避免枚举，浮点数的使用。\"><a href=\"#48-避免枚举，浮点数的使用。\" class=\"headerlink\" title=\"48.避免枚举，浮点数的使用。\"></a>48.避免枚举，浮点数的使用。</h3><p>以下举几个实用优化的例子：</p>\n<h3 id=\"一、避免在循环条件中使用复杂表达式\"><a href=\"#一、避免在循环条件中使用复杂表达式\" class=\"headerlink\" title=\"一、避免在循环条件中使用复杂表达式\"></a>一、避免在循环条件中使用复杂表达式</h3><p>在不做编译优化的情况下，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Vector; </span><br><span class=\"line\">class CEL &#123; </span><br><span class=\"line\">     void method (Vector vector) &#123; </span><br><span class=\"line\">         for (int i &#x3D; 0; i &lt; vector.size (); i++)   &#x2F;&#x2F; Violation </span><br><span class=\"line\">             ; &#x2F;&#x2F; ... </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CEL_fixed &#123; </span><br><span class=\"line\">     void method (Vector vector) &#123; </span><br><span class=\"line\">         int size &#x3D; vector.size () </span><br><span class=\"line\">         for (int i &#x3D; 0; i &lt; size; i++) </span><br><span class=\"line\">             ; &#x2F;&#x2F; ... </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、为’Vectors’-和-‘Hashtables’定义初始大小\"><a href=\"#二、为’Vectors’-和-‘Hashtables’定义初始大小\" class=\"headerlink\" title=\"二、为’Vectors’ 和 ‘Hashtables’定义初始大小\"></a>二、为’Vectors’ 和 ‘Hashtables’定义初始大小</h3><p>JVM 为 Vector 扩充大小的时候需要重新创建一个更大的数组，将原原先数组中的内容复制过来，最后，原先的数组再被回收。可见 Vector 容量的扩大是一个颇费时间的事。</p>\n<p>通常，默认的10个元素大小是不够的。你最好能准确的估计你所需要的最佳大小。例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Vector; </span><br><span class=\"line\">public class DIC &#123; </span><br><span class=\"line\">     public void addObjects (Object[] o) &#123; </span><br><span class=\"line\">         &#x2F;&#x2F; if length &gt; 10, Vector needs to expand </span><br><span class=\"line\">         for (int i &#x3D; 0; i&lt; o.length;i++) &#123;    </span><br><span class=\"line\">             v.add(o);    &#x2F;&#x2F; capacity before it can add more elements. </span><br><span class=\"line\">         &#125; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     public Vector v &#x3D; new Vector();   &#x2F;&#x2F; no initialCapacity. </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正：</p>\n<p>自己设定初始大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Vector v &#x3D; new Vector(20);  </span><br><span class=\"line\">public Hashtable hash &#x3D; new Hashtable(10);</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、在-finally-块中关闭-Stream\"><a href=\"#三、在-finally-块中关闭-Stream\" class=\"headerlink\" title=\"三、在 finally 块中关闭 Stream\"></a>三、在 finally 块中关闭 Stream</h3><p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在 finally 块中去做。不管程序执行的结果如何， finally 块总是会执行的，以确保资源的正确关闭。</p>\n<h3 id=\"四、使用’System-arraycopy-’代替通过来循环复制数组-例子：\"><a href=\"#四、使用’System-arraycopy-’代替通过来循环复制数组-例子：\" class=\"headerlink\" title=\"四、使用’System.arraycopy ()’代替通过来循环复制数组,例子：\"></a>四、使用’System.arraycopy ()’代替通过来循环复制数组,例子：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class IRB </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">     void method () &#123; </span><br><span class=\"line\">         int[] array1 &#x3D; new int [100]; </span><br><span class=\"line\">         for (int i &#x3D; 0; i &lt; array1.length; i++) &#123; </span><br><span class=\"line\">             array1 [i] &#x3D; i; </span><br><span class=\"line\">         &#125; </span><br><span class=\"line\">         int[] array2 &#x3D; new int [100]; </span><br><span class=\"line\">         for (int i &#x3D; 0; i &lt; array2.length; i++) &#123; </span><br><span class=\"line\">             array2 [i] &#x3D; array1 [i]; &#x2F;&#x2F; Violation </span><br><span class=\"line\">         &#125; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class IRB </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">     void method () &#123; </span><br><span class=\"line\">         int[] array1 &#x3D; new int [100]; </span><br><span class=\"line\">         for (int i &#x3D; 0; i &lt; array1.length; i++) &#123; </span><br><span class=\"line\">             array1 [i] &#x3D; i; </span><br><span class=\"line\">         &#125; </span><br><span class=\"line\">         int[] array2 &#x3D; new int [100]; </span><br><span class=\"line\">         System.arraycopy(array1, 0, array2, 0, 100); </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"五、让访问实例内变量的getter-setter方法变成”final”\"><a href=\"#五、让访问实例内变量的getter-setter方法变成”final”\" class=\"headerlink\" title=\"五、让访问实例内变量的getter/setter方法变成”final”\"></a>五、让访问实例内变量的getter/setter方法变成”final”</h3><p>简单的 getter/setter 方法应该被置成 final，这会告诉编译器，这个方法不会被重载，所以，可以变成”inlined”,例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MAF &#123; </span><br><span class=\"line\">     public void setSize (int size) &#123; </span><br><span class=\"line\">          _size &#x3D; size; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     private int _size; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class DAF_fixed &#123; </span><br><span class=\"line\">     final public void setSize (int size) &#123; </span><br><span class=\"line\">          _size &#x3D; size; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     private int _size; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"六、对于常量字符串，用’String’-代替-‘StringBuffer’\"><a href=\"#六、对于常量字符串，用’String’-代替-‘StringBuffer’\" class=\"headerlink\" title=\"六、对于常量字符串，用’String’ 代替 ‘StringBuffer’\"></a>六、对于常量字符串，用’String’ 代替 ‘StringBuffer’</h3><p>常量字符串并不需要动态改变长度。</p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class USC &#123; </span><br><span class=\"line\">     String method () &#123; </span><br><span class=\"line\">         StringBuffer s &#x3D; new StringBuffer (&quot;Hello&quot;); </span><br><span class=\"line\">         String t &#x3D; s + &quot;World!&quot;; </span><br><span class=\"line\">         return t; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正：</p>\n<p>把StringBuffer换成String，如果确定这个String不会再变的话，这将会减少运行开销提高性能。</p>\n<h3 id=\"七、在字符串相加的时候，使用-‘-‘-代替-“-“，如果该字符串只有一个字符的话\"><a href=\"#七、在字符串相加的时候，使用-‘-‘-代替-“-“，如果该字符串只有一个字符的话\" class=\"headerlink\" title=\"七、在字符串相加的时候，使用 ‘ ‘ 代替 “ “，如果该字符串只有一个字符的话\"></a>七、在字符串相加的时候，使用 ‘ ‘ 代替 “ “，如果该字符串只有一个字符的话</h3><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class STR &#123; </span><br><span class=\"line\">     public void method(String s) &#123; </span><br><span class=\"line\">         String string &#x3D; s + &quot;d&quot;   &#x2F;&#x2F; violation. </span><br><span class=\"line\">         string &#x3D; &quot;abc&quot; + &quot;d&quot;      &#x2F;&#x2F; violation. </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正：</p>\n<p>将一个字符的字符串替换成’ ‘</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class STR &#123; </span><br><span class=\"line\">     public void method(String s) &#123; </span><br><span class=\"line\">         String string &#x3D; s + &#39;d&#39; </span><br><span class=\"line\">         string &#x3D; &quot;abc&quot; + &#39;d&#39;   </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上仅是Java方面编程时的性能优化，性能优化大部分都是在时间、效率、代码结构层次等方面的权衡，各有利弊，不要把上面内容当成教条，或许有些对我们实际工作适用，有些不适用，还望根据实际工作场景进行取舍吧，活学活用，变通为宜。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>作者：陶邦仁<br><a href=\"https://my.oschina.net/xianggao/blog/77224\">https://my.oschina.net/xianggao/blog/77224</a></p>\n</blockquote>\n<p>在JAVA程序中，性能问题的大部分原因并不在于JAVA语言，而是程序本身。养成良好的编码习惯非常重要，能够显著地提升程序性能。</p>","more":"<h3 id=\"1-尽量在合适的场合使用单例\"><a href=\"#1-尽量在合适的场合使用单例\" class=\"headerlink\" title=\"1. 尽量在合适的场合使用单例\"></a>1. 尽量在合适的场合使用单例</h3><p>使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p>\n<p>第一，控制资源的使用，通过线程同步来控制资源的并发访问；</p>\n<p>第二，控制实例的产生，以达到节约资源的目的；</p>\n<p>第三，控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</p>\n<h3 id=\"2-尽量避免随意使用静态变量\"><a href=\"#2-尽量避免随意使用静态变量\" class=\"headerlink\" title=\"2. 尽量避免随意使用静态变量\"></a>2. 尽量避免随意使用静态变量</h3><p>要知道，当某个对象被定义为static变量所引用，那么GC通常是不会回收这个对象所占有的内存，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class A&#123; </span><br><span class=\"line\">   private static B b &#x3D; new B(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。</p>\n<h3 id=\"3-尽量避免过多过常的创建Java对象\"><a href=\"#3-尽量避免过多过常的创建Java对象\" class=\"headerlink\" title=\"3. 尽量避免过多过常的创建Java对象\"></a>3. 尽量避免过多过常的创建Java对象</h3><p>尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。</p>\n<h3 id=\"4-尽量使用final修饰符\"><a href=\"#4-尽量使用final修饰符\" class=\"headerlink\" title=\"4. 尽量使用final修饰符\"></a>4. 尽量使用final修饰符</h3><p>带有 final 修饰符的类是不可派生的。在JAVA核心API中，有许多应用 final 的例子，例如<code>java.lang.String</code>，为 String 类指定 final 防止了使用者覆盖 length() 方法。另外，如果一个类是final的，则该类所有方法都是 final 的。java编译器会寻找机会内联（inline）所有的 final 方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。</p>\n<p>如：让访问实例内变量的 getter/setter 方法变成final：</p>\n<p>简单的 getter/setter 方法应该被置成 final，这会告诉编译器，这个方法不会被重载，所以，可以变成“inlined”,例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MAF &#123; </span><br><span class=\"line\">     public void setSize (int size) &#123; </span><br><span class=\"line\">          _size &#x3D; size; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     private int _size; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class DAF_fixed &#123; </span><br><span class=\"line\">     final public void setSize (int size) &#123; </span><br><span class=\"line\">          _size &#x3D; size; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     private int _size; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-尽量使用局部变量\"><a href=\"#5-尽量使用局部变量\" class=\"headerlink\" title=\"5. 尽量使用局部变量\"></a>5. 尽量使用局部变量</h3><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。其他变量，如静态变量，实例变量等，都在堆（Heap）中创建，速度较慢。</p>\n<h3 id=\"6-尽量处理好包装类型和基本类型两者的使用场所\"><a href=\"#6-尽量处理好包装类型和基本类型两者的使用场所\" class=\"headerlink\" title=\"6. 尽量处理好包装类型和基本类型两者的使用场所\"></a>6. 尽量处理好包装类型和基本类型两者的使用场所</h3><p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。</p>\n<h3 id=\"7-慎用synchronized，尽量减小synchronize的方法\"><a href=\"#7-慎用synchronized，尽量减小synchronize的方法\" class=\"headerlink\" title=\"7. 慎用synchronized，尽量减小synchronize的方法\"></a>7. 慎用synchronized，尽量减小synchronize的方法</h3><p>都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize 方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以 synchronize 的方法尽量小，并且应尽量使用方法同步代替代码块同步。</p>\n<h3 id=\"9-尽量不要使用finalize方法\"><a href=\"#9-尽量不要使用finalize方法\" class=\"headerlink\" title=\"9. 尽量不要使用finalize方法\"></a>9. 尽量不要使用finalize方法</h3><p>实际上，将资源清理放在 finalize 方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收 Young 代内存时，大都会引起应用程序暂停，所以再选择使用 finalize 方法进行资源清理，会导致GC负担更大，程序运行效率更差。</p>\n<h3 id=\"10-尽量使用基本数据类型代替对象\"><a href=\"#10-尽量使用基本数据类型代替对象\" class=\"headerlink\" title=\"10. 尽量使用基本数据类型代替对象\"></a>10. 尽量使用基本数据类型代替对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str &#x3D; &quot;hello&quot;;</span><br></pre></td></tr></table></figure>\n<p>上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str &#x3D; new String(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>\n<p>此时程序除创建字符串外，str所引用的 String 对象底层还包含一个 char[] 数组，这个 char[] 数组依次存放了h,e,l,l,o</p>\n<h3 id=\"11-多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList\"><a href=\"#11-多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList\" class=\"headerlink\" title=\"11. 多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList\"></a>11. 多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList</h3><p>HashTable、Vector等使用了同步机制，降低了性能。</p>\n<h3 id=\"12-尽量合理的创建HashMap\"><a href=\"#12-尽量合理的创建HashMap\" class=\"headerlink\" title=\"12. 尽量合理的创建HashMap\"></a>12. 尽量合理的创建HashMap</h3><p>当你要创建一个比较大的hashMap时，充分利用这个构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public HashMap(int initialCapacity, float loadFactor);</span><br></pre></td></tr></table></figure>\n<p>避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中 initialCapacity 只有16，而 loadFactor 是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的 Hashtable，Vectors 也是一样的道理。</p>\n<h3 id=\"13-尽量减少对变量的重复计算\"><a href=\"#13-尽量减少对变量的重复计算\" class=\"headerlink\" title=\"13. 尽量减少对变量的重复计算\"></a>13. 尽量减少对变量的重复计算</h3><p>如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i&#x3D;0;i&lt;list.size();i++)</span><br></pre></td></tr></table></figure>\n<p>应该改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i&#x3D;0,len&#x3D;list.size();i&lt;len;i++)</span><br></pre></td></tr></table></figure>\n<p>并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。</p>\n<h3 id=\"14-尽量避免不必要的创建\"><a href=\"#14-尽量避免不必要的创建\" class=\"headerlink\" title=\"14. 尽量避免不必要的创建\"></a>14. 尽量避免不必要的创建</h3><p>如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a &#x3D; new A();</span><br><span class=\"line\"></span><br><span class=\"line\">if(i&#x3D;&#x3D;1)&#123;list.add(a);&#125;</span><br></pre></td></tr></table></figure>\n<p>应该改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(i&#x3D;&#x3D;1)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  A a &#x3D; new A();</span><br><span class=\"line\"></span><br><span class=\"line\">  list.add(a);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"15-尽量在finally块中释放资源\"><a href=\"#15-尽量在finally块中释放资源\" class=\"headerlink\" title=\"15. 尽量在finally块中释放资源\"></a>15. 尽量在finally块中释放资源</h3><p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在 finally 块中去做。不管程序执行的结果如何，finally 块总是会执行的，以确保资源的正确关闭。</p>\n<h3 id=\"16-尽量使用移位来代替’a-b’的操作\"><a href=\"#16-尽量使用移位来代替’a-b’的操作\" class=\"headerlink\" title=\"16. 尽量使用移位来代替’a/b’的操作\"></a>16. 尽量使用移位来代替’a/b’的操作</h3><p><code>/</code>是一个代价很高的操作，使用移位的操作将会更快和更有效</p>\n<p>如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int num &#x3D; a &#x2F; 4;</span><br><span class=\"line\"></span><br><span class=\"line\">int num &#x3D; a &#x2F; 8;</span><br></pre></td></tr></table></figure>\n<p>应该改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int num &#x3D; a &gt;&gt; 2;</span><br><span class=\"line\"></span><br><span class=\"line\">int num &#x3D; a &gt;&gt; 3;</span><br></pre></td></tr></table></figure>\n<p>但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解</p>\n<h3 id=\"17-尽量使用移位来代替’a-b’的操作\"><a href=\"#17-尽量使用移位来代替’a-b’的操作\" class=\"headerlink\" title=\"17.尽量使用移位来代替’a*b’的操作\"></a>17.尽量使用移位来代替’a*b’的操作</h3><p>同样的，对于’*’操作，使用移位的操作将会更快和更有效</p>\n<p>如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int num &#x3D; a * 4;</span><br><span class=\"line\"></span><br><span class=\"line\">int num &#x3D; a * 8;</span><br></pre></td></tr></table></figure>\n<p>应该改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int num &#x3D; a &lt;&lt; 2;</span><br><span class=\"line\"></span><br><span class=\"line\">int num &#x3D; a &lt;&lt; 3;</span><br></pre></td></tr></table></figure>\n<h3 id=\"18-尽量确定StringBuffer的容量\"><a href=\"#18-尽量确定StringBuffer的容量\" class=\"headerlink\" title=\"18. 尽量确定StringBuffer的容量\"></a>18. 尽量确定StringBuffer的容量</h3><p>StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。 </p>\n<p>如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuffer buffer &#x3D; new StringBuffer(1000);</span><br></pre></td></tr></table></figure>\n<h3 id=\"19-尽量早释放无用对象的引用\"><a href=\"#19-尽量早释放无用对象的引用\" class=\"headerlink\" title=\"19. 尽量早释放无用对象的引用\"></a>19. 尽量早释放无用对象的引用</h3><p>大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Public <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">  Object obj = <span class=\"keyword\">new</span> Object(); </span><br><span class=\"line\"></span><br><span class=\"line\">  …… </span><br><span class=\"line\"></span><br><span class=\"line\">  Obj=<span class=\"keyword\">null</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这个就没必要了，随着方法 test() 的执行完成，程序中obj引用变量的作用域就结束了。但是如果是改成下面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Public void test()&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">  Object obj &#x3D; new Object(); </span><br><span class=\"line\"></span><br><span class=\"line\">  …… </span><br><span class=\"line\"></span><br><span class=\"line\">  Obj&#x3D;null; </span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F;执行耗时，耗内存操作；或调用耗时，耗内存的方法</span><br><span class=\"line\"></span><br><span class=\"line\">  …… </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候就有必要将obj赋值为 null，可以尽早的释放对 Object 对象的引用。</p>\n<h3 id=\"20-尽量避免使用二维数组\"><a href=\"#20-尽量避免使用二维数组\" class=\"headerlink\" title=\"20. 尽量避免使用二维数组\"></a>20. 尽量避免使用二维数组</h3><p>二维数据占用的内存空间比一维数组多得多，大概10倍以上。</p>\n<h3 id=\"21-尽量避免使用split\"><a href=\"#21-尽量避免使用split\" class=\"headerlink\" title=\"21. 尽量避免使用split\"></a>21. 尽量避免使用split</h3><p>除非是必须的，否则应该避免使用 split，split 由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需要频繁的调用split，可以考虑使用 apache 的<code>StringUtils.split(string,char)</code>，频繁split的可以缓存结果。</p>\n<h3 id=\"22-ArrayList-amp-LinkedList\"><a href=\"#22-ArrayList-amp-LinkedList\" class=\"headerlink\" title=\"22. ArrayList &amp; LinkedList\"></a>22. ArrayList &amp; LinkedList</h3><p>一个是线性表，一个是链表，一句话，随机查询尽量使用 ArrayList，ArrayList 优于 LinkedList，LinkedList 还要移动指针，添加删除的操作 LinkedList 优于 ArrayList，ArrayList 还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2者得数据结构，对症下药。</p>\n<h3 id=\"23-尽量使用-System-arraycopy-代替通过来循环复制数组\"><a href=\"#23-尽量使用-System-arraycopy-代替通过来循环复制数组\" class=\"headerlink\" title=\"23. 尽量使用 System.arraycopy() 代替通过来循环复制数组\"></a>23. 尽量使用 System.arraycopy() 代替通过来循环复制数组</h3><p><code>System.arraycopy()</code>要比通过循环来复制数组快的多。</p>\n<h3 id=\"24-尽量缓存经常使用的对象\"><a href=\"#24-尽量缓存经常使用的对象\" class=\"headerlink\" title=\"24. 尽量缓存经常使用的对象\"></a>24. 尽量缓存经常使用的对象</h3><p>尽可能将经常使用的对象进行缓存，可以使用数组，或 HashMap 的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如 EhCache，Oscache 进行缓存，他们基本都实现了 FIFO/FLU 等缓存算法。</p>\n<h3 id=\"25-尽量避免非常大的内存分配\"><a href=\"#25-尽量避免非常大的内存分配\" class=\"headerlink\" title=\"25. 尽量避免非常大的内存分配\"></a>25. 尽量避免非常大的内存分配</h3><p>有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。</p>\n<h3 id=\"26-慎用异常\"><a href=\"#26-慎用异常\" class=\"headerlink\" title=\"26. 慎用异常\"></a>26. 慎用异常</h3><p>当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。</p>\n<p>如果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常。幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。</p>\n<h3 id=\"27-尽量重用对象\"><a href=\"#27-尽量重用对象\" class=\"headerlink\" title=\"27. 尽量重用对象\"></a>27. 尽量重用对象</h3><p>特别是 String 对象的使用中，出现字符串连接情况时应使用 StringBuffer 代替，由于系统不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理。因此生成过多的对象将会给程序的性能带来很大的影响。</p>\n<h3 id=\"28-不要重复初始化变量\"><a href=\"#28-不要重复初始化变量\" class=\"headerlink\" title=\"28. 不要重复初始化变量\"></a>28. 不要重复初始化变量</h3><p>默认情况下，调用类的构造函数时，java会把变量初始化成确定的值，所有的对象被设置成 null，整数变量设置成0，float 和 double 变量设置成0.0，逻辑值设置成 false。当一个类从另一个类派生时，这一点尤其应该注意，因为用 new 关键字创建一个对象时，构造函数链中的所有构造函数都会被自动调用。<br>这里有个注意，给成员变量设置初始值但需要调用其他方法的时候，最好放在一个方法比如 initXXX() 中，因为直接调用某方法赋值可能会因为类尚未初始化而抛空指针异常，如：<code>public int state = this.getState()</code>;</p>\n<h3 id=\"29-在-java-Oracle-的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。\"><a href=\"#29-在-java-Oracle-的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。\" class=\"headerlink\" title=\"29. 在 java+Oracle 的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。\"></a>29. 在 java+Oracle 的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。</h3><h3 id=\"30-在java编程过程中，进行数据库连接，I-O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。\"><a href=\"#30-在java编程过程中，进行数据库连接，I-O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。\" class=\"headerlink\" title=\"30. 在java编程过程中，进行数据库连接，I/O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。\"></a>30. 在java编程过程中，进行数据库连接，I/O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。</h3><h3 id=\"31-过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。\"><a href=\"#31-过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。\" class=\"headerlink\" title=\"31. 过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。\"></a>31. 过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。</h3><h3 id=\"32-在使用同步机制时，应尽量使用方法同步代替代码块同步。\"><a href=\"#32-在使用同步机制时，应尽量使用方法同步代替代码块同步。\" class=\"headerlink\" title=\"32. 在使用同步机制时，应尽量使用方法同步代替代码块同步。\"></a>32. 在使用同步机制时，应尽量使用方法同步代替代码块同步。</h3><h3 id=\"33-不要在循环中使用Try-Catch语句，应把Try-Catch放在循环最外层\"><a href=\"#33-不要在循环中使用Try-Catch语句，应把Try-Catch放在循环最外层\" class=\"headerlink\" title=\"33. 不要在循环中使用Try/Catch语句，应把Try/Catch放在循环最外层\"></a>33. 不要在循环中使用Try/Catch语句，应把Try/Catch放在循环最外层</h3><p>Error是获取系统错误的类，或者说是虚拟机错误的类。不是所有的错误 Exception 都能获取到的，虚拟机报错 Exception 就获取不到，必须用 Error 获取。</p>\n<h3 id=\"34-通过-StringBuffer-的构造函数来设定他的初始化容量，可以明显提升性能\"><a href=\"#34-通过-StringBuffer-的构造函数来设定他的初始化容量，可以明显提升性能\" class=\"headerlink\" title=\"34. 通过 StringBuffer 的构造函数来设定他的初始化容量，可以明显提升性能\"></a>34. 通过 StringBuffer 的构造函数来设定他的初始化容量，可以明显提升性能</h3><p>StringBuffer 的默认容量为16，当 StringBuffer 的容量达到最大容量时，她会将自身容量增加到当前的2倍+2，也就是 2*n+2。无论何时，只要 StringBuffer 到达她的最大容量，她就不得不创建一个新的对象数组，然后复制旧的对象数组，这会浪费很多时间。所以给 StringBuffer 设置一个合理的初始化容量值，是很有必要的！  </p>\n<h3 id=\"35-合理使用java-util-Vector\"><a href=\"#35-合理使用java-util-Vector\" class=\"headerlink\" title=\"35. 合理使用java.util.Vector\"></a>35. 合理使用java.util.Vector</h3><p>Vector 与 StringBuffer 类似，每次扩展容量时，所有现有元素都要赋值到新的存储空间中。Vector 的默认存储能力为10个元素，扩容加倍。<br>vector.add(index,obj) 这个方法可以将元素obj插入到 index 位置，但 index 以及之后的元素依次都要向下移动一个位置（将其索引加 1）。 除非必要，否则对性能不利。同样规则适用于 remove(int index) 方法，移除此向量中指定位置的元素。将所有后续元素左移（将其索引减 1）。返回此向量中移除的元素。所以删除vector最后一个元素要比删除第1个元素开销低很多。删除所有元素最好用 removeAllElements() 方法。<br>如果要删除 vector 里的一个元素可以使用 vector.remove(obj)；而不必自己检索元素位置，再删除，如<code>int index = indexOf(obj);vector.remove(index)</code>； </p>\n<h3 id=\"38-不用new关键字创建对象的实例\"><a href=\"#38-不用new关键字创建对象的实例\" class=\"headerlink\" title=\"38. 不用new关键字创建对象的实例\"></a>38. 不用new关键字创建对象的实例</h3><p>用new关键词创建类的实例时，构造函数链中的所有构造函数都会被自动调用。但如果一个对象实现了 Cloneable 接口，我们可以调用她的 clone() 方法。clone() 方法不会调用任何类构造函数。<br>下面是Factory模式的一个典型实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Credit getNewCredit() </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    return new Credit(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>改进后的代码使用 clone() 方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static Credit BaseCredit &#x3D; new Credit(); </span><br><span class=\"line\">public static Credit getNewCredit() </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    return (Credit)BaseCredit.clone(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"39-不要将数组声明为：public-static-final\"><a href=\"#39-不要将数组声明为：public-static-final\" class=\"headerlink\" title=\"39. 不要将数组声明为：public static final\"></a>39. 不要将数组声明为：public static final</h3><h3 id=\"40-HaspMap的遍历：\"><a href=\"#40-HaspMap的遍历：\" class=\"headerlink\" title=\"40. HaspMap的遍历：\"></a>40. HaspMap的遍历：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String[]&gt; paraMap &#x3D; new HashMap&lt;String, String[]&gt;(); </span><br><span class=\"line\">for( Entry&lt;String, String[]&gt; entry : paraMap.entrySet() ) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    String appFieldDefId &#x3D; entry.getKey(); </span><br><span class=\"line\">    String[] values &#x3D; entry.getValue(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>利用散列值取出相应的 Entry 做比较得到结果，取得 entry 的值之后直接取 key 和 value。 </p>\n<h3 id=\"41-array-数组-和-ArrayList-的使用\"><a href=\"#41-array-数组-和-ArrayList-的使用\" class=\"headerlink\" title=\"41. array(数组)和 ArrayList 的使用\"></a>41. array(数组)和 ArrayList 的使用</h3><p>array 数组效率最高，但容量固定，无法动态改变，ArrayList 容量可以动态增长，但牺牲了效率。  </p>\n<h3 id=\"42-单线程应尽量使用-HashMap-ArrayList，除非必要，否则不推荐使用-HashTable-Vector，她们使用了同步机制，而降低了性能。\"><a href=\"#42-单线程应尽量使用-HashMap-ArrayList，除非必要，否则不推荐使用-HashTable-Vector，她们使用了同步机制，而降低了性能。\" class=\"headerlink\" title=\"42. 单线程应尽量使用 HashMap, ArrayList，除非必要，否则不推荐使用 HashTable,Vector，她们使用了同步机制，而降低了性能。\"></a>42. 单线程应尽量使用 HashMap, ArrayList，除非必要，否则不推荐使用 HashTable,Vector，她们使用了同步机制，而降低了性能。</h3><h3 id=\"43-StringBuffer-StringBuilder-的区别在于：\"><a href=\"#43-StringBuffer-StringBuilder-的区别在于：\" class=\"headerlink\" title=\"43. StringBuffer,StringBuilder 的区别在于：\"></a>43. StringBuffer,StringBuilder 的区别在于：</h3><p>java.lang.StringBuffer 线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。StringBuilder 与该类相比，通常应该优先使用 StringBuilder 类，因为她支持所有相同的操作，但由于她不执行同步，所以速度更快。为了获得更好的性能，在构造 StringBuffer 或 StringBuilder 时应尽量指定她的容量。当然如果不超过16个字符时就不用了。 相同情况下，使用StringBuilder比使用 StringBuffer 仅能获得10%~15%的性能提升，但却要冒多线程不安全的风险。综合考虑还是建议使用 StringBuffer。</p>\n<h3 id=\"44-尽量使用基本数据类型代替对象。\"><a href=\"#44-尽量使用基本数据类型代替对象。\" class=\"headerlink\" title=\"44. 尽量使用基本数据类型代替对象。\"></a>44. 尽量使用基本数据类型代替对象。</h3><h3 id=\"45-使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。\"><a href=\"#45-使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。\" class=\"headerlink\" title=\"45. 使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。\"></a>45. 使用具体类比使用接口效率高，但结构弹性降低了，但现代IDE都可以解决这个问题。</h3><h3 id=\"46-考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。她会被更快地调用，因为她不需要一个虚拟函数导向表。这同事也是一个很好的实践，因为她告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。\"><a href=\"#46-考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。她会被更快地调用，因为她不需要一个虚拟函数导向表。这同事也是一个很好的实践，因为她告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。\" class=\"headerlink\" title=\"46. 考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。她会被更快地调用，因为她不需要一个虚拟函数导向表。这同事也是一个很好的实践，因为她告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。\"></a>46. 考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。她会被更快地调用，因为她不需要一个虚拟函数导向表。这同事也是一个很好的实践，因为她告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。</h3><h3 id=\"47-应尽可能避免使用内在的GET-SET方法。\"><a href=\"#47-应尽可能避免使用内在的GET-SET方法。\" class=\"headerlink\" title=\"47. 应尽可能避免使用内在的GET,SET方法。\"></a>47. 应尽可能避免使用内在的GET,SET方法。</h3><h3 id=\"48-避免枚举，浮点数的使用。\"><a href=\"#48-避免枚举，浮点数的使用。\" class=\"headerlink\" title=\"48.避免枚举，浮点数的使用。\"></a>48.避免枚举，浮点数的使用。</h3><p>以下举几个实用优化的例子：</p>\n<h3 id=\"一、避免在循环条件中使用复杂表达式\"><a href=\"#一、避免在循环条件中使用复杂表达式\" class=\"headerlink\" title=\"一、避免在循环条件中使用复杂表达式\"></a>一、避免在循环条件中使用复杂表达式</h3><p>在不做编译优化的情况下，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Vector; </span><br><span class=\"line\">class CEL &#123; </span><br><span class=\"line\">     void method (Vector vector) &#123; </span><br><span class=\"line\">         for (int i &#x3D; 0; i &lt; vector.size (); i++)   &#x2F;&#x2F; Violation </span><br><span class=\"line\">             ; &#x2F;&#x2F; ... </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CEL_fixed &#123; </span><br><span class=\"line\">     void method (Vector vector) &#123; </span><br><span class=\"line\">         int size &#x3D; vector.size () </span><br><span class=\"line\">         for (int i &#x3D; 0; i &lt; size; i++) </span><br><span class=\"line\">             ; &#x2F;&#x2F; ... </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、为’Vectors’-和-‘Hashtables’定义初始大小\"><a href=\"#二、为’Vectors’-和-‘Hashtables’定义初始大小\" class=\"headerlink\" title=\"二、为’Vectors’ 和 ‘Hashtables’定义初始大小\"></a>二、为’Vectors’ 和 ‘Hashtables’定义初始大小</h3><p>JVM 为 Vector 扩充大小的时候需要重新创建一个更大的数组，将原原先数组中的内容复制过来，最后，原先的数组再被回收。可见 Vector 容量的扩大是一个颇费时间的事。</p>\n<p>通常，默认的10个元素大小是不够的。你最好能准确的估计你所需要的最佳大小。例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Vector; </span><br><span class=\"line\">public class DIC &#123; </span><br><span class=\"line\">     public void addObjects (Object[] o) &#123; </span><br><span class=\"line\">         &#x2F;&#x2F; if length &gt; 10, Vector needs to expand </span><br><span class=\"line\">         for (int i &#x3D; 0; i&lt; o.length;i++) &#123;    </span><br><span class=\"line\">             v.add(o);    &#x2F;&#x2F; capacity before it can add more elements. </span><br><span class=\"line\">         &#125; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     public Vector v &#x3D; new Vector();   &#x2F;&#x2F; no initialCapacity. </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正：</p>\n<p>自己设定初始大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Vector v &#x3D; new Vector(20);  </span><br><span class=\"line\">public Hashtable hash &#x3D; new Hashtable(10);</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、在-finally-块中关闭-Stream\"><a href=\"#三、在-finally-块中关闭-Stream\" class=\"headerlink\" title=\"三、在 finally 块中关闭 Stream\"></a>三、在 finally 块中关闭 Stream</h3><p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在 finally 块中去做。不管程序执行的结果如何， finally 块总是会执行的，以确保资源的正确关闭。</p>\n<h3 id=\"四、使用’System-arraycopy-’代替通过来循环复制数组-例子：\"><a href=\"#四、使用’System-arraycopy-’代替通过来循环复制数组-例子：\" class=\"headerlink\" title=\"四、使用’System.arraycopy ()’代替通过来循环复制数组,例子：\"></a>四、使用’System.arraycopy ()’代替通过来循环复制数组,例子：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class IRB </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">     void method () &#123; </span><br><span class=\"line\">         int[] array1 &#x3D; new int [100]; </span><br><span class=\"line\">         for (int i &#x3D; 0; i &lt; array1.length; i++) &#123; </span><br><span class=\"line\">             array1 [i] &#x3D; i; </span><br><span class=\"line\">         &#125; </span><br><span class=\"line\">         int[] array2 &#x3D; new int [100]; </span><br><span class=\"line\">         for (int i &#x3D; 0; i &lt; array2.length; i++) &#123; </span><br><span class=\"line\">             array2 [i] &#x3D; array1 [i]; &#x2F;&#x2F; Violation </span><br><span class=\"line\">         &#125; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class IRB </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">     void method () &#123; </span><br><span class=\"line\">         int[] array1 &#x3D; new int [100]; </span><br><span class=\"line\">         for (int i &#x3D; 0; i &lt; array1.length; i++) &#123; </span><br><span class=\"line\">             array1 [i] &#x3D; i; </span><br><span class=\"line\">         &#125; </span><br><span class=\"line\">         int[] array2 &#x3D; new int [100]; </span><br><span class=\"line\">         System.arraycopy(array1, 0, array2, 0, 100); </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"五、让访问实例内变量的getter-setter方法变成”final”\"><a href=\"#五、让访问实例内变量的getter-setter方法变成”final”\" class=\"headerlink\" title=\"五、让访问实例内变量的getter/setter方法变成”final”\"></a>五、让访问实例内变量的getter/setter方法变成”final”</h3><p>简单的 getter/setter 方法应该被置成 final，这会告诉编译器，这个方法不会被重载，所以，可以变成”inlined”,例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MAF &#123; </span><br><span class=\"line\">     public void setSize (int size) &#123; </span><br><span class=\"line\">          _size &#x3D; size; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     private int _size; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class DAF_fixed &#123; </span><br><span class=\"line\">     final public void setSize (int size) &#123; </span><br><span class=\"line\">          _size &#x3D; size; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     private int _size; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"六、对于常量字符串，用’String’-代替-‘StringBuffer’\"><a href=\"#六、对于常量字符串，用’String’-代替-‘StringBuffer’\" class=\"headerlink\" title=\"六、对于常量字符串，用’String’ 代替 ‘StringBuffer’\"></a>六、对于常量字符串，用’String’ 代替 ‘StringBuffer’</h3><p>常量字符串并不需要动态改变长度。</p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class USC &#123; </span><br><span class=\"line\">     String method () &#123; </span><br><span class=\"line\">         StringBuffer s &#x3D; new StringBuffer (&quot;Hello&quot;); </span><br><span class=\"line\">         String t &#x3D; s + &quot;World!&quot;; </span><br><span class=\"line\">         return t; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正：</p>\n<p>把StringBuffer换成String，如果确定这个String不会再变的话，这将会减少运行开销提高性能。</p>\n<h3 id=\"七、在字符串相加的时候，使用-‘-‘-代替-“-“，如果该字符串只有一个字符的话\"><a href=\"#七、在字符串相加的时候，使用-‘-‘-代替-“-“，如果该字符串只有一个字符的话\" class=\"headerlink\" title=\"七、在字符串相加的时候，使用 ‘ ‘ 代替 “ “，如果该字符串只有一个字符的话\"></a>七、在字符串相加的时候，使用 ‘ ‘ 代替 “ “，如果该字符串只有一个字符的话</h3><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class STR &#123; </span><br><span class=\"line\">     public void method(String s) &#123; </span><br><span class=\"line\">         String string &#x3D; s + &quot;d&quot;   &#x2F;&#x2F; violation. </span><br><span class=\"line\">         string &#x3D; &quot;abc&quot; + &quot;d&quot;      &#x2F;&#x2F; violation. </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正：</p>\n<p>将一个字符的字符串替换成’ ‘</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class STR &#123; </span><br><span class=\"line\">     public void method(String s) &#123; </span><br><span class=\"line\">         String string &#x3D; s + &#39;d&#39; </span><br><span class=\"line\">         string &#x3D; &quot;abc&quot; + &#39;d&#39;   </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上仅是Java方面编程时的性能优化，性能优化大部分都是在时间、效率、代码结构层次等方面的权衡，各有利弊，不要把上面内容当成教条，或许有些对我们实际工作适用，有些不适用，还望根据实际工作场景进行取舍吧，活学活用，变通为宜。</p>"},{"title":"MySQL高性能优化规范建议","date":"2019-04-08T16:08:39.000Z","updated":"2019-06-19T16:00:00.000Z","_content":"\n# 一、数据库命令规范\n- 所有数据库对象名称必须使用小写字母并用下划线分割\n- 所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）\n- 数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符\n- 临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀\n- 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）\n\n<!-- more -->\n\n# 二、数据库基本设计规范\n\n## 1. 所有表必须使用 Innodb 存储引擎\n没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。\nInnodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。\n\n## 2. 数据库和表的字符集统一使用 UTF-8\n兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。\n\n## 3. 所有表和字段都需要添加注释\n使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护\n\n## 4. 尽量控制单表数据量的大小,建议控制在 500 万以内。\n500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。\n\n可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小\n\n## 5. 谨慎使用 MySQL 分区表\n分区表在物理上表现为多个文件，在逻辑上表现为一个表；\n\n谨慎选择分区键，跨分区查询效率可能更低；\n\n建议采用物理分表的方式管理大数据。\n\n## 6.尽量做到冷热数据分离,减小表的宽度\n> MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。\n\n减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）；\n\n更有效的利用缓存，避免读入无用的冷数据；\n\n经常一起使用的列放到一个表中（避免更多的关联操作）。\n\n## 7. 禁止在表中建立预留字段\n预留字段的命名很难做到见名识义。\n\n预留字段无法确认存储的数据类型，所以无法选择合适的类型。\n\n对预留字段类型的修改，会对表进行锁定。\n\n## 8. 禁止在数据库中存储图片,文件等大的二进制数据\n通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。\n\n通常存储于文件服务器，数据库只存储文件地址信息\n\n## 9. 禁止在线上做数据库压力测试\n\n## 10. 禁止从开发环境,测试环境直接连接生成环境数据库\n\n# 三、数据库字段设计规范\n\n## 1. 优先选择符合存储需要的最小的数据类型\n**原因一：**\n列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。\n\n**方法：**\n**a.将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据**\n\nMySQL 提供了两个方法来处理 ip 地址\n\n- inet_aton 把 ip 转为无符号整型 (4-8 位)\n- inet_ntoa 把整型的 ip 转为地址\n\n插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间，显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。\n\n**b.对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储**\n\n**原因二：**\n无符号相对于有符号可以多出一倍的存储空间\n\n> SIGNED INT -2147483648~2147483647\n> UNSIGNED INT 0~4294967295\n\nVARCHAR(N) 中的 N 代表的是字符数，而不是字节数，使用 UTF-8 存储 255 个汉字 Varchar(255)=765 个字节。过大的长度会消耗更多的内存。\n\n## 2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据\n**a.建议把 BLOB 或是 TEXT 列分离到单独的扩展表中**\n\nMySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。\n\n如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。\n\n**b.TEXT 或 BLOB 类型只能使用前缀索引**\n\n因为MySQL对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的\n\n## 3. 避免使用 ENUM 类型\n修改 ENUM 值需要使用 ALTER 语句\n\nENUM 类型的 ORDER BY 操作效率低，需要额外操作\n\n禁止使用数值作为 ENUM 的枚举值\n\n## 4. 尽可能把所有列定义为 NOT NULL\n索引 NULL 列需要额外的空间来保存，所以要占用更多的空间\n\n进行比较和计算时要对 NULL 值做特别的处理\n\n## 5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间\nTIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07\n\nTIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高\n\n超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储\n\n**经常会有人用字符串存储日期型的数据（不正确的做法）**\n\n- 缺点 1：无法用日期函数进行计算和比较\n- 缺点 2：用字符串存储日期要占用更多的空间\n\n## 6. 同财务相关的金额类数据必须使用 decimal 类型\n- 非精准浮点：float,double\n- 精准浮点：decimal\n\nDecimal 类型为精准浮点数，在计算时不会丢失精度\n\n占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节\n\n可用于存储比 bigint 更大的整型数据\n\n# 四、索引设计规范\n\n## 1. 限制每张表上的索引数量,建议单张表索引不超过 5 个\n索引并不是越多越好！索引可以提高效率同样可以降低效率。\n\n索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。\n\n因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。\n\n## 2. 禁止给表中的每一列都建立单独的索引\n5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。\n\n## 3. 每个 Innodb 表必须有个主键\nInnodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。\n\nInnodb 是按照主键索引的顺序来组织表的\n\n- 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）\n- 不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）\n- 主键建议使用自增 ID 值\n\n## 4. 常见索引列建议\n- 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列\n- 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段\n- 并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好\n- 多表 join 的关联列\n\n## 5. 如何选择索引列的顺序\n建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。\n\n- 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）\n- 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）\n- 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）\n\n## 6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）\n- 重复索引示例：primary key(id)、index(id)、unique index(id)\n- 冗余索引示例：index(a,b,c)、index(a,b)、index(a)\n\n## 7. 对于频繁的查询优先考虑使用覆盖索引\n> 覆盖索引：就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引\n\n覆盖索引的好处：\n- 避免 Innodb 表进行索引的二次查询: Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。\n- 可以把随机 IO 变成顺序 IO 加快查询效率: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。\n\n## 8. 索引 SET 规范\n**尽量避免使用外键约束**\n\n- 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引\n- 外键可用于保证数据的参照完整性，但建议在业务端实现\n- 外键会影响父表和子表的写操作从而降低性能\n\n# 五、数据库 SQL 开发规范\n## 1. 建议使用预编译语句进行数据库操作\n预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。\n\n只传参数，比传递 SQL 语句更高效。\n\n相同语句可以一次解析，多次使用，提高处理效率。\n\n## 2. 避免数据类型的隐式转换\n隐式转换会导致索引失效如:\n```\nselect name,phone from customer where id = '111';\n```\n\n## 3. 充分利用表上已经存在的索引\n避免使用双%号的查询条件。如：`a like '%123%'`，（如果无前置%,只有后置%，是可以用到列上的索引的）\n\n一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。\n\n在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。\n\n## 4. 数据库设计时，应该要对以后扩展进行考虑\n\n## 5. 程序连接不同的数据库使用不同的账号，进制跨库查询\n- 为数据库迁移和分库分表留出余地\n- 降低业务耦合度\n- 避免权限过大而产生的安全风险\n\n## 6. 禁止使用 SELECT * 必须使用 SELECT <字段列表> 查询\n**原因：**\n- 消耗更多的 CPU 和 IO 以网络带宽资源\n- 无法使用覆盖索引\n- 可减少表结构变更带来的影响\n\n## 7. 禁止使用不含字段列表的 INSERT 语句\n如：\n```\ninsert into values ('a','b','c');\n```\n应使用：\n```\ninsert into t(c1,c2,c3) values ('a','b','c');\n```\n\n## 8. 避免使用子查询，可以把子查询优化为 join 操作\n通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。\n\n**子查询性能差的原因：**\n子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。\n\n由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。\n\n虽然 MySQL5.6 引入了物化特性，但需要特别注意它目前仅仅针对查询语句的优化。\n对于更新或删除需要手工重写成 JOIN，来避免循环/嵌套子查询\n\n去掉 exists 更改为 join，能够避免嵌套子查询\n\n## 9. 避免使用 JOIN 关联太多的表\n对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。\n\n在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。\n\n如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。\n\n同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。\n\n## 10. 减少同数据库的交互次数\n数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。\n\n## 11. 对应同一列进行 or 判断时，使用 in 代替 or\nin 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。\n\n## 12. 禁止使用 order by rand() 进行随机排序\norder by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。\n\n推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。\n\n## 13. WHERE 从句中禁止对列进行函数转换和计算\n对列进行函数转换或计算时会导致无法使用索引\n\n**不推荐：**\n```\nwhere date(create_time)='20190101'\n```\n**推荐：**\n```\nwhere create_time >= '20190101' and create_time < '20190102'\n```\n\n14. 在明显不会有重复值时使用 UNION ALL 而不是 UNION\n- UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作\n- UNION ALL 不会再对结果集进行去重操作\n\n## 15. 拆分复杂的大 SQL 为多个小 SQL\n- 大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL\n- MySQL 中，一个 SQL 只能使用一个 CPU 进行计算\n- SQL 拆分后可以通过并行执行来提高处理效率\n\n# 六、数据库操作行为规范\n## 1. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作\n**大批量操作可能会造成严重的主从延迟**\n\n主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况\n\n**binlog 日志为 row 格式时会产生大量的日志**\n\n大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因\n\n**避免产生大事务操作**\n\n大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。\n\n特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批\n\n## 2. 对于大表使用 pt-online-schema-change 修改表结构\n- 避免大表修改产生的主从延迟\n- 避免在对表字段进行修改时进行锁表\n\n对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。\n\npt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。\n\n## 3. 禁止为程序使用的账号赋予 super 权限\n- 当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接\n- super 权限只能留给 DBA 处理问题的账号使用\n\n## 4. 对于程序连接数据库账号,遵循权限最小原则\n- 程序使用数据库账号只能在一个 DB 下使用，不准跨库\n- 程序使用的账号原则上不准有 drop 权限","source":"_posts/2019/MySQL高性能优化规范建议.md","raw":"---\ntitle: MySQL高性能优化规范建议\ndate: 2019-04-09 00:08:39\nupdated: 2019-06-20\ntags: 数据库\n---\n\n# 一、数据库命令规范\n- 所有数据库对象名称必须使用小写字母并用下划线分割\n- 所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）\n- 数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符\n- 临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀\n- 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）\n\n<!-- more -->\n\n# 二、数据库基本设计规范\n\n## 1. 所有表必须使用 Innodb 存储引擎\n没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。\nInnodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。\n\n## 2. 数据库和表的字符集统一使用 UTF-8\n兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。\n\n## 3. 所有表和字段都需要添加注释\n使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护\n\n## 4. 尽量控制单表数据量的大小,建议控制在 500 万以内。\n500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。\n\n可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小\n\n## 5. 谨慎使用 MySQL 分区表\n分区表在物理上表现为多个文件，在逻辑上表现为一个表；\n\n谨慎选择分区键，跨分区查询效率可能更低；\n\n建议采用物理分表的方式管理大数据。\n\n## 6.尽量做到冷热数据分离,减小表的宽度\n> MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。\n\n减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）；\n\n更有效的利用缓存，避免读入无用的冷数据；\n\n经常一起使用的列放到一个表中（避免更多的关联操作）。\n\n## 7. 禁止在表中建立预留字段\n预留字段的命名很难做到见名识义。\n\n预留字段无法确认存储的数据类型，所以无法选择合适的类型。\n\n对预留字段类型的修改，会对表进行锁定。\n\n## 8. 禁止在数据库中存储图片,文件等大的二进制数据\n通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。\n\n通常存储于文件服务器，数据库只存储文件地址信息\n\n## 9. 禁止在线上做数据库压力测试\n\n## 10. 禁止从开发环境,测试环境直接连接生成环境数据库\n\n# 三、数据库字段设计规范\n\n## 1. 优先选择符合存储需要的最小的数据类型\n**原因一：**\n列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。\n\n**方法：**\n**a.将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据**\n\nMySQL 提供了两个方法来处理 ip 地址\n\n- inet_aton 把 ip 转为无符号整型 (4-8 位)\n- inet_ntoa 把整型的 ip 转为地址\n\n插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间，显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。\n\n**b.对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储**\n\n**原因二：**\n无符号相对于有符号可以多出一倍的存储空间\n\n> SIGNED INT -2147483648~2147483647\n> UNSIGNED INT 0~4294967295\n\nVARCHAR(N) 中的 N 代表的是字符数，而不是字节数，使用 UTF-8 存储 255 个汉字 Varchar(255)=765 个字节。过大的长度会消耗更多的内存。\n\n## 2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据\n**a.建议把 BLOB 或是 TEXT 列分离到单独的扩展表中**\n\nMySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。\n\n如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。\n\n**b.TEXT 或 BLOB 类型只能使用前缀索引**\n\n因为MySQL对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的\n\n## 3. 避免使用 ENUM 类型\n修改 ENUM 值需要使用 ALTER 语句\n\nENUM 类型的 ORDER BY 操作效率低，需要额外操作\n\n禁止使用数值作为 ENUM 的枚举值\n\n## 4. 尽可能把所有列定义为 NOT NULL\n索引 NULL 列需要额外的空间来保存，所以要占用更多的空间\n\n进行比较和计算时要对 NULL 值做特别的处理\n\n## 5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间\nTIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07\n\nTIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高\n\n超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储\n\n**经常会有人用字符串存储日期型的数据（不正确的做法）**\n\n- 缺点 1：无法用日期函数进行计算和比较\n- 缺点 2：用字符串存储日期要占用更多的空间\n\n## 6. 同财务相关的金额类数据必须使用 decimal 类型\n- 非精准浮点：float,double\n- 精准浮点：decimal\n\nDecimal 类型为精准浮点数，在计算时不会丢失精度\n\n占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节\n\n可用于存储比 bigint 更大的整型数据\n\n# 四、索引设计规范\n\n## 1. 限制每张表上的索引数量,建议单张表索引不超过 5 个\n索引并不是越多越好！索引可以提高效率同样可以降低效率。\n\n索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。\n\n因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。\n\n## 2. 禁止给表中的每一列都建立单独的索引\n5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。\n\n## 3. 每个 Innodb 表必须有个主键\nInnodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。\n\nInnodb 是按照主键索引的顺序来组织表的\n\n- 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）\n- 不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）\n- 主键建议使用自增 ID 值\n\n## 4. 常见索引列建议\n- 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列\n- 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段\n- 并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好\n- 多表 join 的关联列\n\n## 5. 如何选择索引列的顺序\n建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。\n\n- 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）\n- 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）\n- 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）\n\n## 6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）\n- 重复索引示例：primary key(id)、index(id)、unique index(id)\n- 冗余索引示例：index(a,b,c)、index(a,b)、index(a)\n\n## 7. 对于频繁的查询优先考虑使用覆盖索引\n> 覆盖索引：就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引\n\n覆盖索引的好处：\n- 避免 Innodb 表进行索引的二次查询: Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。\n- 可以把随机 IO 变成顺序 IO 加快查询效率: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。\n\n## 8. 索引 SET 规范\n**尽量避免使用外键约束**\n\n- 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引\n- 外键可用于保证数据的参照完整性，但建议在业务端实现\n- 外键会影响父表和子表的写操作从而降低性能\n\n# 五、数据库 SQL 开发规范\n## 1. 建议使用预编译语句进行数据库操作\n预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。\n\n只传参数，比传递 SQL 语句更高效。\n\n相同语句可以一次解析，多次使用，提高处理效率。\n\n## 2. 避免数据类型的隐式转换\n隐式转换会导致索引失效如:\n```\nselect name,phone from customer where id = '111';\n```\n\n## 3. 充分利用表上已经存在的索引\n避免使用双%号的查询条件。如：`a like '%123%'`，（如果无前置%,只有后置%，是可以用到列上的索引的）\n\n一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。\n\n在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。\n\n## 4. 数据库设计时，应该要对以后扩展进行考虑\n\n## 5. 程序连接不同的数据库使用不同的账号，进制跨库查询\n- 为数据库迁移和分库分表留出余地\n- 降低业务耦合度\n- 避免权限过大而产生的安全风险\n\n## 6. 禁止使用 SELECT * 必须使用 SELECT <字段列表> 查询\n**原因：**\n- 消耗更多的 CPU 和 IO 以网络带宽资源\n- 无法使用覆盖索引\n- 可减少表结构变更带来的影响\n\n## 7. 禁止使用不含字段列表的 INSERT 语句\n如：\n```\ninsert into values ('a','b','c');\n```\n应使用：\n```\ninsert into t(c1,c2,c3) values ('a','b','c');\n```\n\n## 8. 避免使用子查询，可以把子查询优化为 join 操作\n通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。\n\n**子查询性能差的原因：**\n子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。\n\n由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。\n\n虽然 MySQL5.6 引入了物化特性，但需要特别注意它目前仅仅针对查询语句的优化。\n对于更新或删除需要手工重写成 JOIN，来避免循环/嵌套子查询\n\n去掉 exists 更改为 join，能够避免嵌套子查询\n\n## 9. 避免使用 JOIN 关联太多的表\n对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。\n\n在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。\n\n如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。\n\n同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。\n\n## 10. 减少同数据库的交互次数\n数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。\n\n## 11. 对应同一列进行 or 判断时，使用 in 代替 or\nin 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。\n\n## 12. 禁止使用 order by rand() 进行随机排序\norder by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。\n\n推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。\n\n## 13. WHERE 从句中禁止对列进行函数转换和计算\n对列进行函数转换或计算时会导致无法使用索引\n\n**不推荐：**\n```\nwhere date(create_time)='20190101'\n```\n**推荐：**\n```\nwhere create_time >= '20190101' and create_time < '20190102'\n```\n\n14. 在明显不会有重复值时使用 UNION ALL 而不是 UNION\n- UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作\n- UNION ALL 不会再对结果集进行去重操作\n\n## 15. 拆分复杂的大 SQL 为多个小 SQL\n- 大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL\n- MySQL 中，一个 SQL 只能使用一个 CPU 进行计算\n- SQL 拆分后可以通过并行执行来提高处理效率\n\n# 六、数据库操作行为规范\n## 1. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作\n**大批量操作可能会造成严重的主从延迟**\n\n主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况\n\n**binlog 日志为 row 格式时会产生大量的日志**\n\n大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因\n\n**避免产生大事务操作**\n\n大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。\n\n特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批\n\n## 2. 对于大表使用 pt-online-schema-change 修改表结构\n- 避免大表修改产生的主从延迟\n- 避免在对表字段进行修改时进行锁表\n\n对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。\n\npt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。\n\n## 3. 禁止为程序使用的账号赋予 super 权限\n- 当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接\n- super 权限只能留给 DBA 处理问题的账号使用\n\n## 4. 对于程序连接数据库账号,遵循权限最小原则\n- 程序使用数据库账号只能在一个 DB 下使用，不准跨库\n- 程序使用的账号原则上不准有 drop 权限","slug":"2019-MySQL高性能优化规范建议","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cknb3zrl9003b2yku9ndy8ac1","content":"<h1 id=\"一、数据库命令规范\"><a href=\"#一、数据库命令规范\" class=\"headerlink\" title=\"一、数据库命令规范\"></a>一、数据库命令规范</h1><ul>\n<li>所有数据库对象名称必须使用小写字母并用下划线分割</li>\n<li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li>\n<li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li>\n<li>临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀</li>\n<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li>\n</ul>\n<a id=\"more\"></a>\n\n<h1 id=\"二、数据库基本设计规范\"><a href=\"#二、数据库基本设计规范\" class=\"headerlink\" title=\"二、数据库基本设计规范\"></a>二、数据库基本设计规范</h1><h2 id=\"1-所有表必须使用-Innodb-存储引擎\"><a href=\"#1-所有表必须使用-Innodb-存储引擎\" class=\"headerlink\" title=\"1. 所有表必须使用 Innodb 存储引擎\"></a>1. 所有表必须使用 Innodb 存储引擎</h2><p>没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。<br>Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p>\n<h2 id=\"2-数据库和表的字符集统一使用-UTF-8\"><a href=\"#2-数据库和表的字符集统一使用-UTF-8\" class=\"headerlink\" title=\"2. 数据库和表的字符集统一使用 UTF-8\"></a>2. 数据库和表的字符集统一使用 UTF-8</h2><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p>\n<h2 id=\"3-所有表和字段都需要添加注释\"><a href=\"#3-所有表和字段都需要添加注释\" class=\"headerlink\" title=\"3. 所有表和字段都需要添加注释\"></a>3. 所有表和字段都需要添加注释</h2><p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p>\n<h2 id=\"4-尽量控制单表数据量的大小-建议控制在-500-万以内。\"><a href=\"#4-尽量控制单表数据量的大小-建议控制在-500-万以内。\" class=\"headerlink\" title=\"4. 尽量控制单表数据量的大小,建议控制在 500 万以内。\"></a>4. 尽量控制单表数据量的大小,建议控制在 500 万以内。</h2><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p>\n<p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>\n<h2 id=\"5-谨慎使用-MySQL-分区表\"><a href=\"#5-谨慎使用-MySQL-分区表\" class=\"headerlink\" title=\"5. 谨慎使用 MySQL 分区表\"></a>5. 谨慎使用 MySQL 分区表</h2><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p>\n<p>谨慎选择分区键，跨分区查询效率可能更低；</p>\n<p>建议采用物理分表的方式管理大数据。</p>\n<h2 id=\"6-尽量做到冷热数据分离-减小表的宽度\"><a href=\"#6-尽量做到冷热数据分离-减小表的宽度\" class=\"headerlink\" title=\"6.尽量做到冷热数据分离,减小表的宽度\"></a>6.尽量做到冷热数据分离,减小表的宽度</h2><blockquote>\n<p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。</p>\n</blockquote>\n<p>减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）；</p>\n<p>更有效的利用缓存，避免读入无用的冷数据；</p>\n<p>经常一起使用的列放到一个表中（避免更多的关联操作）。</p>\n<h2 id=\"7-禁止在表中建立预留字段\"><a href=\"#7-禁止在表中建立预留字段\" class=\"headerlink\" title=\"7. 禁止在表中建立预留字段\"></a>7. 禁止在表中建立预留字段</h2><p>预留字段的命名很难做到见名识义。</p>\n<p>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</p>\n<p>对预留字段类型的修改，会对表进行锁定。</p>\n<h2 id=\"8-禁止在数据库中存储图片-文件等大的二进制数据\"><a href=\"#8-禁止在数据库中存储图片-文件等大的二进制数据\" class=\"headerlink\" title=\"8. 禁止在数据库中存储图片,文件等大的二进制数据\"></a>8. 禁止在数据库中存储图片,文件等大的二进制数据</h2><p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。</p>\n<p>通常存储于文件服务器，数据库只存储文件地址信息</p>\n<h2 id=\"9-禁止在线上做数据库压力测试\"><a href=\"#9-禁止在线上做数据库压力测试\" class=\"headerlink\" title=\"9. 禁止在线上做数据库压力测试\"></a>9. 禁止在线上做数据库压力测试</h2><h2 id=\"10-禁止从开发环境-测试环境直接连接生成环境数据库\"><a href=\"#10-禁止从开发环境-测试环境直接连接生成环境数据库\" class=\"headerlink\" title=\"10. 禁止从开发环境,测试环境直接连接生成环境数据库\"></a>10. 禁止从开发环境,测试环境直接连接生成环境数据库</h2><h1 id=\"三、数据库字段设计规范\"><a href=\"#三、数据库字段设计规范\" class=\"headerlink\" title=\"三、数据库字段设计规范\"></a>三、数据库字段设计规范</h1><h2 id=\"1-优先选择符合存储需要的最小的数据类型\"><a href=\"#1-优先选择符合存储需要的最小的数据类型\" class=\"headerlink\" title=\"1. 优先选择符合存储需要的最小的数据类型\"></a>1. 优先选择符合存储需要的最小的数据类型</h2><p><strong>原因一：</strong><br>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。</p>\n<p><strong>方法：</strong><br><strong>a.将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</strong></p>\n<p>MySQL 提供了两个方法来处理 ip 地址</p>\n<ul>\n<li>inet_aton 把 ip 转为无符号整型 (4-8 位)</li>\n<li>inet_ntoa 把整型的 ip 转为地址</li>\n</ul>\n<p>插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间，显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。</p>\n<p><strong>b.对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储</strong></p>\n<p><strong>原因二：</strong><br>无符号相对于有符号可以多出一倍的存储空间</p>\n<blockquote>\n<p>SIGNED INT -2147483648<del>2147483647<br>UNSIGNED INT 0</del>4294967295</p>\n</blockquote>\n<p>VARCHAR(N) 中的 N 代表的是字符数，而不是字节数，使用 UTF-8 存储 255 个汉字 Varchar(255)=765 个字节。过大的长度会消耗更多的内存。</p>\n<h2 id=\"2-避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据\"><a href=\"#2-避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据\" class=\"headerlink\" title=\"2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据\"></a>2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h2><p><strong>a.建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</strong></p>\n<p>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p>\n<p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p>\n<p><strong>b.TEXT 或 BLOB 类型只能使用前缀索引</strong></p>\n<p>因为MySQL对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p>\n<h2 id=\"3-避免使用-ENUM-类型\"><a href=\"#3-避免使用-ENUM-类型\" class=\"headerlink\" title=\"3. 避免使用 ENUM 类型\"></a>3. 避免使用 ENUM 类型</h2><p>修改 ENUM 值需要使用 ALTER 语句</p>\n<p>ENUM 类型的 ORDER BY 操作效率低，需要额外操作</p>\n<p>禁止使用数值作为 ENUM 的枚举值</p>\n<h2 id=\"4-尽可能把所有列定义为-NOT-NULL\"><a href=\"#4-尽可能把所有列定义为-NOT-NULL\" class=\"headerlink\" title=\"4. 尽可能把所有列定义为 NOT NULL\"></a>4. 尽可能把所有列定义为 NOT NULL</h2><p>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间</p>\n<p>进行比较和计算时要对 NULL 值做特别的处理</p>\n<h2 id=\"5-使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间\"><a href=\"#5-使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间\" class=\"headerlink\" title=\"5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间\"></a>5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</h2><p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p>\n<p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p>\n<p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p>\n<p><strong>经常会有人用字符串存储日期型的数据（不正确的做法）</strong></p>\n<ul>\n<li>缺点 1：无法用日期函数进行计算和比较</li>\n<li>缺点 2：用字符串存储日期要占用更多的空间</li>\n</ul>\n<h2 id=\"6-同财务相关的金额类数据必须使用-decimal-类型\"><a href=\"#6-同财务相关的金额类数据必须使用-decimal-类型\" class=\"headerlink\" title=\"6. 同财务相关的金额类数据必须使用 decimal 类型\"></a>6. 同财务相关的金额类数据必须使用 decimal 类型</h2><ul>\n<li>非精准浮点：float,double</li>\n<li>精准浮点：decimal</li>\n</ul>\n<p>Decimal 类型为精准浮点数，在计算时不会丢失精度</p>\n<p>占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节</p>\n<p>可用于存储比 bigint 更大的整型数据</p>\n<h1 id=\"四、索引设计规范\"><a href=\"#四、索引设计规范\" class=\"headerlink\" title=\"四、索引设计规范\"></a>四、索引设计规范</h1><h2 id=\"1-限制每张表上的索引数量-建议单张表索引不超过-5-个\"><a href=\"#1-限制每张表上的索引数量-建议单张表索引不超过-5-个\" class=\"headerlink\" title=\"1. 限制每张表上的索引数量,建议单张表索引不超过 5 个\"></a>1. 限制每张表上的索引数量,建议单张表索引不超过 5 个</h2><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p>\n<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>\n<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>\n<h2 id=\"2-禁止给表中的每一列都建立单独的索引\"><a href=\"#2-禁止给表中的每一列都建立单独的索引\" class=\"headerlink\" title=\"2. 禁止给表中的每一列都建立单独的索引\"></a>2. 禁止给表中的每一列都建立单独的索引</h2><p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p>\n<h2 id=\"3-每个-Innodb-表必须有个主键\"><a href=\"#3-每个-Innodb-表必须有个主键\" class=\"headerlink\" title=\"3. 每个 Innodb 表必须有个主键\"></a>3. 每个 Innodb 表必须有个主键</h2><p>Innodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p>\n<p>Innodb 是按照主键索引的顺序来组织表的</p>\n<ul>\n<li>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li>\n<li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li>\n<li>主键建议使用自增 ID 值</li>\n</ul>\n<h2 id=\"4-常见索引列建议\"><a href=\"#4-常见索引列建议\" class=\"headerlink\" title=\"4. 常见索引列建议\"></a>4. 常见索引列建议</h2><ul>\n<li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li>\n<li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li>\n<li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li>\n<li>多表 join 的关联列</li>\n</ul>\n<h2 id=\"5-如何选择索引列的顺序\"><a href=\"#5-如何选择索引列的顺序\" class=\"headerlink\" title=\"5. 如何选择索引列的顺序\"></a>5. 如何选择索引列的顺序</h2><p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>\n<ul>\n<li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li>\n<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li>\n<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li>\n</ul>\n<h2 id=\"6-避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）\"><a href=\"#6-避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）\" class=\"headerlink\" title=\"6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）\"></a>6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h2><ul>\n<li>重复索引示例：primary key(id)、index(id)、unique index(id)</li>\n<li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li>\n</ul>\n<h2 id=\"7-对于频繁的查询优先考虑使用覆盖索引\"><a href=\"#7-对于频繁的查询优先考虑使用覆盖索引\" class=\"headerlink\" title=\"7. 对于频繁的查询优先考虑使用覆盖索引\"></a>7. 对于频繁的查询优先考虑使用覆盖索引</h2><blockquote>\n<p>覆盖索引：就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引</p>\n</blockquote>\n<p>覆盖索引的好处：</p>\n<ul>\n<li>避免 Innodb 表进行索引的二次查询: Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li>\n<li>可以把随机 IO 变成顺序 IO 加快查询效率: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li>\n</ul>\n<h2 id=\"8-索引-SET-规范\"><a href=\"#8-索引-SET-规范\" class=\"headerlink\" title=\"8. 索引 SET 规范\"></a>8. 索引 SET 规范</h2><p><strong>尽量避免使用外键约束</strong></p>\n<ul>\n<li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li>\n<li>外键可用于保证数据的参照完整性，但建议在业务端实现</li>\n<li>外键会影响父表和子表的写操作从而降低性能</li>\n</ul>\n<h1 id=\"五、数据库-SQL-开发规范\"><a href=\"#五、数据库-SQL-开发规范\" class=\"headerlink\" title=\"五、数据库 SQL 开发规范\"></a>五、数据库 SQL 开发规范</h1><h2 id=\"1-建议使用预编译语句进行数据库操作\"><a href=\"#1-建议使用预编译语句进行数据库操作\" class=\"headerlink\" title=\"1. 建议使用预编译语句进行数据库操作\"></a>1. 建议使用预编译语句进行数据库操作</h2><p>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</p>\n<p>只传参数，比传递 SQL 语句更高效。</p>\n<p>相同语句可以一次解析，多次使用，提高处理效率。</p>\n<h2 id=\"2-避免数据类型的隐式转换\"><a href=\"#2-避免数据类型的隐式转换\" class=\"headerlink\" title=\"2. 避免数据类型的隐式转换\"></a>2. 避免数据类型的隐式转换</h2><p>隐式转换会导致索引失效如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name,phone from customer where id &#x3D; &#39;111&#39;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-充分利用表上已经存在的索引\"><a href=\"#3-充分利用表上已经存在的索引\" class=\"headerlink\" title=\"3. 充分利用表上已经存在的索引\"></a>3. 充分利用表上已经存在的索引</h2><p>避免使用双%号的查询条件。如：<code>a like &#39;%123%&#39;</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p>\n<p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p>\n<p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p>\n<h2 id=\"4-数据库设计时，应该要对以后扩展进行考虑\"><a href=\"#4-数据库设计时，应该要对以后扩展进行考虑\" class=\"headerlink\" title=\"4. 数据库设计时，应该要对以后扩展进行考虑\"></a>4. 数据库设计时，应该要对以后扩展进行考虑</h2><h2 id=\"5-程序连接不同的数据库使用不同的账号，进制跨库查询\"><a href=\"#5-程序连接不同的数据库使用不同的账号，进制跨库查询\" class=\"headerlink\" title=\"5. 程序连接不同的数据库使用不同的账号，进制跨库查询\"></a>5. 程序连接不同的数据库使用不同的账号，进制跨库查询</h2><ul>\n<li>为数据库迁移和分库分表留出余地</li>\n<li>降低业务耦合度</li>\n<li>避免权限过大而产生的安全风险</li>\n</ul>\n<h2 id=\"6-禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询\"><a href=\"#6-禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询\" class=\"headerlink\" title=\"6. 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询\"></a>6. 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h2><p><strong>原因：</strong></p>\n<ul>\n<li>消耗更多的 CPU 和 IO 以网络带宽资源</li>\n<li>无法使用覆盖索引</li>\n<li>可减少表结构变更带来的影响</li>\n</ul>\n<h2 id=\"7-禁止使用不含字段列表的-INSERT-语句\"><a href=\"#7-禁止使用不含字段列表的-INSERT-语句\" class=\"headerlink\" title=\"7. 禁止使用不含字段列表的 INSERT 语句\"></a>7. 禁止使用不含字段列表的 INSERT 语句</h2><p>如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</span><br></pre></td></tr></table></figure>\n<p>应使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into t(c1,c2,c3) values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-避免使用子查询，可以把子查询优化为-join-操作\"><a href=\"#8-避免使用子查询，可以把子查询优化为-join-操作\" class=\"headerlink\" title=\"8. 避免使用子查询，可以把子查询优化为 join 操作\"></a>8. 避免使用子查询，可以把子查询优化为 join 操作</h2><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p>\n<p><strong>子查询性能差的原因：</strong><br>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>\n<p>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p>\n<p>虽然 MySQL5.6 引入了物化特性，但需要特别注意它目前仅仅针对查询语句的优化。<br>对于更新或删除需要手工重写成 JOIN，来避免循环/嵌套子查询</p>\n<p>去掉 exists 更改为 join，能够避免嵌套子查询</p>\n<h2 id=\"9-避免使用-JOIN-关联太多的表\"><a href=\"#9-避免使用-JOIN-关联太多的表\" class=\"headerlink\" title=\"9. 避免使用 JOIN 关联太多的表\"></a>9. 避免使用 JOIN 关联太多的表</h2><p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p>\n<p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p>\n<p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p>\n<p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p>\n<h2 id=\"10-减少同数据库的交互次数\"><a href=\"#10-减少同数据库的交互次数\" class=\"headerlink\" title=\"10. 减少同数据库的交互次数\"></a>10. 减少同数据库的交互次数</h2><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p>\n<h2 id=\"11-对应同一列进行-or-判断时，使用-in-代替-or\"><a href=\"#11-对应同一列进行-or-判断时，使用-in-代替-or\" class=\"headerlink\" title=\"11. 对应同一列进行 or 判断时，使用 in 代替 or\"></a>11. 对应同一列进行 or 判断时，使用 in 代替 or</h2><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p>\n<h2 id=\"12-禁止使用-order-by-rand-进行随机排序\"><a href=\"#12-禁止使用-order-by-rand-进行随机排序\" class=\"headerlink\" title=\"12. 禁止使用 order by rand() 进行随机排序\"></a>12. 禁止使用 order by rand() 进行随机排序</h2><p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p>\n<p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p>\n<h2 id=\"13-WHERE-从句中禁止对列进行函数转换和计算\"><a href=\"#13-WHERE-从句中禁止对列进行函数转换和计算\" class=\"headerlink\" title=\"13. WHERE 从句中禁止对列进行函数转换和计算\"></a>13. WHERE 从句中禁止对列进行函数转换和计算</h2><p>对列进行函数转换或计算时会导致无法使用索引</p>\n<p><strong>不推荐：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">where date(create_time)&#x3D;&#39;20190101&#39;</span><br></pre></td></tr></table></figure>\n<p><strong>推荐：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">where create_time &gt;&#x3D; &#39;20190101&#39; and create_time &lt; &#39;20190102&#39;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"14\">\n<li>在明显不会有重复值时使用 UNION ALL 而不是 UNION</li>\n</ol>\n<ul>\n<li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li>\n<li>UNION ALL 不会再对结果集进行去重操作</li>\n</ul>\n<h2 id=\"15-拆分复杂的大-SQL-为多个小-SQL\"><a href=\"#15-拆分复杂的大-SQL-为多个小-SQL\" class=\"headerlink\" title=\"15. 拆分复杂的大 SQL 为多个小 SQL\"></a>15. 拆分复杂的大 SQL 为多个小 SQL</h2><ul>\n<li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li>\n<li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li>\n<li>SQL 拆分后可以通过并行执行来提高处理效率</li>\n</ul>\n<h1 id=\"六、数据库操作行为规范\"><a href=\"#六、数据库操作行为规范\" class=\"headerlink\" title=\"六、数据库操作行为规范\"></a>六、数据库操作行为规范</h1><h2 id=\"1-超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作\"><a href=\"#1-超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作\" class=\"headerlink\" title=\"1. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作\"></a>1. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h2><p><strong>大批量操作可能会造成严重的主从延迟</strong></p>\n<p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>\n<p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p>\n<p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>\n<p><strong>避免产生大事务操作</strong></p>\n<p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p>\n<p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>\n<h2 id=\"2-对于大表使用-pt-online-schema-change-修改表结构\"><a href=\"#2-对于大表使用-pt-online-schema-change-修改表结构\" class=\"headerlink\" title=\"2. 对于大表使用 pt-online-schema-change 修改表结构\"></a>2. 对于大表使用 pt-online-schema-change 修改表结构</h2><ul>\n<li>避免大表修改产生的主从延迟</li>\n<li>避免在对表字段进行修改时进行锁表</li>\n</ul>\n<p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p>\n<p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p>\n<h2 id=\"3-禁止为程序使用的账号赋予-super-权限\"><a href=\"#3-禁止为程序使用的账号赋予-super-权限\" class=\"headerlink\" title=\"3. 禁止为程序使用的账号赋予 super 权限\"></a>3. 禁止为程序使用的账号赋予 super 权限</h2><ul>\n<li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li>\n<li>super 权限只能留给 DBA 处理问题的账号使用</li>\n</ul>\n<h2 id=\"4-对于程序连接数据库账号-遵循权限最小原则\"><a href=\"#4-对于程序连接数据库账号-遵循权限最小原则\" class=\"headerlink\" title=\"4. 对于程序连接数据库账号,遵循权限最小原则\"></a>4. 对于程序连接数据库账号,遵循权限最小原则</h2><ul>\n<li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li>\n<li>程序使用的账号原则上不准有 drop 权限</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、数据库命令规范\"><a href=\"#一、数据库命令规范\" class=\"headerlink\" title=\"一、数据库命令规范\"></a>一、数据库命令规范</h1><ul>\n<li>所有数据库对象名称必须使用小写字母并用下划线分割</li>\n<li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li>\n<li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li>\n<li>临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀</li>\n<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li>\n</ul>","more":"<h1 id=\"二、数据库基本设计规范\"><a href=\"#二、数据库基本设计规范\" class=\"headerlink\" title=\"二、数据库基本设计规范\"></a>二、数据库基本设计规范</h1><h2 id=\"1-所有表必须使用-Innodb-存储引擎\"><a href=\"#1-所有表必须使用-Innodb-存储引擎\" class=\"headerlink\" title=\"1. 所有表必须使用 Innodb 存储引擎\"></a>1. 所有表必须使用 Innodb 存储引擎</h2><p>没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。<br>Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p>\n<h2 id=\"2-数据库和表的字符集统一使用-UTF-8\"><a href=\"#2-数据库和表的字符集统一使用-UTF-8\" class=\"headerlink\" title=\"2. 数据库和表的字符集统一使用 UTF-8\"></a>2. 数据库和表的字符集统一使用 UTF-8</h2><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p>\n<h2 id=\"3-所有表和字段都需要添加注释\"><a href=\"#3-所有表和字段都需要添加注释\" class=\"headerlink\" title=\"3. 所有表和字段都需要添加注释\"></a>3. 所有表和字段都需要添加注释</h2><p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p>\n<h2 id=\"4-尽量控制单表数据量的大小-建议控制在-500-万以内。\"><a href=\"#4-尽量控制单表数据量的大小-建议控制在-500-万以内。\" class=\"headerlink\" title=\"4. 尽量控制单表数据量的大小,建议控制在 500 万以内。\"></a>4. 尽量控制单表数据量的大小,建议控制在 500 万以内。</h2><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p>\n<p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>\n<h2 id=\"5-谨慎使用-MySQL-分区表\"><a href=\"#5-谨慎使用-MySQL-分区表\" class=\"headerlink\" title=\"5. 谨慎使用 MySQL 分区表\"></a>5. 谨慎使用 MySQL 分区表</h2><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p>\n<p>谨慎选择分区键，跨分区查询效率可能更低；</p>\n<p>建议采用物理分表的方式管理大数据。</p>\n<h2 id=\"6-尽量做到冷热数据分离-减小表的宽度\"><a href=\"#6-尽量做到冷热数据分离-减小表的宽度\" class=\"headerlink\" title=\"6.尽量做到冷热数据分离,减小表的宽度\"></a>6.尽量做到冷热数据分离,减小表的宽度</h2><blockquote>\n<p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。</p>\n</blockquote>\n<p>减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）；</p>\n<p>更有效的利用缓存，避免读入无用的冷数据；</p>\n<p>经常一起使用的列放到一个表中（避免更多的关联操作）。</p>\n<h2 id=\"7-禁止在表中建立预留字段\"><a href=\"#7-禁止在表中建立预留字段\" class=\"headerlink\" title=\"7. 禁止在表中建立预留字段\"></a>7. 禁止在表中建立预留字段</h2><p>预留字段的命名很难做到见名识义。</p>\n<p>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</p>\n<p>对预留字段类型的修改，会对表进行锁定。</p>\n<h2 id=\"8-禁止在数据库中存储图片-文件等大的二进制数据\"><a href=\"#8-禁止在数据库中存储图片-文件等大的二进制数据\" class=\"headerlink\" title=\"8. 禁止在数据库中存储图片,文件等大的二进制数据\"></a>8. 禁止在数据库中存储图片,文件等大的二进制数据</h2><p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。</p>\n<p>通常存储于文件服务器，数据库只存储文件地址信息</p>\n<h2 id=\"9-禁止在线上做数据库压力测试\"><a href=\"#9-禁止在线上做数据库压力测试\" class=\"headerlink\" title=\"9. 禁止在线上做数据库压力测试\"></a>9. 禁止在线上做数据库压力测试</h2><h2 id=\"10-禁止从开发环境-测试环境直接连接生成环境数据库\"><a href=\"#10-禁止从开发环境-测试环境直接连接生成环境数据库\" class=\"headerlink\" title=\"10. 禁止从开发环境,测试环境直接连接生成环境数据库\"></a>10. 禁止从开发环境,测试环境直接连接生成环境数据库</h2><h1 id=\"三、数据库字段设计规范\"><a href=\"#三、数据库字段设计规范\" class=\"headerlink\" title=\"三、数据库字段设计规范\"></a>三、数据库字段设计规范</h1><h2 id=\"1-优先选择符合存储需要的最小的数据类型\"><a href=\"#1-优先选择符合存储需要的最小的数据类型\" class=\"headerlink\" title=\"1. 优先选择符合存储需要的最小的数据类型\"></a>1. 优先选择符合存储需要的最小的数据类型</h2><p><strong>原因一：</strong><br>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。</p>\n<p><strong>方法：</strong><br><strong>a.将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</strong></p>\n<p>MySQL 提供了两个方法来处理 ip 地址</p>\n<ul>\n<li>inet_aton 把 ip 转为无符号整型 (4-8 位)</li>\n<li>inet_ntoa 把整型的 ip 转为地址</li>\n</ul>\n<p>插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间，显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。</p>\n<p><strong>b.对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储</strong></p>\n<p><strong>原因二：</strong><br>无符号相对于有符号可以多出一倍的存储空间</p>\n<blockquote>\n<p>SIGNED INT -2147483648<del>2147483647<br>UNSIGNED INT 0</del>4294967295</p>\n</blockquote>\n<p>VARCHAR(N) 中的 N 代表的是字符数，而不是字节数，使用 UTF-8 存储 255 个汉字 Varchar(255)=765 个字节。过大的长度会消耗更多的内存。</p>\n<h2 id=\"2-避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据\"><a href=\"#2-避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据\" class=\"headerlink\" title=\"2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据\"></a>2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h2><p><strong>a.建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</strong></p>\n<p>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p>\n<p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p>\n<p><strong>b.TEXT 或 BLOB 类型只能使用前缀索引</strong></p>\n<p>因为MySQL对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p>\n<h2 id=\"3-避免使用-ENUM-类型\"><a href=\"#3-避免使用-ENUM-类型\" class=\"headerlink\" title=\"3. 避免使用 ENUM 类型\"></a>3. 避免使用 ENUM 类型</h2><p>修改 ENUM 值需要使用 ALTER 语句</p>\n<p>ENUM 类型的 ORDER BY 操作效率低，需要额外操作</p>\n<p>禁止使用数值作为 ENUM 的枚举值</p>\n<h2 id=\"4-尽可能把所有列定义为-NOT-NULL\"><a href=\"#4-尽可能把所有列定义为-NOT-NULL\" class=\"headerlink\" title=\"4. 尽可能把所有列定义为 NOT NULL\"></a>4. 尽可能把所有列定义为 NOT NULL</h2><p>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间</p>\n<p>进行比较和计算时要对 NULL 值做特别的处理</p>\n<h2 id=\"5-使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间\"><a href=\"#5-使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间\" class=\"headerlink\" title=\"5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间\"></a>5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</h2><p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p>\n<p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p>\n<p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p>\n<p><strong>经常会有人用字符串存储日期型的数据（不正确的做法）</strong></p>\n<ul>\n<li>缺点 1：无法用日期函数进行计算和比较</li>\n<li>缺点 2：用字符串存储日期要占用更多的空间</li>\n</ul>\n<h2 id=\"6-同财务相关的金额类数据必须使用-decimal-类型\"><a href=\"#6-同财务相关的金额类数据必须使用-decimal-类型\" class=\"headerlink\" title=\"6. 同财务相关的金额类数据必须使用 decimal 类型\"></a>6. 同财务相关的金额类数据必须使用 decimal 类型</h2><ul>\n<li>非精准浮点：float,double</li>\n<li>精准浮点：decimal</li>\n</ul>\n<p>Decimal 类型为精准浮点数，在计算时不会丢失精度</p>\n<p>占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节</p>\n<p>可用于存储比 bigint 更大的整型数据</p>\n<h1 id=\"四、索引设计规范\"><a href=\"#四、索引设计规范\" class=\"headerlink\" title=\"四、索引设计规范\"></a>四、索引设计规范</h1><h2 id=\"1-限制每张表上的索引数量-建议单张表索引不超过-5-个\"><a href=\"#1-限制每张表上的索引数量-建议单张表索引不超过-5-个\" class=\"headerlink\" title=\"1. 限制每张表上的索引数量,建议单张表索引不超过 5 个\"></a>1. 限制每张表上的索引数量,建议单张表索引不超过 5 个</h2><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p>\n<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>\n<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>\n<h2 id=\"2-禁止给表中的每一列都建立单独的索引\"><a href=\"#2-禁止给表中的每一列都建立单独的索引\" class=\"headerlink\" title=\"2. 禁止给表中的每一列都建立单独的索引\"></a>2. 禁止给表中的每一列都建立单独的索引</h2><p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p>\n<h2 id=\"3-每个-Innodb-表必须有个主键\"><a href=\"#3-每个-Innodb-表必须有个主键\" class=\"headerlink\" title=\"3. 每个 Innodb 表必须有个主键\"></a>3. 每个 Innodb 表必须有个主键</h2><p>Innodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p>\n<p>Innodb 是按照主键索引的顺序来组织表的</p>\n<ul>\n<li>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li>\n<li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li>\n<li>主键建议使用自增 ID 值</li>\n</ul>\n<h2 id=\"4-常见索引列建议\"><a href=\"#4-常见索引列建议\" class=\"headerlink\" title=\"4. 常见索引列建议\"></a>4. 常见索引列建议</h2><ul>\n<li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li>\n<li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li>\n<li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li>\n<li>多表 join 的关联列</li>\n</ul>\n<h2 id=\"5-如何选择索引列的顺序\"><a href=\"#5-如何选择索引列的顺序\" class=\"headerlink\" title=\"5. 如何选择索引列的顺序\"></a>5. 如何选择索引列的顺序</h2><p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>\n<ul>\n<li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li>\n<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li>\n<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li>\n</ul>\n<h2 id=\"6-避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）\"><a href=\"#6-避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）\" class=\"headerlink\" title=\"6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）\"></a>6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h2><ul>\n<li>重复索引示例：primary key(id)、index(id)、unique index(id)</li>\n<li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li>\n</ul>\n<h2 id=\"7-对于频繁的查询优先考虑使用覆盖索引\"><a href=\"#7-对于频繁的查询优先考虑使用覆盖索引\" class=\"headerlink\" title=\"7. 对于频繁的查询优先考虑使用覆盖索引\"></a>7. 对于频繁的查询优先考虑使用覆盖索引</h2><blockquote>\n<p>覆盖索引：就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引</p>\n</blockquote>\n<p>覆盖索引的好处：</p>\n<ul>\n<li>避免 Innodb 表进行索引的二次查询: Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li>\n<li>可以把随机 IO 变成顺序 IO 加快查询效率: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li>\n</ul>\n<h2 id=\"8-索引-SET-规范\"><a href=\"#8-索引-SET-规范\" class=\"headerlink\" title=\"8. 索引 SET 规范\"></a>8. 索引 SET 规范</h2><p><strong>尽量避免使用外键约束</strong></p>\n<ul>\n<li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li>\n<li>外键可用于保证数据的参照完整性，但建议在业务端实现</li>\n<li>外键会影响父表和子表的写操作从而降低性能</li>\n</ul>\n<h1 id=\"五、数据库-SQL-开发规范\"><a href=\"#五、数据库-SQL-开发规范\" class=\"headerlink\" title=\"五、数据库 SQL 开发规范\"></a>五、数据库 SQL 开发规范</h1><h2 id=\"1-建议使用预编译语句进行数据库操作\"><a href=\"#1-建议使用预编译语句进行数据库操作\" class=\"headerlink\" title=\"1. 建议使用预编译语句进行数据库操作\"></a>1. 建议使用预编译语句进行数据库操作</h2><p>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</p>\n<p>只传参数，比传递 SQL 语句更高效。</p>\n<p>相同语句可以一次解析，多次使用，提高处理效率。</p>\n<h2 id=\"2-避免数据类型的隐式转换\"><a href=\"#2-避免数据类型的隐式转换\" class=\"headerlink\" title=\"2. 避免数据类型的隐式转换\"></a>2. 避免数据类型的隐式转换</h2><p>隐式转换会导致索引失效如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name,phone from customer where id &#x3D; &#39;111&#39;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-充分利用表上已经存在的索引\"><a href=\"#3-充分利用表上已经存在的索引\" class=\"headerlink\" title=\"3. 充分利用表上已经存在的索引\"></a>3. 充分利用表上已经存在的索引</h2><p>避免使用双%号的查询条件。如：<code>a like &#39;%123%&#39;</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p>\n<p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p>\n<p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p>\n<h2 id=\"4-数据库设计时，应该要对以后扩展进行考虑\"><a href=\"#4-数据库设计时，应该要对以后扩展进行考虑\" class=\"headerlink\" title=\"4. 数据库设计时，应该要对以后扩展进行考虑\"></a>4. 数据库设计时，应该要对以后扩展进行考虑</h2><h2 id=\"5-程序连接不同的数据库使用不同的账号，进制跨库查询\"><a href=\"#5-程序连接不同的数据库使用不同的账号，进制跨库查询\" class=\"headerlink\" title=\"5. 程序连接不同的数据库使用不同的账号，进制跨库查询\"></a>5. 程序连接不同的数据库使用不同的账号，进制跨库查询</h2><ul>\n<li>为数据库迁移和分库分表留出余地</li>\n<li>降低业务耦合度</li>\n<li>避免权限过大而产生的安全风险</li>\n</ul>\n<h2 id=\"6-禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询\"><a href=\"#6-禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询\" class=\"headerlink\" title=\"6. 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询\"></a>6. 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h2><p><strong>原因：</strong></p>\n<ul>\n<li>消耗更多的 CPU 和 IO 以网络带宽资源</li>\n<li>无法使用覆盖索引</li>\n<li>可减少表结构变更带来的影响</li>\n</ul>\n<h2 id=\"7-禁止使用不含字段列表的-INSERT-语句\"><a href=\"#7-禁止使用不含字段列表的-INSERT-语句\" class=\"headerlink\" title=\"7. 禁止使用不含字段列表的 INSERT 语句\"></a>7. 禁止使用不含字段列表的 INSERT 语句</h2><p>如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</span><br></pre></td></tr></table></figure>\n<p>应使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into t(c1,c2,c3) values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-避免使用子查询，可以把子查询优化为-join-操作\"><a href=\"#8-避免使用子查询，可以把子查询优化为-join-操作\" class=\"headerlink\" title=\"8. 避免使用子查询，可以把子查询优化为 join 操作\"></a>8. 避免使用子查询，可以把子查询优化为 join 操作</h2><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p>\n<p><strong>子查询性能差的原因：</strong><br>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>\n<p>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p>\n<p>虽然 MySQL5.6 引入了物化特性，但需要特别注意它目前仅仅针对查询语句的优化。<br>对于更新或删除需要手工重写成 JOIN，来避免循环/嵌套子查询</p>\n<p>去掉 exists 更改为 join，能够避免嵌套子查询</p>\n<h2 id=\"9-避免使用-JOIN-关联太多的表\"><a href=\"#9-避免使用-JOIN-关联太多的表\" class=\"headerlink\" title=\"9. 避免使用 JOIN 关联太多的表\"></a>9. 避免使用 JOIN 关联太多的表</h2><p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p>\n<p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p>\n<p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p>\n<p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p>\n<h2 id=\"10-减少同数据库的交互次数\"><a href=\"#10-减少同数据库的交互次数\" class=\"headerlink\" title=\"10. 减少同数据库的交互次数\"></a>10. 减少同数据库的交互次数</h2><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p>\n<h2 id=\"11-对应同一列进行-or-判断时，使用-in-代替-or\"><a href=\"#11-对应同一列进行-or-判断时，使用-in-代替-or\" class=\"headerlink\" title=\"11. 对应同一列进行 or 判断时，使用 in 代替 or\"></a>11. 对应同一列进行 or 判断时，使用 in 代替 or</h2><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p>\n<h2 id=\"12-禁止使用-order-by-rand-进行随机排序\"><a href=\"#12-禁止使用-order-by-rand-进行随机排序\" class=\"headerlink\" title=\"12. 禁止使用 order by rand() 进行随机排序\"></a>12. 禁止使用 order by rand() 进行随机排序</h2><p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p>\n<p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p>\n<h2 id=\"13-WHERE-从句中禁止对列进行函数转换和计算\"><a href=\"#13-WHERE-从句中禁止对列进行函数转换和计算\" class=\"headerlink\" title=\"13. WHERE 从句中禁止对列进行函数转换和计算\"></a>13. WHERE 从句中禁止对列进行函数转换和计算</h2><p>对列进行函数转换或计算时会导致无法使用索引</p>\n<p><strong>不推荐：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">where date(create_time)&#x3D;&#39;20190101&#39;</span><br></pre></td></tr></table></figure>\n<p><strong>推荐：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">where create_time &gt;&#x3D; &#39;20190101&#39; and create_time &lt; &#39;20190102&#39;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"14\">\n<li>在明显不会有重复值时使用 UNION ALL 而不是 UNION</li>\n</ol>\n<ul>\n<li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li>\n<li>UNION ALL 不会再对结果集进行去重操作</li>\n</ul>\n<h2 id=\"15-拆分复杂的大-SQL-为多个小-SQL\"><a href=\"#15-拆分复杂的大-SQL-为多个小-SQL\" class=\"headerlink\" title=\"15. 拆分复杂的大 SQL 为多个小 SQL\"></a>15. 拆分复杂的大 SQL 为多个小 SQL</h2><ul>\n<li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li>\n<li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li>\n<li>SQL 拆分后可以通过并行执行来提高处理效率</li>\n</ul>\n<h1 id=\"六、数据库操作行为规范\"><a href=\"#六、数据库操作行为规范\" class=\"headerlink\" title=\"六、数据库操作行为规范\"></a>六、数据库操作行为规范</h1><h2 id=\"1-超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作\"><a href=\"#1-超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作\" class=\"headerlink\" title=\"1. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作\"></a>1. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h2><p><strong>大批量操作可能会造成严重的主从延迟</strong></p>\n<p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>\n<p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p>\n<p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>\n<p><strong>避免产生大事务操作</strong></p>\n<p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p>\n<p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>\n<h2 id=\"2-对于大表使用-pt-online-schema-change-修改表结构\"><a href=\"#2-对于大表使用-pt-online-schema-change-修改表结构\" class=\"headerlink\" title=\"2. 对于大表使用 pt-online-schema-change 修改表结构\"></a>2. 对于大表使用 pt-online-schema-change 修改表结构</h2><ul>\n<li>避免大表修改产生的主从延迟</li>\n<li>避免在对表字段进行修改时进行锁表</li>\n</ul>\n<p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p>\n<p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p>\n<h2 id=\"3-禁止为程序使用的账号赋予-super-权限\"><a href=\"#3-禁止为程序使用的账号赋予-super-权限\" class=\"headerlink\" title=\"3. 禁止为程序使用的账号赋予 super 权限\"></a>3. 禁止为程序使用的账号赋予 super 权限</h2><ul>\n<li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li>\n<li>super 权限只能留给 DBA 处理问题的账号使用</li>\n</ul>\n<h2 id=\"4-对于程序连接数据库账号-遵循权限最小原则\"><a href=\"#4-对于程序连接数据库账号-遵循权限最小原则\" class=\"headerlink\" title=\"4. 对于程序连接数据库账号,遵循权限最小原则\"></a>4. 对于程序连接数据库账号,遵循权限最小原则</h2><ul>\n<li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li>\n<li>程序使用的账号原则上不准有 drop 权限</li>\n</ul>"}],"PostAsset":[{"_id":"source/_posts/2019/IDEA使用技巧/1.gif","post":"cknb3zrjz000i2ykuaa5w7hnr","slug":"1.gif","modified":1,"renderable":1},{"_id":"source/_posts/2019/IDEA使用技巧/10.gif","post":"cknb3zrjz000i2ykuaa5w7hnr","slug":"10.gif","modified":1,"renderable":1},{"_id":"source/_posts/2019/IDEA使用技巧/2.gif","post":"cknb3zrjz000i2ykuaa5w7hnr","slug":"2.gif","modified":1,"renderable":1},{"_id":"source/_posts/2019/IDEA使用技巧/3.gif","post":"cknb3zrjz000i2ykuaa5w7hnr","slug":"3.gif","modified":1,"renderable":1},{"_id":"source/_posts/2019/IDEA使用技巧/4.gif","post":"cknb3zrjz000i2ykuaa5w7hnr","slug":"4.gif","modified":1,"renderable":1},{"_id":"source/_posts/2019/IDEA使用技巧/5.gif","post":"cknb3zrjz000i2ykuaa5w7hnr","slug":"5.gif","modified":1,"renderable":1},{"_id":"source/_posts/2019/IDEA使用技巧/6.gif","post":"cknb3zrjz000i2ykuaa5w7hnr","slug":"6.gif","modified":1,"renderable":1},{"_id":"source/_posts/2019/IDEA使用技巧/7.gif","post":"cknb3zrjz000i2ykuaa5w7hnr","slug":"7.gif","modified":1,"renderable":1},{"_id":"source/_posts/2019/IDEA使用技巧/8.gif","post":"cknb3zrjz000i2ykuaa5w7hnr","slug":"8.gif","modified":1,"renderable":1},{"_id":"source/_posts/2019/IDEA使用技巧/9.gif","post":"cknb3zrjz000i2ykuaa5w7hnr","slug":"9.gif","modified":1,"renderable":1},{"_id":"source/_posts/2019/常用MySQL优化/1.webp","post":"cknb3zrk6000s2ykuhvtv5xyx","slug":"1.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/常用MySQL优化/2.webp","post":"cknb3zrk6000s2ykuhvtv5xyx","slug":"2.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/常用MySQL优化/3.webp","post":"cknb3zrk6000s2ykuhvtv5xyx","slug":"3.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/常用MySQL优化/4.webp","post":"cknb3zrk6000s2ykuhvtv5xyx","slug":"4.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/常用MySQL优化/5.webp","post":"cknb3zrk6000s2ykuhvtv5xyx","slug":"5.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/常用MySQL优化/6.webp","post":"cknb3zrk6000s2ykuhvtv5xyx","slug":"6.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/常用MySQL优化/7.webp","post":"cknb3zrk6000s2ykuhvtv5xyx","slug":"7.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/常用MySQL优化/8.webp","post":"cknb3zrk6000s2ykuhvtv5xyx","slug":"8.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/树/1.png","post":"cknb3zrka00102yku6sqlbrb0","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/2019/树/2.png","post":"cknb3zrka00102yku6sqlbrb0","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/10.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"10.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/11.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"11.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/12.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"12.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/13.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"13.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/14.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"14.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/15.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"15.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/16.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"16.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/17.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"17.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/19.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"19.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/2.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"2.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/20.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"20.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/21.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"21.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/22.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"22.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/23.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"23.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/24.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"24.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/25.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"25.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/3.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"3.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/4.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"4.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/5.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"5.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/6.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"6.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/640.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"640.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/7.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"7.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/8.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"8.webp","modified":1,"renderable":1},{"_id":"source/_posts/2019/Java虚拟机/9.webp","post":"cknb3zrl800382yku0hrwa13k","slug":"9.webp","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cknb3zrjj00012ykucnyq2ozi","tag_id":"cknb3zrjp00042yku6skogm16","_id":"cknb3zrjw000c2yku09354mmq"},{"post_id":"cknb3zrjm00032ykuday8cep4","tag_id":"cknb3zrjw000b2yku0r7d2zxf","_id":"cknb3zrjz000h2yku7dto94qb"},{"post_id":"cknb3zrjs00062ykud8kkhofc","tag_id":"cknb3zrjy000f2ykud2suc6ub","_id":"cknb3zrk2000l2ykuflmi7rwk"},{"post_id":"cknb3zrju00082yku0hng4xbu","tag_id":"cknb3zrjw000b2yku0r7d2zxf","_id":"cknb3zrk5000p2yku3qo44x0b"},{"post_id":"cknb3zrjv000a2yku2xh8bss3","tag_id":"cknb3zrk4000n2ykuarwwbrrn","_id":"cknb3zrk7000t2yku97074uuu"},{"post_id":"cknb3zrjw000d2ykudbu3cs7c","tag_id":"cknb3zrk6000r2yku9d0l4nqi","_id":"cknb3zrk9000x2ykucou6ftt8"},{"post_id":"cknb3zrk8000v2ykudcqk558o","tag_id":"cknb3zrjw000b2yku0r7d2zxf","_id":"cknb3zrka000z2yku50qo7xh0"},{"post_id":"cknb3zrjx000e2yku9jaf85yj","tag_id":"cknb3zrk6000r2yku9d0l4nqi","_id":"cknb3zrkb00122ykucre678ho"},{"post_id":"cknb3zrkb00132ykudf0fef8x","tag_id":"cknb3zrjw000b2yku0r7d2zxf","_id":"cknb3zrke00162yku629g1g9r"},{"post_id":"cknb3zrjy000g2ykua1ii8i1g","tag_id":"cknb3zrka00112ykub51v8yvx","_id":"cknb3zrkf00182yku5djk8378"},{"post_id":"cknb3zrjz000i2ykuaa5w7hnr","tag_id":"cknb3zrke00152ykuftfb7a5h","_id":"cknb3zrkh001c2ykue39z579m"},{"post_id":"cknb3zrkf00192yku8cbz2c1j","tag_id":"cknb3zrk6000r2yku9d0l4nqi","_id":"cknb3zrki001e2ykuh1bv64wj"},{"post_id":"cknb3zrkg001b2yku88ocbeyl","tag_id":"cknb3zrkg001a2yku6ulbh0oa","_id":"cknb3zrkj001h2ykud12bcc47"},{"post_id":"cknb3zrk1000k2yku7wcg5n23","tag_id":"cknb3zrkg001a2yku6ulbh0oa","_id":"cknb3zrkk001j2yku3k6xczwl"},{"post_id":"cknb3zrkh001d2yku68dog0tz","tag_id":"cknb3zrjp00042yku6skogm16","_id":"cknb3zrkl001m2ykuavme6sdq"},{"post_id":"cknb3zrki001g2ykud0w5541v","tag_id":"cknb3zrjp00042yku6skogm16","_id":"cknb3zrkl001o2yku1w3h05w7"},{"post_id":"cknb3zrkj001i2yku9tr9au1n","tag_id":"cknb3zrjp00042yku6skogm16","_id":"cknb3zrkm001r2ykudcmz6ddk"},{"post_id":"cknb3zrk3000m2ykue3k1a4hu","tag_id":"cknb3zrki001f2yku0ly0cvdi","_id":"cknb3zrkn001t2yku7l4p574d"},{"post_id":"cknb3zrkk001k2yku305h9xct","tag_id":"cknb3zrjw000b2yku0r7d2zxf","_id":"cknb3zrkp001w2yku32vw8ik3"},{"post_id":"cknb3zrkl001n2ykucicwfb9d","tag_id":"cknb3zrjw000b2yku0r7d2zxf","_id":"cknb3zrkq001y2ykual1i8bje"},{"post_id":"cknb3zrk4000o2ykueii55u0b","tag_id":"cknb3zrkk001l2ykucn2j0p8e","_id":"cknb3zrkr00212yku80fjdiq7"},{"post_id":"cknb3zrkm001p2ykueign249s","tag_id":"cknb3zrjw000b2yku0r7d2zxf","_id":"cknb3zrkr00232ykugtkb80l1"},{"post_id":"cknb3zrk5000q2yku23cghni0","tag_id":"cknb3zrkg001a2yku6ulbh0oa","_id":"cknb3zrks00252ykuh3yjdfs7"},{"post_id":"cknb3zrko001u2ykud6gn3n51","tag_id":"cknb3zrjw000b2yku0r7d2zxf","_id":"cknb3zrkt00282ykubqnheymi"},{"post_id":"cknb3zrkp001x2ykufy0d43tp","tag_id":"cknb3zrkg001a2yku6ulbh0oa","_id":"cknb3zrku002a2ykugi9rfvmd"},{"post_id":"cknb3zrk6000s2ykuhvtv5xyx","tag_id":"cknb3zrkg001a2yku6ulbh0oa","_id":"cknb3zrkv002d2yku8siifmqh"},{"post_id":"cknb3zrkq001z2yku03fwduo3","tag_id":"cknb3zrk6000r2yku9d0l4nqi","_id":"cknb3zrkw002f2yku1jsdgzcw"},{"post_id":"cknb3zrkr00222yku7davb1xo","tag_id":"cknb3zrkg001a2yku6ulbh0oa","_id":"cknb3zrkx002i2ykuezbag4xw"},{"post_id":"cknb3zrk7000u2yku8e2rfcxf","tag_id":"cknb3zrkq00202ykuefde0uve","_id":"cknb3zrky002k2yku9ll96pyt"},{"post_id":"cknb3zrks00242yku5xr09ivo","tag_id":"cknb3zrk6000r2yku9d0l4nqi","_id":"cknb3zrkz002n2ykuak070bky"},{"post_id":"cknb3zrkt00272yku4um2ek5z","tag_id":"cknb3zrkg001a2yku6ulbh0oa","_id":"cknb3zrkz002p2ykugzbu09tk"},{"post_id":"cknb3zrk9000y2ykuady37lc1","tag_id":"cknb3zrkg001a2yku6ulbh0oa","_id":"cknb3zrl1002s2yku96db7u6p"},{"post_id":"cknb3zrkv002c2yku4mmieyga","tag_id":"cknb3zrk6000r2yku9d0l4nqi","_id":"cknb3zrl1002t2ykufepohdss"},{"post_id":"cknb3zrka00102yku6sqlbrb0","tag_id":"cknb3zrku002b2yku98dc5ktz","_id":"cknb3zrl1002v2ykubak9dtof"},{"post_id":"cknb3zrkw002h2yku0qud0mou","tag_id":"cknb3zrkg001a2yku6ulbh0oa","_id":"cknb3zrl1002w2ykucy7q80n7"},{"post_id":"cknb3zrkx002j2ykugp64gfis","tag_id":"cknb3zrk6000r2yku9d0l4nqi","_id":"cknb3zrl2002y2yku3iah1ji2"},{"post_id":"cknb3zrkd00142yku6czqhm0x","tag_id":"cknb3zrkw002g2ykuhodiahly","_id":"cknb3zrl2002z2ykucdqu22mx"},{"post_id":"cknb3zrky002l2ykua2n9ht52","tag_id":"cknb3zrkg001a2yku6ulbh0oa","_id":"cknb3zrl200302ykubl7i9fna"},{"post_id":"cknb3zrkz002o2yku9lz8h8i7","tag_id":"cknb3zrjw000b2yku0r7d2zxf","_id":"cknb3zrl200312yku2xcn0u2f"},{"post_id":"cknb3zrke00172ykubtd4g53j","tag_id":"cknb3zrkq00202ykuefde0uve","_id":"cknb3zrl200322yku9m9w2x02"},{"post_id":"cknb3zrl0002q2yku0s85ge74","tag_id":"cknb3zrkg001a2yku6ulbh0oa","_id":"cknb3zrl200332ykubujj1aqt"},{"post_id":"cknb3zrkn001s2yku5hps88pk","tag_id":"cknb3zrkq00202ykuefde0uve","_id":"cknb3zrl200342yku5lluhwu9"},{"post_id":"cknb3zrkt00292yku4ohcaglo","tag_id":"cknb3zrl1002u2ykua0d46wcg","_id":"cknb3zrl200352yku800p9n88"},{"post_id":"cknb3zrkv002e2ykue8qyghnl","tag_id":"cknb3zrl1002x2ykuhpltgcqb","_id":"cknb3zrl200362ykuhifn2dsu"},{"post_id":"cknb3zrl800382yku0hrwa13k","tag_id":"cknb3zrk4000n2ykuarwwbrrn","_id":"cknb3zrl9003a2yku3x26661y"},{"post_id":"cknb3zrl800392yku00rs7l11","tag_id":"cknb3zrk4000n2ykuarwwbrrn","_id":"cknb3zrla003c2ykuamxxgl5r"},{"post_id":"cknb3zrl9003b2yku9ndy8ac1","tag_id":"cknb3zrkg001a2yku6ulbh0oa","_id":"cknb3zrla003d2ykue1om3q2g"}],"Tag":[{"name":"代理","_id":"cknb3zrjp00042yku6skogm16"},{"name":"JS","_id":"cknb3zrjw000b2yku0r7d2zxf"},{"name":"JAVA","_id":"cknb3zrjy000f2ykud2suc6ub"},{"name":"Java","_id":"cknb3zrk4000n2ykuarwwbrrn"},{"name":"Node.js","_id":"cknb3zrk6000r2yku9d0l4nqi"},{"name":"版本控制","_id":"cknb3zrka00112ykub51v8yvx"},{"name":"IDE","_id":"cknb3zrke00152ykuftfb7a5h"},{"name":"数据库","_id":"cknb3zrkg001a2yku6ulbh0oa"},{"name":"并发","_id":"cknb3zrki001f2yku0ly0cvdi"},{"name":"Shell","_id":"cknb3zrkk001l2ykucn2j0p8e"},{"name":"杂谈","_id":"cknb3zrkq00202ykuefde0uve"},{"name":"数据结构","_id":"cknb3zrku002b2yku98dc5ktz"},{"name":"系统设计","_id":"cknb3zrkw002g2ykuhodiahly"},{"name":"面经","_id":"cknb3zrl1002u2ykua0d46wcg"},{"name":"容器","_id":"cknb3zrl1002x2ykuhpltgcqb"}]}}